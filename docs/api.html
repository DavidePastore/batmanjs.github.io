<div>
    <h2>batman.js</h2>
    <p><a href="http://batmanjs.org/">batman.js</a> is a framework for building rich single-page browser applications. It is written in <a href="http://jashkenas.github.com/coffee-script/">CoffeeScript</a> and its API is developed with CoffeeScript in mind, but of course you can use plain old JavaScript too.</p>
<h3>It&#39;s got:</h3>
<ul>
<li>a stateful MVC architecture</li>
<li>a powerful binding system</li>
<li>routable controller actions</li>
<li>pure HTML views</li>
<li>toolchain support built on <a href="http://nodejs.org">node.js</a> and <a href="http://jashkenas.github.com/coffee-script/#cake">cake</a></li>
</ul>
<p>Batman&#39;s API is heavily inspired by <a href="http://rubyonrails.org/">Rails</a> and designed to make Rails devs feel right at home.</p>
<h3>Platforms</h3>
<p>Batman runs in node and the browser. Batman supports node v0.8.x. We&#39;re targeting Chrome, Safari 4+, Firefox 3+, and IE 7+ for compatibility. Batman expects ES5 features like <code>Function::bind</code> and <code>Array::map</code>, so we recommend poly-filling these for older browsers with something like <a href="https://github.com/kriskowal/es5-shim">es5shim</a> or <a href="http://augmentjs.com/">augmentjs</a>. Batman also expects <code>JSON.parse</code>, which can be implemented in browsers without it using <a href="https://github.com/douglascrockford/JSON-js">json2.js</a>.</p>

      <h3>Installation</h3>
      <p>Batman is available as a standalone download or as an <code>npm</code> package.</p>
<h3>Standalone Browser Version</h3>
<p>Versions of batman suitable for use in a web application are available at GitHub.</p>
<h3>node.js</h3>
<p>If you haven&#39;t already, you&#39;ll need to install <a href="http://nodejs.org">node.js</a>. Then:</p>
<p><code>bash
npm install -g batman</code></p>
<p>Generate a new batman.js app somewhere, called my_app:</p>
<p><code>bash
cd ~/code
batman new my_app</code></p>
<p>Fire it up:</p>
<p><code>bash
cd my_app
batman server # (or just &quot;batman s&quot;)</code></p>
<p>Now visit <a href="http://localhost:1047"><a href="http://localhost:1047">http://localhost:1047</a></a> and start playing around!</p>

      <h3>Architecture</h3>
      <p>Batman prescribes an MVC architecture for client side applications which fits together like this:</p>
<ul>
<li>Models have validations, lifecycle events, a built-in identity map, and can be told how to persist themselves. (<code>Batman.LocalStorage</code>, <code>Batman.RestStorage</code>, and <code>Batman.RailsStorage</code> are included).</li>
<li>Views are JavaScript classes which render templates written in pure HTML. The templates use <code>data-*</code> attributes to create bindings to model data and trigger event handlers.</li>
<li>Controllers are persistent objects which mediate access to the model data, render the views, and handle events from the views.</li>
</ul>
<p>A batman.js application is served up in one page load, followed by asynchronous requests for various resources as the user interacts with the app. Navigation within the app can use <a href="https://developer.mozilla.org/en/DOM/Manipulating_the_browser_history#Adding_and_modifying_history_entries">pushState</a> where supported, or fall back on to <a href="http://www.w3.org/QA/2011/05/hash_uris.html">hash-bang fragment identifers</a>.</p>

    <hr />
    <h2>Batman Helpers</h2>
    <p>Batman includes a number of useful, general purpose helper functions and references. They can all be found attached to the <code>Batman</code> object and can optionally be exported into the global namespace with a <code>$</code> prefix.</p>

      <h3>container</h3>
      <p><code>Batman.container</code> points to either the <code>window</code> object if running in the browser, or the <code>global</code> object if running in node. This is useful if you want to add something to the global scope in all environments.</p>

      <h3>typeOf(object) : string</h3>
      <p><code>typeOf</code> determines a more specific type of an <code>object</code> than the native <code>typeof</code> operator in JavaScript. This is useful for a number of situations like dealing with <code>Object</code> promoted strings and numbers, or arrays which look like <code>object</code>s to <code>typeof</code>. Use <code>typeOf</code> when you need more than <code>&quot;object&quot;</code> from <code>typeof</code>.</p>
<p><em>Note</em>: <code>typeOf</code> is substantially slower than <code>typeof</code>. <code>typeOf</code> works in a somewhat hackish manner by getting the <code>Object::toString</code> representation of the object and slicing it to retrieve the name of the constructor.</p>
<pre><code><span class="title">test</span><span class="string"> 'typeOf returns "String" for both strings and Object strings'</span>, -&gt;
  primitive = <span class="string">"test"</span>
  objectified = new <span class="type">String</span>(<span class="string">"test"</span>)
  equal <span class="typedef">typeof primitive, "string"</span>
  equal <span class="typedef">typeof objectified, "object"</span>
  equal <span class="type">Batman</span>.<span class="typedef">typeOf<span class="container">(<span class="title">primitive</span>)</span>, "<span class="type">String</span>"</span>
  equal <span class="type">Batman</span>.<span class="typedef">typeOf<span class="container">(<span class="title">objectified</span>)</span>, "<span class="type">String</span>"</span>

<span class="title">test</span><span class="string"> 'typeOf returns Array for arrays'</span>, -&gt;
  array = [];
  equal <span class="typedef">typeof array, "object"</span>
  equal <span class="type">Batman</span>.<span class="typedef">typeOf<span class="container">(<span class="title">array</span>)</span>, "<span class="type">Array</span>"</span></code></pre>

      <h3>mixin(subject, objects...) : subject</h3>
      <p><code>mixin</code>, occasionally known elsewhere as <code>extend</code> or <code>merge</code>, flattens a series of objects onto the subject. Key/value pairs on objects passed as later arguments (arguments with a higher index) take precedence over earlier arguments. Returns the <code>subject</code> passed in with the new values.</p>
<p><code>mixin</code> also has special properties that make it different than the canonical <code>extend</code> functions:</p>
<ol>
<li>If the <code>subject</code> has a <code>set</code> function, <code>subject.set(key, value)</code> will be used to apply keys instead of <code>subject[key] = value</code>. This means that if the subject is a <code>Batman.Object</code>, observers and thus bindings on the object will be notified when other (Batmanified or not) objects are mixed into it.</li>
<li>If a mixed-in <code>object</code> has an <code>initialize</code> function defined, that function will be called and passed the <code>subject</code>. This is useful for custom extension logic, similar to <code>self.included</code> in Ruby. For this reason, the keys <code>initialize</code> and <code>uninitialize</code> are skipped by <code>mixin</code>.</li>
<li><code>mixin</code> only iterates over keys for which the <code>hasOwnProperty</code> test passes.</li>
</ol>
<p><em>Note</em>: <code>mixin</code> is destructive to (only) the first argument. If you need a non-destructive version of <code>mixin</code>, just pass an empty object as the first object, and all keys from the successive arguments will be applied to the empty object.</p>
<pre><code>test <span class="string">'mixin merges argument objects'</span>, -&gt;
  subject = {}
  deepEqual <span class="class">Batman</span>.mixin(subject, {<span class="method">fit:</span> <span class="keyword">true</span>}, {<span class="method">fly:</span> <span class="keyword">true</span>}, {<span class="method">funky:</span> <span class="keyword">true</span>}), {<span class="method">fit:</span> <span class="keyword">true</span>, <span class="method">fly:</span> <span class="keyword">true</span>, <span class="method">funky:</span> <span class="keyword">true</span>}, <span class="comment">"mixin returns the subject"</span>
  deepEqual subject, {<span class="method">fit:</span> <span class="keyword">true</span>, <span class="method">fly:</span> <span class="keyword">true</span>, <span class="method">funky:</span> <span class="keyword">true</span>}, <span class="comment">"the subject is modified destructively"</span>

test <span class="string">'mixin merges argument objects'</span>, -&gt;
  unmodified = {<span class="method">fit:</span> <span class="keyword">true</span>}
  deepEqual <span class="class">Batman</span>.mixin({}, unmodified, {<span class="method">fly:</span> <span class="keyword">true</span>}, {<span class="method">funky:</span> <span class="keyword">true</span>}), {<span class="method">fit:</span> <span class="keyword">true</span>, <span class="method">fly:</span> <span class="keyword">true</span>, <span class="method">funky:</span> <span class="keyword">true</span>}, <span class="comment">"mixin returns the subject"</span>
  deepEqual unmodified, {<span class="method">fit:</span> <span class="keyword">true</span>}, <span class="comment">"argument objects are untouched allowing non-destructive merge"</span>

test <span class="string">'mixed in objects passed as higher indexed arguments take precedence'</span>, -&gt;
  subject = {}
  deepEqual <span class="class">Batman</span>.mixin(subject, {<span class="method">x:</span> <span class="number">1</span>, <span class="method">y:</span> <span class="number">1</span>}, {<span class="method">x:</span> <span class="number">2</span>}), {<span class="method">x:</span> <span class="number">2</span>, <span class="method">y:</span> <span class="number">1</span>}</code></pre>

      <h3>unmixin(subject, objects...) : subject</h3>
      <p><code>unmixin</code> &quot;unmerges&quot; the passed objects from the <code>subject</code>. If a key exists on any of the <code>objects</code> it will be <code>delete</code>d from the <code>subject</code>. Returns the <code>subject</code>.</p>
<p><code>unmixin</code>, similar to <code>mixin</code>, supports calling an <code>uninitialize</code> function for each of the <code>objects</code> being unmixed in. If an <code>uninitialize</code> function exists on each</p>
<pre><code>test <span class="string">'unmixin removes keys found on the unmixined objects on the subject'</span>, -&gt;
  subject = {<span class="method">fit:</span> <span class="keyword">true</span>, <span class="method">fly:</span> <span class="keyword">true</span>, <span class="method">funky:</span> <span class="keyword">true</span>}
  deepEqual <span class="class">Batman</span>.unmixin(subject, {<span class="method">fit:</span> <span class="keyword">true</span>}, {<span class="method">fly:</span> <span class="keyword">true</span>}), {<span class="method">funky:</span> <span class="keyword">true</span>}, <span class="comment">"unmixin returns the subject"</span>
  deepEqual subject, {<span class="method">funky:</span> <span class="keyword">true</span>}, <span class="comment">"the subject is destructively modified."</span></code></pre>

      <h3>functionName(function) : string</h3>
      <p><code>functionName</code> returns the name of a given function, if any. Works with Internet Explorer 7/8/9, FireFox, Chrome, and Safari.</p>
<pre><code>test 'functionName returns <span class="keyword">the</span> <span class="property">name</span> <span class="keyword">of</span> a <span class="keyword">given</span> function', -&gt;
  <span class="keyword">equal</span> Batman.functionName(<span class="string">""</span>.toString), 'toString'</code></pre>

      <h3>isChildOf(parent : HTMLElement, child : HTMLElement) : boolean</h3>
      <p><code>isChildOf</code> is a simple DOM helper which returns a boolean describing if the passed <code>child</code> node can be found in the descendants of the passed <code>parent</code> node.</p>

      <h3>setImmediate(callback : Function) : object</h3>
      <p><code>setImmediate</code> (and its sister <code>clearImmediate</code>) are a more efficient version of <code>setTimeout(callback, 0)</code>. Due to timer resolution issues, setTimeout passed a timeout of 0 doesn&#39;t actually execute the function as soon as the JS execution stack has been emptied, but at minimum 4ms and maxmium 25ms after. For this reason Batman provides a cross browser implementation of <code>setImmediate</code> which does its best to call the callback immediately after the stack empties. Batman&#39;s <code>setImmediate</code> polyfill uses the native version if available, <code>window.postmessage</code> trickery if supported, and falls back on <code>setTimeout(-&gt;, 0)</code>.</p>
<p><code>setImmediate</code> returns a handle which can be passed to <code>clearImmediate</code> to cancel the future calling of the callback.</p>

      <h3>clearImmediate(handle)</h3>
      <p><code>clearImmediate</code> stops the calling of a callback in the future when passed its <code>handle</code> (which is returned from the <code>setImmediate</code> call used to enqueue it).</p>

      <h3>forEach(iterable : object, iterator : Function[, context : Object])</h3>
      <p>The <code>forEach</code> Batman helper is a universal iteration helper. When passed an <code>iterable</code> object, the helper will call the <code>iterator</code> (optionally in the <code>context</code>) for each item in the <code>iterable</code>. The <code>iterable</code> can be:</p>
<ol>
<li>something which has its own <code>forEach</code>, in which case the <code>iterator</code> will just be passed to <code>iterable.forEach</code>.</li>
<li>an array like object, in which case a JavaScript <code>for(;;)</code> loop will be used to iterate over each entry</li>
<li>or an object, in which case a JavaScript <code>for-in</code> loop will be used to iterate over each entry.</li>
</ol>
<p>The <code>forEach</code> helper is useful for iterating over objects when the type of those objects isn&#39;t guaranteed.</p>
<pre><code>test <span class="comment">'forEach iterates over objects with forEach defined', -&gt;</span>
  results = []
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.SimpleSet(<span class="comment">'a')</span>
  Batman.forEach(<span class="keyword">set</span>, (x) -&gt; results.push(x))
  deepEqual results, [<span class="comment">'a']</span>

test <span class="comment">'forEach iterates over array like objects', -&gt;</span>
  results = []
  ArrayLike = -&gt;
  ArrayLike:: = []
  imitation = <span class="keyword">new</span> ArrayLike
  <span class="built_in">Array</span>::push.<span class="keyword">call</span>(imitation, <span class="string">"a"</span>)
  <span class="built_in">Array</span>::push.<span class="keyword">call</span>(imitation, <span class="string">"b"</span>)
  Batman.forEach(imitation, (x) -&gt; results.push(x))
  deepEqual results, [<span class="comment">'a', 'b']</span>

test <span class="comment">'forEach iterates over objects', -&gt;</span>
  result = {}
  object = {x: <span class="literal">true</span>}
  Batman.forEach(object, (key, val) -&gt; result[key] = val)
  console.<span class="built_in">log</span>(<span class="comment">'result', result)</span>
  deepEqual result, object</code></pre>

      <h3>objectHasKey(object, key) : boolean</h3>
      <p><code>objectHasKey</code> returns a boolean describing the presence of the <code>key</code> in the passed <code>object</code>. <code>objectHasKey</code> delegates to the <code>object</code>&#39;s <code>hasKey</code> function if present, and otherwise just does a check using the JavaScript <code>in</code> operator.</p>
<pre><code>test 'objectHasKey verifies <span class="keyword">if</span> a key <span class="keyword">is</span> present <span class="keyword">in</span> an object', -&gt;
  subject = {fit: <span class="constant">true</span>}
  ok Batman.objectHasKey(subject, 'fit')
  <span class="keyword">equal</span> Batman.objectHasKey(subject, 'flirty'), <span class="constant">false</span>

test 'objectHasKey verifies <span class="keyword">if</span> a key <span class="keyword">is</span> present <span class="keyword">in</span> an object <span class="keyword">with</span> `hasKey` defined', -&gt;
  subject = new Batman.SimpleHash {fit: <span class="constant">true</span>}
  ok Batman.objectHasKey(subject, 'fit')
  <span class="keyword">equal</span> Batman.objectHasKey(subject, 'flirty'), <span class="constant">false</span></code></pre>

      <h3>contains(object, item) : boolean</h3>
      <p><code>contains</code> returns a boolean describing if the given <code>object</code> has member <code>item</code>. Membership in this context is defined as:</p>
<ul>
<li>the result of <code>object.has(item)</code> if the <code>object</code> has a <code>has</code> function defined</li>
<li>the result of <code>item in object</code> if the <code>object</code> is arraylike</li>
<li>the result of the Batman.objectHasKey otherwise</li>
</ul>
<p><em>Note</em>: When passed an object without a <code>has</code> function, <code>contains</code> will return <code>true</code> if the <code>object</code> has <code>item</code> as a <em><code>key</code></em>, not as a value at any key.</p>
<p><code>contains</code> is useful for checking item membership when the type of the object can&#39;t be relied on.</p>

      <h3>get(object, key) : value</h3>
      <p><code>get</code> is a general purpose function for retrieving the value from a <code>key</code> on an <code>object</code> of an indeterminate type. This is useful if code needs to work with both <code>Batman.Object</code>s and Plain Old JavaScript Objects. <code>get</code> has the following semantics:</p>
<ul>
<li>if the <code>object</code> has a <code>get</code> function defined, return the result of <code>object.get(key)</code></li>
<li><p>if the object does not have a <code>get</code> function defined, use an ephemeral <code>Batman.Property</code> to retrieve the key. This is equivalent to <code>object[key]</code> for single segment <code>key</code>s, but if the <code>key</code> is multi-segment (example: &#39;product.customer.name&#39;), <code>get</code> will do nested gets until the either <code>undefined</code> or the end of the keypath is reached.</p>
<p> test &#39;get returns the value at a key on a POJO&#39;, -&gt;
   subject = {fit: true}
   equal Batman.get(subject, &#39;fit&#39;), true
   equal Batman.get(subject, &#39;flirty&#39;), undefined</p>
<p> test &#39;get returns the value at a key on a Batman.Object&#39;, -&gt;
   subject = Batman {fit: true}
   equal Batman.get(subject, &#39;fit&#39;), true
   equal Batman.get(subject, &#39;flirty&#39;), undefined</p>
<p> test &#39;get returns the value at a deep key on a POJO&#39;, -&gt;
   subject = {customer: {name: &quot;Joe&quot;}}
   equal Batman.get(subject, &#39;customer.name&#39;), &quot;Joe&quot;
   equal Batman.get(subject, &#39;customer.age&#39;), undefined</p>
<p> test &#39;get returns the value at a deep key on a Batman.Object&#39;, -&gt;
   subject = Batman {customer: {name: &quot;Joe&quot;}}
   equal Batman.get(subject, &#39;customer.name&#39;), &quot;Joe&quot;
   equal Batman.get(subject, &#39;customer.age&#39;), undefined</p>
</li>
</ul>

      <h3>getPath(base, segments) : string</h3>
      <p><code>getPath</code> returns the hash value denoted by the specified path, which consists of an array of nested hash keys. See examples below for more detail.</p>
<pre><code>test <span class="string">"takes a base and an array of keys and returns the corresponding nested value"</span>, -&gt;
  @complexObject = <span class="keyword">new</span> Batman.Object
    hash: <span class="keyword">new</span> Batman.Hash
      foo: <span class="keyword">new</span> Batman.Object(bar: <span class="attribute">'nested</span> value'),
      <span class="string">"foo.bar"</span>: <span class="attribute">'flat</span> value'
  equal Batman.getPath(@complexObject, [<span class="attribute">'hash</span>', <span class="attribute">'foo</span>', <span class="attribute">'bar</span>']), <span class="attribute">'nested</span> value'
  equal Batman.getPath(@complexObject, [<span class="attribute">'hash</span>', <span class="attribute">'foo</span>.bar']), <span class="attribute">'flat</span> value'
  strictEqual Batman.getPath(@complexObject, [<span class="attribute">'hash</span>', <span class="attribute">'not</span>-foo', <span class="attribute">'bar</span>']), undefined

test <span class="string">"returns just the base if the key array is empty"</span>, -&gt;
  @complexObject = <span class="keyword">new</span> Batman.Object
    hash: <span class="keyword">new</span> Batman.Hash
      foo: <span class="keyword">new</span> Batman.Object(bar: <span class="attribute">'nested</span> value'),
      <span class="string">"foo.bar"</span>: <span class="attribute">'flat</span> value'
  strictEqual Batman.getPath(@complexObject, []), @complexObject
  strictEqual Batman.getPath(<span class="keyword">null</span>, []), <span class="keyword">null</span>

test <span class="string">"returns undefined if the base is null-ish"</span>, -&gt;
  @complexObject = <span class="keyword">new</span> Batman.Object
    hash: <span class="keyword">new</span> Batman.Hash
      foo: <span class="keyword">new</span> Batman.Object(bar: <span class="attribute">'nested</span> value'),
      <span class="string">"foo.bar"</span>: <span class="attribute">'flat</span> value'
  strictEqual Batman.getPath(<span class="keyword">null</span>, [<span class="attribute">'foo</span>']), undefined
  strictEqual Batman.getPath(undefined, [<span class="attribute">'foo</span>']), undefined

test <span class="string">"returns falsy values"</span>, -&gt;
  @complexObject = <span class="keyword">new</span> Batman.Object
    hash: <span class="keyword">new</span> Batman.Hash
      foo: <span class="keyword">new</span> Batman.Object(bar: <span class="attribute">'nested</span> value'),
      <span class="string">"foo.bar"</span>: <span class="attribute">'flat</span> value'
  strictEqual Batman.getPath(num: <span class="number">0</span>, [<span class="attribute">'num</span>']), <span class="number">0</span>
  strictEqual Batman.getPath(thing: <span class="keyword">null</span>, [<span class="attribute">'thing</span>']), <span class="keyword">null</span></code></pre>

      <h3>escapeHTML(string) : string</h3>
      <p><code>escapeHTML</code> takes a string of unknown origin and makes it safe for display on a web page by encoding control characters in HTML into their HTML entities.</p>
<p><em>Warning</em>: Do not rely on <code>escapeHTML</code> to purge unsafe data from user submitted content. While <code>escapeHTML</code> is applied to every binding&#39;s contents by default, it should not be your only line of defence against script injection attacks.</p>
<pre><code>test 'escapeHTML encodes special <span class="property">characters</span> <span class="keyword">into</span> HTML entities', -&gt;
  <span class="keyword">equal</span> Batman.escapeHTML(<span class="string">"&amp; &lt; &gt; \" '"</span>), <span class="string">"&amp;amp; &amp;lt; &amp;gt; &amp;#34; &amp;#39;"</span></code></pre>

    <hr />
    <h2>Batman.helpers</h2>
    <p><code>Batman.helpers</code> is a namespace for Batman&#39;s helpful string manipulation helpers.</p>
<p><em>Note</em>: Batman&#39;s pluralization functions mirror those of Rails&#39; exactly.</p>

      <h3>ordinalize(value : [number|string]) : string</h3>
      <p><code>ordinalize</code> converts a given integer into an ordinal string for describing position in a list, like 1st, 2nd, or 20th.</p>
<pre><code><span class="comment">test</span> <span class="comment">'ordinalize</span> <span class="comment">converts</span> <span class="comment">numbers</span> <span class="comment">to</span> <span class="comment">their</span> <span class="comment">ordinal</span> <span class="comment">form'</span>, <span class="literal">-</span>&gt;
  <span class="comment">equal</span> <span class="comment">Batman</span>.<span class="comment">helpers</span>.<span class="comment">ordinalize(1)</span>     <span class="string">,</span> <span class="comment">"1st"</span>
  <span class="comment">equal</span> <span class="comment">Batman</span>.<span class="comment">helpers</span>.<span class="comment">ordinalize("2")</span>     <span class="string">,</span> <span class="comment">"2nd"</span>
  <span class="comment">equal</span> <span class="comment">Batman</span>.<span class="comment">helpers</span>.<span class="comment">ordinalize(1002)</span>  <span class="string">,</span> <span class="comment">"1002nd"</span>
  <span class="comment">equal</span> <span class="comment">Batman</span>.<span class="comment">helpers</span>.<span class="comment">ordinalize("1003")</span>  <span class="string">,</span> <span class="comment">"1003rd"</span>
  <span class="comment">equal</span> <span class="comment">Batman</span>.<span class="comment">helpers</span>.<span class="comment">ordinalize(</span>-<span class="comment">11)</span>   <span class="string">,</span> <span class="comment">"</span>-<span class="comment">11th"</span>
  <span class="comment">equal</span> <span class="comment">Batman</span>.<span class="comment">helpers</span>.<span class="comment">ordinalize(</span>-<span class="comment">1021)</span> <span class="string">,</span> <span class="comment">"</span>-<span class="comment">1021st"</code></pre>

      <h3>singularize(pluralString : string) : string</h3>
      <p><code>singularize</code> converts the plural form of a word to a singular form.</p>
<pre><code>test 'singularize converts plural <span class="property">words</span> <span class="keyword">to</span> singular <span class="property">words</span>', -&gt;
  <span class="keyword">equal</span> Batman.helpers.singularize(<span class="string">"posts"</span>), <span class="string">"post"</span>
  <span class="keyword">equal</span> Batman.helpers.singularize(<span class="string">"octopi"</span>), <span class="string">"octopus"</span>
  <span class="keyword">equal</span> Batman.helpers.singularize(<span class="string">"sheep"</span>), <span class="string">"sheep"</span>
  <span class="keyword">equal</span> Batman.helpers.singularize(<span class="string">"word"</span>), <span class="string">"word"</span>
  <span class="keyword">equal</span> Batman.helpers.singularize(<span class="string">"CamelOctopi"</span>), <span class="string">"CamelOctopus"</span></code></pre>

      <h3>pluralize(singularString : string) : string</h3>
      <p><code>pluralize</code> converts the singular form of a word to the plural form.</p>
<pre><code>test 'pluralize converts plural <span class="property">words</span> <span class="keyword">to</span> singular <span class="property">words</span>', -&gt;
  <span class="keyword">equal</span> Batman.helpers.pluralize(<span class="string">"post"</span>), <span class="string">"posts"</span>
  <span class="keyword">equal</span> Batman.helpers.pluralize(<span class="string">"octopus"</span>), <span class="string">"octopi"</span>
  <span class="keyword">equal</span> Batman.helpers.pluralize(<span class="string">"sheep"</span>), <span class="string">"sheep"</span>
  <span class="keyword">equal</span> Batman.helpers.pluralize(<span class="string">"words"</span>), <span class="string">"words"</span>
  <span class="keyword">equal</span> Batman.helpers.pluralize(<span class="string">"CamelOctopus"</span>), <span class="string">"CamelOctopi"</span></code></pre>

      <h3>camelize(string, [lowercaseFirstLetter = false]) : string</h3>
      <p><code>camelize</code> converts the passed <code>string</code> to UpperCamelCase. If the second argument is passed as <code>true</code>, then lowerCamelCase is returned.</p>
<pre><code>test 'camelize returns <span class="keyword">the</span> CamelCase <span class="property">version</span> <span class="keyword">of</span> an under_scored <span class="property">word</span>', -&gt;
  <span class="keyword">equal</span> Batman.helpers.camelize(<span class="string">"batman_object"</span>), <span class="string">"BatmanObject"</span>
  <span class="keyword">equal</span> Batman.helpers.camelize(<span class="string">"batman_object"</span>, <span class="constant">true</span>), <span class="string">"batmanObject"</span></code></pre>

      <h3>underscore(string) : string</h3>
      <p><code>underscore</code> returns the underscored version of a CamelCase word.</p>
<pre><code>test <span class="attribute">'underscore</span> converts CamelCase <span class="keyword">to</span> under_scores', -&gt;
  equal Batman.helpers.underscore(<span class="string">"BatmanObject"</span>), <span class="string">"batman_object"</span></code></pre>

      <h3>capitalize(string) : string</h3>
      <p><code>capitalize</code> does a word-wise capitalization of a phrase or word.</p>
<pre><code>test 'capitalize makes <span class="keyword">the</span> <span class="keyword">first</span> letter <span class="keyword">of</span> each <span class="property">word</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">string</span> uppercase', -&gt;
  <span class="keyword">equal</span> Batman.helpers.capitalize(<span class="string">"batmanObject"</span>), <span class="string">"BatmanObject"</span>
  <span class="keyword">equal</span> Batman.helpers.capitalize(<span class="string">"batman object"</span>), <span class="string">"Batman Object"</span>
  <span class="keyword">equal</span> Batman.helpers.capitalize(<span class="string">"AlreadyCapitalized"</span>), <span class="string">"AlreadyCapitalized"</span></code></pre>

      <h3>trim(string) : string</h3>
      <p><code>trim</code> trims a string getting rid of extra white space around the string or returning an empty string if it is null.</p>
<pre><code>test 'trim gets rid <span class="keyword">of</span> <span class="constant">space</span> <span class="keyword">around</span> a <span class="type">string</span>', -&gt;
  <span class="keyword">equal</span> Batman.helpers.trim(<span class="string">"TrimRight "</span>), <span class="string">"TrimRight"</span>
  <span class="keyword">equal</span> Batman.helpers.trim(<span class="string">" TrimLeft"</span>), <span class="string">"TrimLeft"</span>
  <span class="keyword">equal</span> Batman.helpers.trim(<span class="string">" TrimBothSides "</span>), <span class="string">"TrimBothSides"</span>
  <span class="keyword">equal</span> Batman.helpers.trim(<span class="string">"AlreadyTrimmed"</span>), <span class="string">"AlreadyTrimmed"</span>

test 'trim turns a null <span class="keyword">or</span> undefined <span class="type">string</span> <span class="keyword">into</span> an empty <span class="type">string</span>', -&gt;
  <span class="keyword">equal</span> Batman.helpers.trim(null), <span class="string">""</span>
  <span class="keyword">equal</span> Batman.helpers.trim(undefined), <span class="string">""</span></code></pre>

      <h3>interpolate(stringOrObject, keys) : string</h3>
      <p><code>interpolate</code> interpolates a string, filling it in with values matching interpolation keys, similar to printf variants.</p>
<pre><code>test 'interpolate fills <span class="flow">in</span> key values globally <span class="flow">in</span> a string', -&gt;
  equal Batman.helpers.interpolate("%{field} must be at least %{count} characters <span class="flow">in</span> order <span class="flow">for</span> %{field} to be valid", count: "<span class="number">3</span>", field: "name"), "name must be at least <span class="number">3</span> characters <span class="flow">in</span> order <span class="flow">for</span> name to be valid"

test 'interpolate fills <span class="flow">in</span> key values globally <span class="flow">in</span> an object-embedded string', -&gt;
  equal Batman.helpers.interpolate({'other': "%{field} must be at least %{count} characters <span class="flow">in</span> order <span class="flow">for</span> %{field} to be valid"}, count: "<span class="number">3</span>", field: "name"), "name must be at least <span class="number">3</span> characters <span class="flow">in</span> order <span class="flow">for</span> name to be valid"

test 'interpolate fills <span class="flow">in</span> key values globally <span class="flow">in</span> an object-embedded string, embedded by key count', -&gt;
  equal Batman.helpers.interpolate({<span class="number">3</span>: "%{field} must be at least %{count} characters <span class="flow">in</span> order <span class="flow">for</span> %{field} to be valid"}, count: "<span class="number">3</span>", field: "name"), "name must be at least <span class="number">3</span> characters <span class="flow">in</span> order <span class="flow">for</span> name to be valid"</code></pre>

      <h3>humanize(string) : string</h3>
      <p><code>humanize</code> reformats a string that has a programmatic meaning (camelcased, underscored, &quot;_id&quot; suffixed) to make human-readable by separating concatenated words and/or getting rid of the &quot;_id&quot; suffix.</p>
<pre><code>test <span class="attribute">'humanize</span> replaces underscores <span class="keyword">and</span> dashes <span class="keyword">with</span> empty space', -&gt;
  equal Batman.helpers.humanize(<span class="attribute">'underscored_string</span>'), <span class="attribute">'Underscored</span> <span class="typename">string</span>'
  equal Batman.helpers.humanize(<span class="attribute">'dash</span>-separated-<span class="typename">string</span>'), <span class="attribute">'Dash</span> separated <span class="typename">string</span>'

test <span class="attribute">'humanize</span> splits camel cased words by empty space', -&gt;
  equal Batman.helpers.humanize(<span class="attribute">'CamelCasedString</span>'), <span class="attribute">'Camel</span> cased <span class="typename">string</span>'

test <span class="attribute">'humanize</span> title-cases the first word', -&gt;
  equal Batman.helpers.humanize(<span class="attribute">'lower</span> <span class="keyword">case</span> sentence'), <span class="attribute">'Lower</span> <span class="keyword">case</span> sentence'

test <span class="attribute">'humanize</span> lower-cases <span class="keyword">all</span> words <span class="keyword">after</span> the first one', -&gt;
  equal Batman.helpers.humanize(<span class="attribute">'Mixed</span> <span class="keyword">Case</span> SENTENCE'), <span class="attribute">'Mixed</span> <span class="keyword">case</span> sentence'

test <span class="attribute">'humanize</span> gets rid <span class="keyword">of</span> _id suffix', -&gt;
  equal Batman.helpers.humanize(<span class="attribute">'identifying_string_id</span>'), <span class="attribute">'Identifying</span> <span class="typename">string</span>'</code></pre>

      <h3>Batman.EventEmitter</h3>
      <p><code>EventEmitter</code> is a mixin which can be applied to any object to give it the ability to fire events and accept listeners for those events.</p>
<h3>on(key, handler)</h3>
<p>Attaches a function <code>handler</code> to the event with name <code>key</code>. This function will be executed every time the event fires.</p>
<pre><code>test 'event handlers execute when attached <span class="keyword">with</span> <span class="keyword">on</span>', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  ok dynamite.<span class="function_start"><span class="keyword">on</span> </span>'detonate', -&gt; <span class="command">log</span> <span class="string">"detonated"</span></code></pre>
<h3>fire(key, arguments...)</h3>
<p>Calls all previously attached handlers on the event with name <code>key</code>. All handlers will receive the passed <code>arguments</code>.</p>
<p><em>Note</em>: Calling <code>fire</code> doesn&#39;t guarantee the event will fire since firing can be prevented with <code>prevent</code> or <code>preventAll</code>.</p>
<pre><code>test <span class="string">'event handlers are fired'</span>, -&gt;
  dynamite = <span class="variable">$mixin</span> {}, Batman.EventEmitter
  dynamite.on <span class="string">'detonate'</span>, (noise) -&gt; <span class="keyword">log</span> <span class="string">"detonated with noise #{noise}"</span>
  dynamite.fire <span class="string">'detonate'</span>, <span class="string">"BOOM!"</span>
  equal logged.<span class="keyword">last</span>, <span class="string">"detonated with noise BOOM!"</span></code></pre>
<h3>hasEvent(key) : boolean</h3>
<p>Asks if the <code>EventEmitter</code> has an event with the given <code>key</code>.</p>
<pre><code>test 'events can be tested <span class="keyword">for</span> presence', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  dynamite.<span class="function_start"><span class="keyword">on</span> </span>'detonate', -&gt; <span class="command">log</span> <span class="string">"detonated"</span>
  ok dynamite.hasEvent('detonate')
  <span class="keyword">equal</span> dynamite.hasEvent('click'), <span class="constant">false</span></code></pre>
<h3>oneShot : boolean</h3>
<p>Events can be set to fire only once, and then fire subsequently attached handlers immediately if they are attached after the initial firing. This is useful for events similar to <code>window.onload</code> where they really only happen once in the lifespan of the application, but you don&#39;t want to check if they have happened already when attaching event handlers.</p>
<p>Access the <code>Event</code> object to set the <code>oneShot</code> property on them using <code>EventEmitter::event</code>.</p>
<pre><code>test 'one shot events fire handlers attached <span class="keyword">after</span> they have fired <span class="keyword">for</span> <span class="keyword">the</span> <span class="keyword">first</span> <span class="property">time</span>', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  dynamite.event('detonate').oneShot = <span class="constant">true</span>
  dynamite.fire('detonate')
  dynamite.<span class="function_start"><span class="keyword">on</span> </span>'detonate', -&gt; <span class="command">log</span> <span class="string">"detonated immediately!!"</span>
  <span class="keyword">equal</span> logged.<span class="keyword">last</span>, <span class="string">"detonated immediately!!"</span>, <span class="string">"The handler was called as soon as it was attached."</span></code></pre>
<h3>prevent(key) : EventEmitter</h3>
<p>Prevents the event with name <code>key</code> from firing, even if <code>.fire</code> is called. This is useful if you need to guarantee a precondition has been fulfilled before allowing event handlers to execute. Returns the event emitting object.</p>
<p>Undo event prevention with <code>allow</code> or <code>allowAndFire</code>.</p>
<p><em>Note</em>: <code>prevent</code> can be called more than once to effectively &quot;nest&quot; preventions. <code>allow</code> or <code>allowAndFire</code> must be called the same number of times or more for events to fire once more.</p>
<pre><code>test <span class="string">'events can be prevented'</span>, -&gt;
  dynamite = <span class="variable">$mixin</span> {}, Batman.EventEmitter
  dynamite.prevent(<span class="string">'detonate'</span>)
  dynamite.on <span class="string">'detonate'</span>, -&gt; <span class="keyword">log</span> <span class="string">"This shouldn't fire"</span>
  dynamite.fire(<span class="string">'detonate'</span>)
  equal logged.<span class="keyword">last</span>, undefined, <span class="string">"The event handler wasn't fired."</span>

test <span class="string">'prevent returns the event emitter'</span>, -&gt;
  dynamite = <span class="variable">$mixin</span> {}, Batman.EventEmitter
  equal dynamite, dynamite.prevent(<span class="string">'detonate'</span>)</code></pre>
<h3>allow(key) : EventEmitter</h3>
<p>Allows the event with name <code>key</code> to fire once more, after <code>prevent</code> had been called previously. <code>allow</code> will not fire the event when called, regardless of whether or not the event can now be fired or if an attempt to fire it was made while the event was prevented. Returns the event emitting object.</p>
<p><em>Note</em>: <code>prevent</code> can be called more than once to effectively &quot;nest&quot; preventions. <code>allow</code> or <code>allowAndFire</code> must be called the same number of times or more for events to fire once more.</p>
<pre><code>test 'events can be allowed <span class="keyword">after</span> prevention', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  dynamite.prevent('detonate')
  dynamite.<span class="function_start"><span class="keyword">on</span> </span>'detonate', -&gt; <span class="command">log</span> <span class="string">"This will only fire once"</span>
  dynamite.fire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">0</span>, <span class="string">"The event handler wasn't fired."</span>
  dynamite.allow('detonate')
  dynamite.fire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">1</span>, <span class="string">"The event handler was fired."</span>

test 'events must be allowed <span class="keyword">the</span> same <span class="type">number</span> <span class="keyword">of</span> <span class="keyword">times</span> they have been prevented', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  dynamite.prevent('detonate')
  dynamite.prevent('detonate')
  dynamite.<span class="function_start"><span class="keyword">on</span> </span>'detonate', -&gt; <span class="command">log</span> <span class="string">"This will only fire once"</span>
  dynamite.fire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">0</span>, <span class="string">"The event handler wasn't fired, the prevent count is at 2."</span>
  dynamite.allow('detonate')
  dynamite.fire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">0</span>, <span class="string">"The event handler still wasn't fired, but the prevent count is now at 1."</span>
  dynamite.allow('detonate')
  dynamite.fire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">1</span>, <span class="string">"The event handler was fired."</span>

test 'allow returns <span class="keyword">the</span> event emitter', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  <span class="keyword">equal</span> dynamite, dynamite.allow('detonate')</code></pre>
<h3>allowAndFire(key)</h3>
<p>Allows the event with name <code>key</code> to fire once more, and tries to fire it. <code>allowAndFire</code> may fail to fire the event if <code>prevent</code> has been called more times than <code>allow</code> or <code>allowAndFire</code> have previous.</p>
<pre><code>test 'events can be allowed <span class="keyword">and</span> fired <span class="keyword">after</span> prevention', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  dynamite.<span class="function_start"><span class="keyword">on</span> </span>'detonate', -&gt; <span class="command">log</span> <span class="string">"This will only fire once"</span>
  dynamite.prevent('detonate')
  dynamite.fire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">0</span>, <span class="string">"The event handler wasn't fired."</span>
  dynamite.allowAndFire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">1</span>, <span class="string">"The event handler was fired."</span>

test 'events must be allowed <span class="keyword">and</span> fired <span class="keyword">the</span> same <span class="type">number</span> <span class="keyword">of</span> <span class="keyword">times</span> they have been prevented', -&gt;
  dynamite = $mixin {}, Batman.EventEmitter
  dynamite.<span class="function_start"><span class="keyword">on</span> </span>'detonate', -&gt; <span class="command">log</span> <span class="string">"This will only fire once"</span>
  dynamite.prevent('detonate')
  dynamite.prevent('detonate')
  dynamite.allowAndFire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">0</span>, <span class="string">"The event handler wasn't fired."</span>
  dynamite.allowAndFire('detonate')
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">1</span>, <span class="string">"The event handler was fired."</span></code></pre>

    <hr />
    <h2>Batman.Observable</h2>
    <p><code>Batman.Observable</code> is a mixin which gives objects the ability to notify subscribers to changes on its properties. <code>Observable</code> also adds functionality for observing <em>keypaths</em>: arbitrarily deeply nested properties on objects.</p>

      <h3>get(keypath) : value</h3>
      <p>Retrieves the value at a <code>key</code> on an object. Accepts keypaths.</p>
<p><em>Note</em>: <code>get</code> must be used for property access on any object in <code>Batman</code>&#39;s world. This is so that Batman can implement neat things like automatic dependency calculation for computed properties, property caching where it is safe, and smart storage mechanisms. With Batman, you must use <code>get</code> instead of normal <code>.</code> property access.</p>
<pre><code>test '<span class="keyword">get</span> retrieves properties <span class="function_start"><span class="keyword">on</span> <span class="title">Batman</span></span> objects', -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">340</span>
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('bpm'), <span class="number">120</span>

test '<span class="keyword">get</span> retrieves properties <span class="function_start"><span class="keyword">on</span> <span class="title">nested</span></span> Batman objects using keypaths', -&gt;
  post = Batman
    <span class="type">text</span>: <span class="string">"Hello World!"</span>
    author: Batman
  <span class="property">name</span>: <span class="string">"Harry"</span>
  <span class="keyword">equal</span> post.<span class="keyword">get</span>('author.<span class="property">name</span>'), <span class="string">"Harry"</span>

test <span class="string">"get retrieves properties on Batman objects when . property access doesn't"</span>, -&gt;
  song = new Batman.Model({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  <span class="keyword">equal</span> typeof song.<span class="property">length</span>, <span class="string">"undefined"</span>
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">340</span></code></pre>

      <h3>set(keypath, newValue) : newValue</h3>
      <p>Stores the <code>value</code> at a <code>key</code> on an object. Accepts keypaths. Returns the new value of the property.</p>
<p><em>Note</em>: Once more, <code>set</code> must be used for property mutation on all objects in the <code>Batman</code> world. This is again so that Batman can implement useful functionality like cache busting, eager recalculation of computed properties, and smarter storage.</p>
<p><em>Note</em>: Custom setters can mutate the value during setting, so the value which was passed to <code>set</code> and <code>set</code>&#39;s return value are not guaranteed to be identical.</p>
<pre><code>test '<span class="keyword">set</span> stores properties <span class="function_start"><span class="keyword">on</span> <span class="title">batman</span></span> objects.', -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})</code></pre>
<p>  equal song.get(&#39;length&#39;), 340
  equal song.set(&#39;length&#39;, 1000), 1000
      equal song.get(&#39;length&#39;), 1000</p>
<pre><code>test '<span class="keyword">set</span> stores properties <span class="function_start"><span class="keyword">on</span> <span class="title">nested</span></span> Batman objects using keypaths', -&gt;
  author = Batman
    <span class="property">name</span>: <span class="string">"Harry"</span>
  post = Batman
    <span class="type">text</span>: <span class="string">"Hello World!"</span>
    author: author
  <span class="keyword">equal</span> post.<span class="keyword">set</span>('author.<span class="property">name</span>', <span class="string">"Nick"</span>), <span class="string">"Nick"</span>
  <span class="keyword">equal</span> author.<span class="keyword">get</span>('<span class="property">name</span>'), <span class="string">"Nick"</span>, <span class="string">"The value was set on the nested object."</span>

test <span class="string">"set is incompatible with '.' property mutation"</span>, -&gt;
  song = new Batman.Model({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})</code></pre>
<p>  equal song.get(&#39;length&#39;), 340
  equal song.length = 1000, 1000
      equal song.get(&#39;length&#39;), 340, &quot;The song length reported by Batman is unchanged because set wasn&#39;t used to change the value.&quot;</p>

      <h3>unset(keypath) : value</h3>
      <p>Removes the value at the given <code>keypath</code>, leaving it <code>undefined</code>. Accepts keypaths. Returns the value the property had before unsetting.</p>
<p><code>unset</code> is roughly equivalent to <code>set(keypath, undefined)</code>, however, custom properties can define a nonstandard <code>unset</code> function, so it is best to use <code>unset</code> instead of <code>set(keypath, undefined)</code> wherever possible.</p>
<pre><code>test <span class="string">"unset removes the property on Batman objects"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">340</span>
  <span class="keyword">equal</span> song.unset('<span class="property">length</span>'), <span class="number">340</span>
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('<span class="property">length</span>'), undefined, <span class="string">"The value is unset."</span>

test <span class="string">"unset removes the property at a keypath"</span>, -&gt;
  author = Batman
    <span class="property">name</span>: <span class="string">"Harry"</span>
  post = Batman
    <span class="type">text</span>: <span class="string">"Hello World!"</span>
    author: author
  <span class="keyword">equal</span> post.unset('author.<span class="property">name</span>'), <span class="string">"Harry"</span>
  <span class="keyword">equal</span> author.<span class="keyword">get</span>('<span class="property">name</span>'), undefined, <span class="string">"The value was unset on the nested object."</span></code></pre>

      <h3>observe(key, observerCallback) : this</h3>
      <p>Adds a handler to call when the value of the property at the <code>key</code> changes upon <code>set</code>ting. Accepts keypaths.</p>
<p><code>observe</code> is the very core of Batman&#39;s usefulness. As long as <code>set</code> is used everywhere to do property mutation, any object can be observed for changes to its properties. This is critical to the concept of bindings, which Batman uses for its views.</p>
<p>The <code>observerCallback</code> gets called whenever the <code>key</code> changes with the arguments <code>newValue, oldValue</code>.</p>
<p>Returns the object <code>observe</code> was called upon.</p>
<pre><code>test <span class="string">"observe attaches handlers which get called upon change"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  song.observe '<span class="property">length</span>', (newValue, oldValue) -&gt; <span class="command">log</span> [newValue, oldValue]
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">200</span>), <span class="number">200</span>
  deepEqual logged.<span class="keyword">last</span>, [<span class="number">200</span>, <span class="number">340</span>]
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">300</span>), <span class="number">300</span>
  deepEqual logged.<span class="keyword">last</span>, [<span class="number">300</span>, <span class="number">200</span>]</code></pre>
<p><em>Note</em>: <code>observe</code> works excellently on keypaths. If you attach a handler to a &quot;deep&quot; keypath, it will fire any time the value of that keypath changes, which is another way of saying the handler will fire when any segment of the keypath changes, passing in the new value at the end of the keypath.</p>
<pre><code>test <span class="string">"observe attaches handlers which get called upon change"</span>, -&gt;
  author = Batman
    <span class="property">name</span>: <span class="string">"Harry"</span>
  post = Batman
    <span class="type">text</span>: <span class="string">"Hello World!"</span>
    author: author
  post.observe('author.<span class="property">name</span>', (newName, oldName) -&gt; <span class="command">log</span> [newName, oldName])
  post.<span class="keyword">set</span> 'author', newAuthor = Batman({<span class="property">name</span>: <span class="string">"James"</span>})
  deepEqual logged.<span class="keyword">last</span>, [<span class="string">"James"</span>, <span class="string">"Harry"</span>], <span class="string">"The observer fired when the 'author' segment of the keypath changed."</span></code></pre>

      <h3>observeAndFire(key, observerCallback) : this</h3>
      <p>Adds the <code>observerCallback</code> as an observer to <code>key</code>, and fires it immediately. Accepts the exact same arguments and follows the same semantics as <code>Observable::observe</code>, but the observer is fired with the current value of the keypath it observes synchronously during the call to <code>observeAndFire</code>.</p>
<p>During the initial synchronous firing of the <code>callback</code>, the <code>newValue</code> and <code>oldValue</code> arguments will be the same value: the current value of the property. This is because the old value of the property is not cached and therefore unavailable. If your observer needs the old value of the property, you must attach it before the <code>set</code> on the property happens.</p>
<pre><code>test <span class="string">"observeAndFire calls the observer upon attaching it with the currentValue of the property"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  song.observeAndFire '<span class="property">length</span>', (newValue, oldValue) -&gt; <span class="command">log</span> [newValue, oldValue]
  deepEqual logged.<span class="keyword">last</span>, [<span class="number">340</span>, <span class="number">340</span>]
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">300</span>), <span class="number">300</span>
  deepEqual logged.<span class="keyword">last</span>, [<span class="number">300</span>, <span class="number">340</span>]</code></pre>

      <h3>forget([key [, observerCallback]]) : this</h3>
      <p>If <code>observerCallback</code> and <code>key</code> are given, that observer is removed from the observers on <code>key</code>. If only a <code>key</code> is given, all observers on that key are removed. If no <code>key</code> is given, all observers on all keys are removed. Accepts keypaths.</p>
<p>Returns the object on which <code>forget</code> was called.</p>
<pre><code>test <span class="string">"forget removes an observer from a key if the key and the observer are given"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  observer = (newValue, oldValue) -&gt; <span class="command">log</span> [newValue, oldValue]
  song.observe '<span class="property">length</span>', observer
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">200</span>), <span class="number">200</span>
  deepEqual logged.<span class="keyword">last</span>, [<span class="number">200</span>, <span class="number">340</span>]
  song.forget '<span class="property">length</span>', observer
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">300</span>), <span class="number">300</span>
  deepEqual logged.<span class="keyword">last</span>, [<span class="number">200</span>, <span class="number">340</span>], <span class="string">"The logged values haven't changed because the observer hasn't fired again."</span>

test <span class="string">"forget removes all observers from a key if only the key is given"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  observerA = ((newValue, oldValue) -&gt; <span class="command">log</span> [newValue, oldValue])
  observerB = ((newValue, oldValue) -&gt; <span class="command">log</span> [newValue, oldValue])
  song.observe '<span class="property">length</span>', observerA
  song.observe '<span class="property">length</span>', observerB
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">200</span>), <span class="number">200</span>
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">2</span>, <span class="string">"Both length observers fired."</span>
  song.forget('<span class="property">length</span>')
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">300</span>), <span class="number">300</span>
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">2</span>, <span class="string">"Nothing more has been logged because neither observer fired."</span>

test <span class="string">"forget removes all observers from all keys if no key is given"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  observerA = ((newValue, oldValue) -&gt; <span class="command">log</span> [newValue, oldValue])
  observerB = ((newValue, oldValue) -&gt; <span class="command">log</span> [newValue, oldValue])
  song.observe '<span class="property">length</span>', observerA
  song.observe 'bpm', observerB
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">200</span>), <span class="number">200</span>
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">1</span>, <span class="string">"The length observer fired."</span>
  song.forget()
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('<span class="property">length</span>', <span class="number">300</span>), <span class="number">300</span>
  <span class="keyword">equal</span> song.<span class="keyword">set</span>('bpm', <span class="number">130</span>), <span class="number">130</span>
  <span class="keyword">equal</span> logged.<span class="property">length</span>, <span class="number">1</span>, <span class="string">"Nothing more has been logged because neither observer fired."</span></code></pre>

      <h3>getOrSet(keypath, valueFunction) : value</h3>
      <p>Assigns the <code>keypath</code> to the result of calling the <code>valueFunction</code> if the current value at the <code>keypath</code> is falsey. Returns the value of the property after the operation, be it changed or not. Equivalent to CoffeeScript&#39;s <code>||=</code> operator.</p>
<pre><code>test <span class="string">"getOrSet doesn't set the property if it exists"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  <span class="keyword">equal</span> song.getOrSet('<span class="property">length</span>', -&gt; <span class="number">500</span>), <span class="number">340</span>
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">340</span>

test <span class="string">"getOrSet sets the property if it is falsey"</span>, -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">340</span>, bpm: <span class="number">120</span>})
  <span class="keyword">equal</span> song.getOrSet('artist', -&gt; <span class="string">"Elvis"</span>), <span class="string">"Elvis"</span>
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('artist'), <span class="string">"Elvis"</span></code></pre>

    <hr />
    <h2>Batman.Object</h2>
    <p><code>Batman.Object</code> is the superclass for virtually all objects in a Batman application. <code>Batman.Object</code> mixes in <code>Batman.Observable</code> and <code>Batman.EventEmitter</code> for things like <code>get</code>, <code>set</code>, <code>observe</code>, and <code>fire</code>, and then defines some more useful things for tying everything together.</p>

      <h3>@accessor([keys...], objectOrFunction)</h3>
      <p>Accessors are used to create properties on a class, prototype, or instance which can be fetched, set, and unset. These properties can be static, computed as functions of the other properties on the object the accessor belongs to, or properties of any Batman object in the system. <code>accessor</code> is a Batman and old browser friendly version of ES5 <code>Object.defineProperty</code>.</p>
<p>The value of custom accessors can be observed just like any property. Accessors also track which other properties they rely on for computation, and recalculate eagerly when those other properties change. This way, when a source value is changed, any dependent accessors will automatically update any bindings to them with a new value. Accessors accomplish this feat by tracking <code>get</code> calls, so be sure to use <code>get</code> to retrieve properties on Batman Objects inside accessors so those properties can be tracked as dependencies. The property dependencies of an accessor are called &quot;sources&quot; in the Batman world.</p>
<p>Importantly, accessors are also inherited, so accessors defined anywhere in an object&#39;s prototype chain will be used. Following this, <code>@accessor</code> is meant to be used during the class definition of a class extending <code>Batman.Object</code>.</p>
<h4>Arguments</h4>
<p><code>@accessor</code> can be called with zero, one, or many keys for the accessor to define. This has the following effects:</p>
<ul>
<li>zero: create a <code>defaultAccessor</code>, which will be called when no other properties or accessors on an object match a keypath. This is similar to <code>method_missing</code> in Ruby or <code>#doesNotUnderstand</code> in Smalltalk.</li>
<li>one: create a <code>keyAccessor</code> at the given key, which will only be called when that key is gotten, set, or unset.</li>
<li>many: create <code>keyAccessors</code> for each given key, which will then be called whenever each one of the listed keys is gotten, set, or unset.</li>
</ul>
<p><code>@accessor</code> accepts as the last argument either an object with any combination of the <code>get</code>, <code>set</code>, and <code>unset</code> keys defined, or a function. Functions which implement the behaviour for those particular actions on the property should reside at these keys. <code>@accessor</code> also accepts a function as the last argument, which is a shorthand for specifying the <code>get</code> implementation for the accessor.</p>
<h4>Uses</h4>
<p>Accessors are a really useful addition to the world of JavaScript. You can now define transforms on simple properties which will automatically update when the properties they transform change: for example, you might want to truncate a potentially long piece of text to display a summary elsewhere, or you might want to capitalize or <code>encodeURIComponent</code> a value before putting it in the view or the current URL.</p>
<pre><code>test <span class="string">'@accessor can be called on a class to define how a property is calculated'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">accessor</span> '<span class="title">summary</span>', -&gt; @<span class="title">get</span>('<span class="title">body</span>').<span class="title">slice</span>(0, 10) + "..."

  <span class="title">post</span> = <span class="title">new</span> <span class="title">Post</span>(<span class="title">body</span>: "<span class="title">Why</span> <span class="title">Batman</span> <span class="title">is</span> <span class="title">Useful</span>: <span class="title">A</span> <span class="title">lengthy</span> <span class="title">post</span> <span class="title">on</span> <span class="title">an</span> <span class="title">important</span> <span class="title">subject</span>")
  <span class="title">equal</span> <span class="title">post</span>.<span class="title">get</span>('<span class="title">summary</span>'), "<span class="title">Why</span> <span class="title">Batman</span>..."</code></pre>
<p>You can also use accessors to combine properties; the colloquial <code>fullName</code> example comes to mind, but all sorts of other complex logic can be abstracted away using the accessor pattern.</p>
<pre><code>test <span class="string">'@accessor can define a transform on several properties'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">accessor</span> '<span class="title">fullName</span>', -&gt; @<span class="title">get</span>('<span class="title">firstName</span>') + " " + @<span class="title">get</span>('<span class="title">lastName</span>')

  <span class="title">tim</span> = <span class="title">new</span> <span class="title">User</span>(<span class="title">firstName</span>: "<span class="title">Tim</span>", <span class="title">lastName</span>: "<span class="title">Thomas</span>")
  <span class="title">equal</span> <span class="title">tim</span>.<span class="title">get</span>('<span class="title">fullName</span>'), "<span class="title">Tim</span> <span class="title">Thomas</span>"
  <span class="title">tim</span>.<span class="title">set</span>('<span class="title">firstName</span>', "<span class="title">Timmy</span>")
  <span class="title">equal</span> <span class="title">tim</span>.<span class="title">get</span>('<span class="title">fullName</span>'), "<span class="title">Timmy</span> <span class="title">Thomas</span>"</code></pre>
<p>Accessors can define custom <code>get</code>, <code>set</code>, and <code>unset</code> functions to support each operation on the property:</p>
<pre><code>test <span class="string">'@accessor can define the get, set, and unset methods for the property'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">AbsoluteNumber</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">accessor</span> '<span class="title">value</span>',
      <span class="title">get</span>: -&gt; @<span class="title">_value</span>
      <span class="title">set</span>: (<span class="title">_</span>, <span class="title">value</span>) -&gt; @<span class="title">_value</span> = <span class="title">Math</span>.<span class="title">abs</span>(<span class="title">value</span>)
      <span class="title">unset</span>: -&gt; <span class="title">delete</span> @<span class="title">_value</span>

  <span class="title">number</span> = <span class="title">new</span> <span class="title">AbsoluteNumber</span>(<span class="title">value</span>: -10)
  <span class="title">equal</span> <span class="title">number</span>.<span class="title">get</span>('<span class="title">value</span>'), 10</code></pre>
<p>Importantly, it is also safe to use branching, loops, or whatever logic you want in accessor bodies:</p>
<pre><code>test <span class="string">'@accessor can use arbitrary logic to define the value'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">accessor</span> '<span class="title">score</span>', -&gt;
      <span class="title">if</span> @<span class="title">get</span>('<span class="title">played</span>')
        (@<span class="title">get</span>('<span class="title">goals</span>') * 2) + (@<span class="title">get</span>('<span class="title">assists</span>') * 1)
      <span class="title">else</span>
        0

  <span class="title">rick</span> = <span class="title">new</span> <span class="title">Player</span>(<span class="title">played</span>: <span class="title">false</span>, <span class="title">goals</span>: 0, <span class="title">assists</span>: 0)
  <span class="title">equal</span> <span class="title">rick</span>.<span class="title">get</span>('<span class="title">score</span>'), 0
  <span class="title">rick</span>.<span class="title">set</span>('<span class="title">played</span>', <span class="title">true</span>)
  <span class="title">equal</span> <span class="title">rick</span>.<span class="title">get</span>('<span class="title">score</span>'), 0
  <span class="title">rick</span>.<span class="title">set</span>('<span class="title">goals</span>', 3)
  <span class="title">equal</span> <span class="title">rick</span>.<span class="title">get</span>('<span class="title">score</span>'), 6
  <span class="title">rick</span>.<span class="title">set</span>('<span class="title">assists</span>', 1)
  <span class="title">equal</span> <span class="title">rick</span>.<span class="title">get</span>('<span class="title">score</span>'), 7</code></pre>
<h4>Caveats</h4>
<p>Accessors are extremely useful, but keep these items in mind when using them:</p>
<ol>
<li>Accessors should be pure functions so they are predictable and can be cached.</li>
</ol>
<p>Batman automatically memoizes the return value of accessors, and will not re-execute the body until one of the accessor&#39;s sources changes. If you need the accessor to recalculate every time the property is gotten, pass <code>false</code> for the <code>cache</code> option in the accessor descriptor object (the last argument to the <code>@accessor</code> function).</p>
<pre><code>test <span class="string">"@accessor usually caches results"</span>, -&gt;
  counter = <span class="number">0</span>
  <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">accessor</span> '<span class="title">cachedCounter</span>', -&gt; ++<span class="title">counter</span>
    @<span class="title">accessor</span> '<span class="title">notCachedCounter</span>',
      <span class="title">get</span>: -&gt; ++<span class="title">counter</span>
      <span class="title">cache</span>: <span class="title">false</span>

  <span class="title">example</span> = <span class="title">new</span> <span class="title">Example</span>()
  <span class="title">equal</span> <span class="title">example</span>.<span class="title">get</span>('<span class="title">cachedCounter</span>'), 1
  <span class="title">equal</span> <span class="title">example</span>.<span class="title">get</span>('<span class="title">cachedCounter</span>'), 1
  <span class="title">equal</span> <span class="title">example</span>.<span class="title">get</span>('<span class="title">cachedCounter</span>'), 1, "<span class="title">The</span> <span class="title">second</span> <span class="title">and</span> <span class="title">third</span> <span class="title">calls</span> <span class="title">do</span> <span class="title">not</span> <span class="title">execute</span> <span class="title">the</span> <span class="title">function</span>"
  <span class="title">equal</span> <span class="title">example</span>.<span class="title">get</span>('<span class="title">notCachedCounter</span>'), 2
  <span class="title">equal</span> <span class="title">example</span>.<span class="title">get</span>('<span class="title">notCachedCounter</span>'), 3, "<span class="title">Passing</span> <span class="title">cache</span>: <span class="title">false</span> <span class="title">does</span> <span class="title">re</span>-<span class="title">execute</span> <span class="title">the</span> <span class="title">function</span>"
  <span class="title">equal</span> <span class="title">example</span>.<span class="title">get</span>('<span class="title">cachedCounter</span>'), 1</code></pre>
<ol>
<li>Accessors <em>must</em> use <code>get</code> to access properties they use for computation</li>
</ol>
<p>Batman tracks an accessor&#39;s sources by adding a global hook to all <code>get</code>s done, so if you don&#39;t use <code>get</code> to access properties on objects, Batman can&#39;t know that that property is a source of the property your accessor defines, so it can&#39;t recompute that property when the source property changes. All properties on <code>Batman.Object</code> should be accessed using <code>get</code> and <code>set</code> whether or not the code occurs in an accessor body, but it is critical to do so in accessors so the sources of the accessor can be tracked.</p>
<ol>
<li>Accessors can create memory leaks or performance bottlenecks</li>
</ol>
<p>If you return a brand new object, say by merging a number of <code>Batman.Set</code>s or doing any sort of major and complete re-computation, you run the risk of creating performance problems. This is because accessors can be called frequently and unpredictably, as they are recomputed every time one of their sources changes and for every call to <code>set</code>. Instead of recomputing expensive things every time the accessor is called, try to use objects which do smart re-computation using observers. Practically, this translates to using things like <code>new SetUnion(@get(&#39;setA&#39;), @get(&#39;setB&#39;))</code> instead of <code>@get(&#39;setA&#39;).merge(@get(&#39;setB&#39;))</code> in an accessor body, since <code>SetUnion</code> will observe its constituents and update itself when they change, instead of the <code>merge</code> resulting in the accessor recomputing every time <code>setA</code> or <code>setB</code> changed.</p>

      <h3>@classAccessor([keys...], objectOrFunction)</h3>
      <p><code>classAccessor</code> defines an accessor on the class: <code>get</code>s and <code>set</code>s done to the class will use the accessor definition as an implementation. <code>@accessor</code> called on a class will define an accessor for all instances of that class, whereas <code>@classAccessor</code> defines accessors on the class object itself. See <code>@accessor</code> for the details surrounding accessors.</p>
<pre><code>test <span class="string">'@classAccessor defines an accessor on the class'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">SingletonDooDad</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">classAccessor</span> '<span class="title">instance</span>', -&gt; <span class="title">new</span> @()

  <span class="title">instance</span> = <span class="title">SingletonDooDad</span>.<span class="title">get</span>('<span class="title">instance</span>')      # "<span class="title">classAccessor</span> <span class="title">defines</span> <span class="title">accessors</span> <span class="title">for</span> <span class="title">gets</span> <span class="title">done</span> <span class="title">on</span> <span class="title">the</span> <span class="title">class</span> <span class="title">its</span> <span class="title">self</span>"
  <span class="title">ok</span> <span class="title">SingletonDooDad</span>.<span class="title">get</span>('<span class="title">instance</span>') == <span class="title">instance</span>  # "<span class="title">A</span> <span class="title">second</span> <span class="title">get</span> <span class="title">returns</span> <span class="title">the</span> <span class="title">same</span> <span class="title">instance</span>"</code></pre>

      <h3>@mixin(objects...) : prototype</h3>
      <p><code>@mixin</code> is a handy function for mixing in <code>object</code>s to a class&#39; prototype. <code>@mixin</code> is implemented on top of the Batman level <code>mixin</code> helper, which means that keys from incoming <code>objects</code> will be applied using <code>set</code>, and any <code>initialize</code> functions on the <code>objects</code> will be called with the prototype being mixed into. Returns the prototype being mixed into.</p>
<p><em>Note</em>: <code>@mixin</code>, similar to <code>@accessor</code>, applies to all instances of a class. If you need to mix in to the class itself, look at <code>classMixin</code>. <code>@mixin</code> is intended for use during the class definition of a <code>Batman.Object</code> subclass.</p>
<pre><code>test <span class="string">'@mixin extends the prototype of a Batman.Object subclass'</span>, -&gt;
  FishBehaviour = {canBreathUnderwater: <span class="keyword">true</span>}
  MammalBehaviour = {canBreathAboveWater: <span class="keyword">true</span>}
  <span class="class"><span class="keyword">class</span> <span class="title">Platypus</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">mixin</span> <span class="title">FishBehaviour</span>, <span class="title">MammalBehaviour</span>

  <span class="title">platypus</span> = <span class="title">new</span> <span class="title">Platypus</span>
  <span class="title">ok</span> <span class="title">platypus</span>.<span class="title">get</span>('<span class="title">canBreathAboveWater</span>')
  <span class="title">ok</span> <span class="title">platypus</span>.<span class="title">get</span>('<span class="title">canBreathUnderwater</span>')</code></pre>

      <h3>@classMixin(objects...) : this</h3>
      <p><code>@classMixin</code> allows mixing in objects to a class during that class&#39; definition. See <code>@mixin</code> for information about the arguments passed to mixin, but note that <code>@classMixin</code> applies to the class object itself, and <code>@mixin</code> applies to all instances of the class. Returns the class being mixed into.</p>
<pre><code>test <span class="string">'@classMixin extends the Batman.Object subclass'</span>, -&gt;
  Singleton =
    initialze: (subject) -&gt;
      subject.accessor <span class="string">'instance'</span>, -&gt; <span class="keyword">new</span> subject

  <span class="class"><span class="keyword">class</span> <span class="title">Highlander</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">classMixin</span> <span class="title">Singleton</span>

  <span class="title">instance</span> = <span class="title">Highlander</span>.<span class="title">get</span>('<span class="title">instance</span>')
  <span class="title">ok</span> <span class="title">instance</span> == <span class="title">Highlander</span>.<span class="title">get</span>('<span class="title">instance</span>'), "<span class="title">There</span> <span class="title">can</span> <span class="title">only</span> <span class="title">be</span> <span class="title">one</span>."</code></pre>

      <h3>@observeAll(key, callback : function) : prototype</h3>
      <p><code>@observeAll</code> extends the <code>Batman.Object</code> implementation of <code>Batman.Observable</code> with the ability to observe all instances of the class (and subclasses). Observers attached with <code>@observeAll</code> function exactly as if they were attached to the object directly. Returns the prototype of the class.</p>
<p><em>Note</em>: <code>@observeAll</code> is intended to be used during the class definition for a <code>Batman.Object</code> subclass, but it can be called after the class has been defined as a function on the class. It supports being called after instances of the class have been instantiated as well.</p>
<pre><code>test <span class="string">"@observeAll attaches handlers which get called upon change"</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Song</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">observeAll</span> '<span class="title">length</span>', (<span class="title">newValue</span>, <span class="title">oldValue</span>) -&gt; <span class="title">log</span> <span class="title">newValue</span>

  <span class="title">song</span> = <span class="title">new</span> <span class="title">Song</span>({</span>length: <span class="number">340</span>, bpm: <span class="number">120</span>})
  equal song.set(<span class="string">'length'</span>, <span class="number">200</span>), <span class="number">200</span>
  deepEqual logged.last, <span class="number">200</span>

test <span class="string">"@observeAll can attach handlers after instance instantiation"</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Song</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>

  <span class="title">song</span> = <span class="title">new</span> <span class="title">Song</span>({</span>length: <span class="number">340</span>, bpm: <span class="number">120</span>})
  equal song.set(<span class="string">'length'</span>, <span class="number">360</span>), <span class="number">360</span>
  deepEqual logged.last, undefined
  Song.observeAll <span class="string">'length'</span>, (newValue, oldValue) -&gt; log newValue
  equal song.set(<span class="string">'length'</span>, <span class="number">200</span>), <span class="number">200</span>
  deepEqual logged.last, <span class="number">200</span></code></pre>

      <h3>constructor(objects...)</h3>
      <p>To create a new <code>Batman.Object</code>, the <code>Batman.Object</code> constructor can be used, or, the <code>Batman</code> namespace is also a utility function for creating Batman objects. Each object passed in to the constructor will have all its properties applied to the new <code>Batman.Object</code> using <code>get</code> and <code>set</code>, so any custom getters or setters will be respected. Objects passed in last will have precedence over objects passed in first in the event that they share the same keys. The property <code>copy</code> from these objects is shallow.</p>
<pre><code>test 'Batman() function allows <span class="keyword">for</span> handy creation <span class="keyword">of</span> Batman.Objects', -&gt;
  object = Batman(foo: 'bar')
  <span class="keyword">equal</span> typeof object.<span class="keyword">get</span>, 'function'

test 'Batman.Object constructor function accepts multiple mixin arguments <span class="keyword">and</span> later mixins take precedence.', -&gt;
  song = Batman({<span class="property">length</span>: <span class="number">100</span>, bpm: <span class="number">120</span>}, {bpm: <span class="number">130</span>})
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">100</span>
  <span class="keyword">equal</span> song.<span class="keyword">get</span>('bpm'), <span class="number">130</span>, <span class="string">"The property from the second object passed to the constructor overwrites that from the first."</span></code></pre>

      <h3>toJSON() : object</h3>
      <p><code>toJSON</code> returns a vanilla JavaScript object representing this <code>Batman.Object</code>.</p>
<pre><code>test <span class="string">'toJSON returns a vanilla JS object'</span>, -&gt;
  <span class="class"><span class="keyword">object</span> = <span class="title">Batman</span><span class="params">(foo: <span class="string">'bar'</span>)</span></span>
  deepEqual <span class="keyword">object</span>.toJSON(), {foo: <span class="string">'bar'</span>}</code></pre>

      <h3>hashKey() : string</h3>
      <p><code>hashKey</code> returns a unique string identifying this particular <code>Batman.Object</code>. No two <code>Batman.Object</code>s will have the same <code>hashKey</code>. Feel free to override the implmentation of this function on your objects if you have a better hashing scheme for a domain object of yours.</p>

      <h3>accessor([keys...], objectOrFunction)</h3>
      <p><code>accessor</code> defines an accessor on one instance of an object instead of on all instances like the class level <code>@accessor</code>. See <code>@accessor</code> for the details surrounding accessors.</p>
<pre><code>test <span class="string">'accessor can be called on an instance of Batman.Object to define an accessor just on that instance'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    @<span class="title">accessor</span> '<span class="title">summary</span>', -&gt; @<span class="title">get</span>('<span class="title">body</span>').<span class="title">slice</span>(0, 10) + "..."

  <span class="title">post</span> = <span class="title">new</span> <span class="title">Post</span>(<span class="title">body</span>: "<span class="title">Why</span> <span class="title">Batman</span> <span class="title">is</span> <span class="title">Useful</span>: <span class="title">A</span> <span class="title">lengthy</span> <span class="title">post</span> <span class="title">on</span> <span class="title">an</span> <span class="title">important</span> <span class="title">subject</span>")
  <span class="title">equal</span> <span class="title">post</span>.<span class="title">get</span>('<span class="title">summary</span>'), "<span class="title">Why</span> <span class="title">Batman</span>..."
  <span class="title">post</span>.<span class="title">accessor</span>('<span class="title">longSummary</span>', -&gt; @<span class="title">get</span>('<span class="title">body</span>').<span class="title">slice</span>(0, 20) + "...")  # "<span class="title">Instance</span> <span class="title">level</span> <span class="title">accessor</span> <span class="title">defines</span> <span class="title">accessors</span> <span class="title">just</span> <span class="title">for</span> <span class="title">that</span> <span class="title">instance</span>"
  <span class="title">equal</span> <span class="title">post</span>.<span class="title">get</span>('<span class="title">longSummary</span>'), "<span class="title">Why</span> <span class="title">Batman</span> <span class="title">is</span> <span class="title">Useful</span>..."

<span class="title">test</span> '<span class="title">defining</span> <span class="title">an</span> <span class="title">accessor</span> <span class="title">on</span> <span class="title">an</span> <span class="title">instance</span> <span class="title">does</span> <span class="title">not</span> <span class="title">affect</span> <span class="title">the</span> <span class="title">other</span> <span class="title">instances</span>', -&gt;
  <span class="title">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>

  <span class="title">post</span> = <span class="title">new</span> <span class="title">Post</span>(<span class="title">body</span>: "<span class="title">Why</span> <span class="title">Batman</span> <span class="title">is</span> <span class="title">Useful</span>: <span class="title">A</span> <span class="title">lengthy</span> <span class="title">post</span> <span class="title">on</span> <span class="title">an</span> <span class="title">important</span> <span class="title">subject</span>")
  <span class="title">otherPost</span> = <span class="title">new</span> <span class="title">Post</span>(<span class="title">body</span>: "<span class="title">Why</span> <span class="title">State</span> <span class="title">Machines</span> <span class="title">Are</span> <span class="title">Useful</span>: <span class="title">Another</span> <span class="title">lengthy</span> <span class="title">post</span>")
  <span class="title">post</span>.<span class="title">accessor</span> '<span class="title">longSummary</span>', -&gt; @<span class="title">get</span>('<span class="title">body</span>').<span class="title">slice</span>(0, 20) + "..."
  <span class="title">equal</span> <span class="title">post</span>.<span class="title">get</span>('<span class="title">longSummary</span>'), "<span class="title">Why</span> <span class="title">Batman</span> <span class="title">is</span> <span class="title">Useful</span>..."
  <span class="title">equal</span> <span class="title">otherPost</span>.<span class="title">get</span>('<span class="title">longSummary</span>'), <span class="title">undefined</span></code></pre>

      <h3>mixin(objects...) : this</h3>
      <p><code>mixin</code> extends the object it&#39;s called on with the passed <code>objects</code> using the <code>Batman.mixin</code> helper. Returns the object it&#39;s called upon.</p>
<p><em>Note</em>: Since the <code>Batman.mixin</code> helper is used, mixin functionality like using <code>set</code> to apply properties and calling <code>initialize</code> functions is included in the instance level <code>mixin</code> function.</p>
<pre><code>test <span class="string">'mixin on an instance applies the keys from the mixed in object to the instance'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>

  <span class="title">snake</span> = <span class="title">new</span> <span class="title">Snake</span>()
  <span class="title">snake</span>.<span class="title">mixin</span> {</span>canSlither: <span class="keyword">true</span>}, {canHiss: <span class="keyword">true</span>}
  ok snake.get(<span class="string">'canSlither'</span>)
  ok snake.get(<span class="string">'canHiss'</span>)</code></pre>

    <hr />
    <h2>Batman.SimpleSet</h2>
    <p><code>SimpleSet</code> is an implementation of the <code>Set</code> object you might expect to find in other languages&#39; standard libraries. Sets are an enumerable but unordered collection of objects. A particular object may either be a member or not be a member of a particular set, but it may not belong to the set twice, as that would imply ordering. In Batman, sets will tell you when items are added or removed through events, mix in the <code>Enumerable</code> module for handy iteration and aggregation, and can also generate indices and sorts via <code>SetIndex</code> and <code>SetSort</code>.</p>
<h3>SimpleSet vs Set</h3>
<p><code>SimpleSet</code> and <code>Set</code> are two distinct classes in Batman. <code>SimpleSet</code> implements the set semantics as described above, but it is <em>not</em> a <code>Batman.Object</code>, so properties on it (like its <code>length</code> or <code>toArray</code>) cannot be observed or bound. <code>Set</code> is a <code>Batman.Object</code>, so it can be observed, and thus plays nicely with the accessor system. Use a <code>SimpleSet</code> only when you know nothing will need to be observed on the set you are creating, which usually isn&#39;t a valid assumption. If it is in fact valid, consider using a native array as well, as iteration and membership checks will be faster.</p>

      <h3>constructor(items...)</h3>
      <p>When creating a <code>SimpleSet</code>, items forming the initial set can be passed as separate arguments to the constructor</p>
<pre><code>test <span class="attribute">'new</span> SimpleSet constructor can be called without arguments', -&gt;
  set = <span class="keyword">new</span> Batman.SimpleSet
  deepEqual set.toArray(), []

test <span class="attribute">'new</span> SimpleSet constructor can be passed items <span class="keyword">to</span> add <span class="keyword">to</span> the set.', -&gt;
  set = <span class="keyword">new</span> Batman.SimpleSet(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>']</code></pre>

      <h3>length : number</h3>
      <p>A count of the items in a <code>SimpleSet</code> can be found at its <code>length</code> property.</p>

      <h3>has(item) : Boolean</h3>
      <p><code>has</code> returns a boolean describing if the given <code>item</code> is a member of the set.</p>
<pre><code>test 'SimpleSet::has indicates <span class="keyword">if</span> an <span class="property">item</span> <span class="keyword">is</span> a member <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">set</span> <span class="keyword">or</span> <span class="keyword">not</span>.', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet('a', 'b', 'c')
  ok <span class="keyword">set</span>.has('a')
  <span class="keyword">equal</span> <span class="keyword">set</span>.has('d'), <span class="constant">false</span></code></pre>

      <h3>add(items...) : Array</h3>
      <p><code>add</code> adds 0 or more new items to the set. <code>add</code> returns an array of the items which have been newly added to the set, which is to say the intersection of the argument items and the set&#39;s complement before addition.</p>
<pre><code>test <span class="attribute">'SimpleSet</span>::add adds an item <span class="keyword">to</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.SimpleSet()
  equal set.has(<span class="attribute">'a</span>'), false
  deepEqual set.add(<span class="attribute">'a</span>'), [<span class="attribute">'a</span>']
  equal set.has(<span class="attribute">'a</span>'), true

test <span class="attribute">'SimpleSet</span>::add returns only the <span class="keyword">new</span> items that weren\<span class="attribute">'t</span> previously <span class="keyword">in</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.SimpleSet(<span class="attribute">'a</span>', <span class="attribute">'b</span>')
  deepEqual set.add(<span class="attribute">'b</span>',<span class="attribute">'c</span>',<span class="attribute">'d</span>').sort(), [<span class="attribute">'c</span>', <span class="attribute">'d</span>']
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>', <span class="attribute">'d</span>']</code></pre>

      <h3>remove(items...) : Array</h3>
      <p><code>remove</code> removes 0 or more items from the set. <code>remove</code> returns an array of the items which were successfully removed from the set, which is to say the intersection of the argument items and the set itself before removal.</p>
<pre><code>test 'SimpleSet::remove removes an <span class="property">item</span> <span class="keyword">from</span> <span class="keyword">the</span> <span class="keyword">set</span>', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet('a')
  <span class="keyword">equal</span> <span class="keyword">set</span>.has('a'), <span class="constant">true</span>
  deepEqual <span class="keyword">set</span>.remove('a'), ['a']
  <span class="keyword">equal</span> <span class="keyword">set</span>.has('a'), <span class="constant">false</span>

test 'SimpleSet::remove returns only <span class="keyword">the</span> new items <span class="keyword">that</span> were previously <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">set</span>', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet('a', 'b')
  deepEqual <span class="keyword">set</span>.remove('b','c','d').sort(), ['b']
  deepEqual <span class="keyword">set</span>.toArray(), ['a']</code></pre>

      <h3>addAndRemove(itemsToAdd, itemsToRemove) : Object</h3>
      <p><code>addAndRemove</code> adds <code>itemsToAdd</code> items to the set and removes <code>itemsToRemove</code> items from the set. <code>addAndRemove</code> returns an object containing the items added and removed (see <code>add</code> and <code>remove</code>) under the form <code>{added: [itemsAdded...], removed: [itemsRemoved...]}</code>. <code>addAndRemove</code> only fires events when all items has been added and removed.</p>
<pre><code>test 'SimpleSet::addAndRemove adds items <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">set</span>', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet('b')
  <span class="keyword">equal</span> <span class="keyword">set</span>.has('a'), <span class="constant">false</span>
  deepEqual <span class="keyword">set</span>.addAndRemove(['a'], ['b']), {added: ['a'], removed: ['b']}
  <span class="keyword">equal</span> <span class="keyword">set</span>.has('a'), <span class="constant">true</span></code></pre>

      <h3>find(testFunction : function) : [Object]</h3>
      <p><code>find</code> returns the first item within the set for which the <code>testFunction</code> called with the item returns <code>true</code>, or <code>undefined</code> if no item passes the test.</p>
<p><em>Note</em>: <code>find</code> returns the first item the test passes for, but since set iteration has no specified order, no guarantee can be made about which item will be returned if more than one item in the set passes the test. However, set iteration order is stable, so <code>find</code> called on the same set twice should return the same item.</p>
<pre><code>test 'SimpleSet::find returns <span class="keyword">the</span> <span class="keyword">first</span> <span class="property">item</span> <span class="keyword">for</span> which <span class="keyword">the</span> test function passes', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
  <span class="keyword">equal</span> <span class="keyword">set</span>.find((x) -&gt; x % <span class="number">2</span> == <span class="number">0</span>), <span class="number">2</span>

test 'SimpleSet::find returns undefined <span class="keyword">if</span> no items pass <span class="keyword">the</span> test function', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
  <span class="keyword">equal</span> typeof <span class="keyword">set</span>.find((x) -&gt; x &gt; <span class="number">5</span>), 'undefined'</code></pre>

      <h3>forEach(iteratorFunction : function[, context: Object])</h3>
      <p><code>forEach</code> calls the <code>iteratorFunction</code> with each item in the set, optionally executing the <code>iteratorFunction</code> in the passed context. Returns <code>undefined</code>.</p>
<p><em>Note</em>: Set iteration order is not defined, thus Set client code cannot rely on one item being iterated over before another, regardless of when the Set&#39;s items were added. If you need an ordered set, Batman provides <code>SetSort</code> for exactly this, while including the added benefit of observability. If you need a one time ordering of a set, you can get the array representation with <code>toArray</code> and then use vanilla JavaScript <code>sort</code> on that array.</p>
<pre><code>test 'SimpleSet::forEach iterates <span class="keyword">over</span> each <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">set</span>', -&gt;
  sum = <span class="number">0</span>
  <span class="keyword">set</span> = new Batman.SimpleSet(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
  <span class="keyword">set</span>.forEach (x) -&gt; sum += x
  <span class="keyword">equal</span> sum, <span class="number">6</span>

test 'SimpleSet::forEach iterates <span class="keyword">over</span> each <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">set</span> optionally <span class="keyword">in</span> <span class="keyword">the</span> provided context', -&gt;
  context = {sum: <span class="number">0</span>}
  <span class="keyword">set</span> = new Batman.SimpleSet(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
  <span class="keyword">set</span>.forEach((x) -&gt;
    @sum += x
  , context)
  <span class="keyword">equal</span> context.sum, <span class="number">6</span></code></pre>

      <h3>isEmpty() : boolean</h3>
      <p><code>isEmpty</code> returns a boolean: <code>true</code> if the set has no items, and <code>false</code> if it has any items.</p>
<pre><code>test <span class="comment">'SimpleSet::isEmpty returns true if the set has no items', -&gt;</span>
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.SimpleSet()
  ok <span class="keyword">set</span>.<span class="built_in">isEmpty</span>()
  <span class="keyword">set</span>.add(<span class="comment">'a')</span>
  equal <span class="keyword">set</span>.<span class="built_in">isEmpty</span>(), <span class="literal">false</span></code></pre>

      <h3>clear() : Array</h3>
      <p><code>clear</code> removes all items from a set. Returns an array of all the items in the set.</p>
<p><em>Note</em>: Set iteration order is not defined, so the order of the array of items returned by <code>clear</code> is undefined.</p>
<pre><code>test <span class="comment">'SimpleSet::clear empties the set', -&gt;</span>
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.SimpleSet(<span class="comment">'a', 'b', 'c')</span>
  equal <span class="keyword">set</span>.<span class="built_in">isEmpty</span>(), <span class="literal">false</span>
  deepEqual <span class="keyword">set</span>.clear().sort(), [<span class="comment">'a', 'b', 'c']</span>
  ok <span class="keyword">set</span>.<span class="built_in">isEmpty</span>()</code></pre>

      <h3>replace(collection : Enumerable) : Array</h3>
      <p><code>replace</code> removes all the items in a set and then adds all the items found in another <code>collection</code>. The other collection must have a <code>toArray</code> function which returns an array representation of the collection. Returns the array of items added.</p>
<pre><code>test <span class="attribute">'SimpleSet</span>::replace empties the set <span class="keyword">and</span> <span class="keyword">then</span> adds items from a different collection', -&gt;
  set = <span class="keyword">new</span> Batman.SimpleSet(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  secondSet = <span class="keyword">new</span> Batman.SimpleSet(<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>')
  deepEqual set.replace(secondSet).sort(), [<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>']
  deepEqual set.toArray().sort(), [<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>']</code></pre>

      <h3>toArray() : Array</h3>
      <p><code>toArray</code> returns an array representation of the set.</p>
<p><em>Note</em>: Set iteration order is not defined, so the order in which the set&#39;s items appear in the array is not defined. It is however stable, so the order of the items in two successive <code>toArray</code> calls where the set was not modified in between should be the same.</p>
<pre><code>test <span class="attribute">'SimpleSet</span>::toArray returns an <span class="keyword">array</span> representation <span class="keyword">of</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.SimpleSet()
  deepEqual set.toArray(), []
  set.add(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>']</code></pre>

      <h3>merge(collections... : Enumerable) : SimpleSet</h3>
      <p><code>merge</code> adds all the items in a set and all the items in the passed <code>collections</code> to a new set and returns it. A <code>collection</code> is an object which has a <code>forEach</code> function. <code>merge</code> is a non-destructive collection union, so the set <code>merge</code> is called on and each <code>collection</code> passed to <code>merge</code> are unaffected by the call.</p>
<pre><code>test <span class="attribute">'SimpleSet</span>::merge returns a <span class="keyword">new</span> set <span class="keyword">with</span> the items <span class="keyword">of</span> the original set <span class="keyword">and</span> the passed set', -&gt;
  abc = <span class="keyword">new</span> Batman.SimpleSet(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  def = <span class="keyword">new</span> Batman.SimpleSet(<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>')
  equal Batman.typeOf(set = abc.merge(def)), <span class="attribute">'Object</span>'
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>', <span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>']</code></pre>

      <h3>indexedBy(key : String) : SetIndex</h3>
      <p><code>indexedBy</code> returns a hash of sets which buckets all the items in the callee set by the value of a particular <code>key</code>. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to a set of the items with that value at the <code>key</code> is built. This hash of sets is a smart object called a <code>SetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the set index remains up to date. <code>SetIndex</code> also has a friend named <code>UniqueSetIndex</code> which will give you a hash of items instead of a hash of sets with items for easy access if you know each item&#39;s value at the <code>key</code> is unique.</p>
<pre><code>test 'SimpleSet::indexedBy returns a new SetIndex <span class="keyword">with</span> <span class="keyword">the</span> items bucketed <span class="keyword">by</span> <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span> key', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet(Batman(colour: 'blue'), Batman(colour: 'green'), Batman(colour: 'blue'))
  index = <span class="keyword">set</span>.indexedBy('colour')
  ok index.<span class="keyword">get</span>('blue') instanceof Batman.Set
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">2</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('green').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">1</span></code></pre>
<p><em>Note</em>: <code>SetIndex</code> on <code>SimpleSet</code> can&#39;t maintain up-to-datedness as the state of the set or items change. It can on a bonified <code>Set</code> however, so if you need a <code>SetIndex</code> which will be guaranteed up to date as items in the set change or the values of the observed <code>key</code> change on items, use a <code>Set</code> and <code>Set::indexedBy</code> instead of <code>SimpleSet::indexedBy</code>.</p>

      <h3>indexedByUnique(key : String) : UniqueSetIndex</h3>
      <p><code>indexedByUnique</code> returns a hash of items keyed by the value of the given <code>key</code> on each item from the callee set. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to an item with that value at the <code>key</code> is built. This hash of items is a smart object called a <code>UniqueSetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the index remains up to date. Note that the semantics for which item ends up in the hash if two items have the same value for the <code>key</code> are undefined, so it is wise to only use <code>UniqueSetIndex</code>es on keys who&#39;s values are going to be unique in the set. If the values are not going to be unique, you may be interested in <code>SetIndex</code> and <code>Set::indexedBy</code>.</p>
<pre><code>test <span class="comment">'SimpleSet::indexedByUnique returns a new UniqueSetIndex with the items hashed by the value of the key', -&gt;</span>
  greenItem = Batman(colour: <span class="comment">'green')</span>
  blueItem = Batman(colour: <span class="comment">'blue')</span>
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.SimpleSet(greenItem, blueItem)
  index = <span class="keyword">set</span>.indexedByUnique(<span class="comment">'colour')</span>
  ok blueItem == index.<span class="keyword">get</span>(<span class="comment">'blue')</span>
  ok greenItem == index.<span class="keyword">get</span>(<span class="comment">'green')</span>
  equal undefined, index.<span class="keyword">get</span>(<span class="comment">'red')</span></code></pre>
<p><em>Note</em>: <code>UniqueSetIndex</code> when created on a <code>SimpleSet</code> can&#39;t maintain up-to-datedness as the state of the set or items change. It can on a bonified <code>Set</code> however, so if you need a <code>UniqueSetIndex</code> which will be guaranteed up to date as items in the set change or the values of the observed <code>key</code> change on items, use a <code>Set</code> and <code>Set::indexedByUnique</code> instead of <code>SimpleSet::indexedByUnique</code>.</p>

      <h3>sortedBy(key: String [, order: String]) : SetSort</h3>
      <p><code>sortedBy</code> returns a <code>Set</code> like object containing all the items of the callee set but with a defined iteration order (unlike <code>SimpleSet</code>). The iteration order is defined as the alpha numeric sorting of the values of the passed <code>key</code> gotten from each item. The direction of the sort can be controlled with the <code>order</code> argument, which defaults to <code>asc</code> (short for ascending) or can be passed as <code>desc</code> (short for descending). This <code>Set</code> like object is a <code>SetSort</code> which encapsulates the logic to get the values from each item at the passed <code>key</code> and traverse the <code>Set</code> in the values sorted order.</p>
<p><code>SetSort</code>s are useful for getting a transform of a <code>Set</code> which sorted, but also because the sort stays up to date as items are added or removed to the sorted set, or the value at the <code>key</code> changes on any of the items in the set.</p>
<pre><code>test 'SimpleSet::sortedBy returns a new SetSort who can be iterated <span class="keyword">in</span> <span class="keyword">the</span> sorted order <span class="keyword">of</span> <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span> key <span class="function_start"><span class="keyword">on</span> <span class="title">each</span></span> <span class="property">item</span>', -&gt;
  <span class="keyword">set</span> = new Batman.SimpleSet(Batman(place: <span class="number">3</span>, <span class="property">name</span>: 'Harry'), Batman(place: <span class="number">1</span>, <span class="property">name</span>: 'Tom'), Batman(place: <span class="number">2</span>, <span class="property">name</span>: 'Camilo'))
  sort = <span class="keyword">set</span>.sortedBy('place')
  deepEqual sort.toArray().map((<span class="property">item</span>) -&gt; <span class="property">item</span>.<span class="keyword">get</span>('<span class="property">name</span>')), ['Tom', 'Camilo', 'Harry']</code></pre>

      <h3>Batman.Set</h3>
      <p><code>Set</code> is an observable, <code>Batman.Object</code> wrapper around <code>SimpleSet</code>.</p>
<h4>SimpleSet vs Set</h4>
<p><code>SimpleSet</code> and <code>Set</code> are two distinct classes in Batman. <code>SimpleSet</code> implements the basic set semantics, but it is <em>not</em> a <code>Batman.Object</code>, so properties on it (like its <code>length</code> or <code>toArray</code>) cannot be bound. <code>Set</code> is a <code>Batman.Object</code>, so it can be observed, and thus plays nicely with the accessor system. Use a <code>SimpleSet</code> only when you know nothing will need to be observed on the set you are creating, which usually isn&#39;t a valid assumption. If it is in fact valid, consider using a native array as well, as iteration and membership checks will be faster.</p>
<h3>constructor(items...)</h3>
<p>When creating a <code>Set</code>, items forming the initial set can be passed as separate arguments to the constructor</p>
<pre><code>test <span class="attribute">'new</span> Set constructor can be called without arguments', -&gt;
  set = <span class="keyword">new</span> Batman.Set
  deepEqual set.toArray(), []

test <span class="attribute">'new</span> Set constructor can be passed items <span class="keyword">to</span> add <span class="keyword">to</span> the set.', -&gt;
  set = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>']</code></pre>
<h3>length : number</h3>
<p>A count of the items in a <code>Set</code> can be found at its <code>length</code> property.</p>
<h3>isEmpty : boolean</h3>
<p>Observable property for <code>isEmpty()</code></p>
<h3>toArray : Array</h3>
<p>Observable property for <code>toArray()</code>. Whenever items are added or removed on the set, the <code>toArray</code> property will change. This is the mechanism by which Batman&#39;s view bindings get notified of collection updates.</p>
<pre><code>test <span class="attribute">'observers</span> <span class="keyword">on</span> the toArray <span class="keyword">property</span> fire <span class="keyword">when</span> the set changes', -&gt;
  set = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  set.observe(<span class="attribute">'toArray</span>', (newArray) -&gt; log newArray.sort())
  deepEqual set.add(<span class="attribute">'d</span>'), [<span class="attribute">'d</span>']
  deepEqual logged.last, [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>', <span class="attribute">'d</span>']
  deepEqual set.remove(<span class="attribute">'b</span>'), [<span class="attribute">'b</span>']
  deepEqual logged.last, [<span class="attribute">'a</span>', <span class="attribute">'c</span>', <span class="attribute">'d</span>']</code></pre>
<h3>has(item) : Boolean</h3>
<p><code>has</code> returns a boolean describing if the given <code>item</code> is a member of the set.</p>
<p><em>Note</em>: Using <code>has(item)</code> in an accessor body will register the set <code>has</code> is called upon as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated, because the set may now have or not have the item in question.</p>
<pre><code>test <span class="string">'Set::has indicates if an item is a member of the set or not.'</span>, -&gt;
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.Set(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)
  ok <span class="keyword">set</span>.has(<span class="string">'a'</span>)
  equal <span class="keyword">set</span>.has(<span class="string">'d'</span>), <span class="literal">false</span>

test <span class="string">'Set::has registers the set as a source of an accessor'</span>, -&gt;
  (<span class="class"><span class="keyword">class</span> <span class="title">Team</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    <span class="title">constructor</span>: -&gt;
      @<span class="title">awards</span> = <span class="title">new</span> <span class="title">Batman</span>.<span class="title">Set</span>()

    @<span class="title">accessor</span> '<span class="title">bestEver</span>?', -&gt; @<span class="title">get</span>('<span class="title">awards</span>').<span class="title">has</span>('<span class="title">Stanley</span> <span class="title">Cup</span>')
  )
  <span class="title">team</span> = <span class="title">new</span> <span class="title">Team</span>
  <span class="title">team</span>.<span class="title">observeAndFire</span> '<span class="title">bestEver</span>?', (<span class="title">status</span>) -&gt; <span class="title">log</span> <span class="title">status</span>
  <span class="title">team</span>.<span class="title">get</span>('<span class="title">awards</span>').<span class="title">add</span> '<span class="title">Eastern</span> <span class="title">Conference</span> <span class="title">Champs</span>'
  <span class="title">equal</span> <span class="title">logged</span>.<span class="title">last</span>, <span class="title">false</span>
  <span class="title">team</span>.<span class="title">get</span>('<span class="title">awards</span>').<span class="title">add</span> '<span class="title">Stanley</span> <span class="title">Cup</span>'
  <span class="title">equal</span> <span class="title">logged</span>.<span class="title">last</span>, <span class="title">true</span></code></pre>
<h3>add(items...)</h3>
<p><code>add</code> adds 0 or more new items to the set. <code>add</code> returns an array of the items which have been newly added to the set, which is to say the intersection of the argument items and the set&#39;s complement before addition.</p>
<p><code>add</code> fires the <code>itemsWereAdded</code> event with the list of items newly added to the set if that list has length greater than 0. This is to say the event will not be fired if the items passed to add were all already members of the set.</p>
<pre><code>test <span class="attribute">'Set</span>::add adds an item <span class="keyword">to</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.Set()
  equal set.has(<span class="attribute">'a</span>'), false
  deepEqual set.add(<span class="attribute">'a</span>'), [<span class="attribute">'a</span>']
  equal set.has(<span class="attribute">'a</span>'), true

test <span class="attribute">'Set</span>::add returns only the <span class="keyword">new</span> items that weren\<span class="attribute">'t</span> previously <span class="keyword">in</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>')
  deepEqual set.add(<span class="attribute">'b</span>',<span class="attribute">'c</span>',<span class="attribute">'d</span>').sort(), [<span class="attribute">'c</span>', <span class="attribute">'d</span>']
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>', <span class="attribute">'d</span>']

test <span class="attribute">'Set</span>::add fires the itemsWereAdded event <span class="keyword">with</span> the items newly added <span class="keyword">to</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>')
  set.<span class="keyword">on</span>(<span class="attribute">'itemsWereAdded</span>', (items...) -&gt; log items)
  set.add(<span class="attribute">'b</span>',<span class="attribute">'c</span>',<span class="attribute">'d</span>')
  deepEqual logged.last.sort(), [<span class="attribute">'c</span>',<span class="attribute">'d</span>']

test <span class="attribute">'Set</span>::add does <span class="keyword">not</span> fire the itemsWereAdded event <span class="keyword">if</span> the added items were already <span class="keyword">in</span> the set.', -&gt;
  set = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>')
  set.<span class="keyword">on</span>(<span class="attribute">'itemsWereAdded</span>', (items...) -&gt; log items)
  set.add(<span class="attribute">'a</span>', <span class="attribute">'b</span>')
  equal typeof logged.last, <span class="attribute">'undefined</span>'</code></pre>
<h3>remove(items...)</h3>
<p><code>remove</code> removes 0 or more items from the set. <code>remove</code> returns an array of the items which were successfully removed from the set, which is to say the intersection of the argument items and the set itself before removal.</p>
<p><code>remove</code> fires the <code>itemsWereRemoved</code> event with the list of removed items if that list has length greater than 0. This is to say the event will not be fired if none of the passed items were members of the set.</p>
<pre><code>test 'Set::remove removes an <span class="property">item</span> <span class="keyword">from</span> <span class="keyword">the</span> <span class="keyword">set</span>', -&gt;
  <span class="keyword">set</span> = new Batman.Set('a')
  <span class="keyword">equal</span> <span class="keyword">set</span>.has('a'), <span class="constant">true</span>
  deepEqual <span class="keyword">set</span>.remove('a'), ['a']
  <span class="keyword">equal</span> <span class="keyword">set</span>.has('a'), <span class="constant">false</span>

test 'Set::remove returns only <span class="keyword">the</span> new items <span class="keyword">that</span> were previously <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">set</span>', -&gt;
  <span class="keyword">set</span> = new Batman.Set('a', 'b')
  deepEqual <span class="keyword">set</span>.remove('b','c','d').sort(), ['b']
  deepEqual <span class="keyword">set</span>.toArray(), ['a']

test 'Set::remove fires <span class="keyword">the</span> itemsWereRemoved event <span class="keyword">with</span> <span class="keyword">the</span> items removed <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">set</span>', -&gt;
  <span class="keyword">set</span> = new Batman.Set('a', 'b', 'c')
  <span class="keyword">set</span>.<span class="keyword">on</span>('itemsWereRemoved', (items...) -&gt; <span class="command">log</span> items)
  <span class="keyword">set</span>.remove('b','c')
  deepEqual logged.<span class="keyword">last</span>.sort(), ['b','c']

test 'Set::remove <span class="keyword">does</span> <span class="keyword">not</span> fire <span class="keyword">the</span> itemsWereRemoved event <span class="keyword">if</span> <span class="keyword">the</span> removed items were <span class="keyword">not</span> already members <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">set</span>.', -&gt;
  <span class="keyword">set</span> = new Batman.Set('a', 'b')
  <span class="keyword">set</span>.<span class="keyword">on</span>('itemsWereRemoved', (items...) -&gt; <span class="command">log</span> items)
  <span class="keyword">set</span>.remove('c', 'd')
  <span class="keyword">equal</span> typeof logged.<span class="keyword">last</span>, 'undefined'</code></pre>
<h3>find(testFunction : function) : [Object]</h3>
<p><code>find</code> returns the first item within the set for which the <code>testFunction</code> called with the item returns <code>true</code>, or <code>undefined</code> if no item passes the test.</p>
<p><em>Note</em>: <code>find</code> returns the first item the test passes for, but since set iteration has no specified order, no guarantee can be made about which item will be returned if more than one item in the set passes the test. However, set iteration order is stable, so <code>find</code> called on the same set twice should return the same item.</p>
<pre><code>test 'Set::find returns <span class="keyword">the</span> <span class="keyword">first</span> <span class="property">item</span> <span class="keyword">for</span> which <span class="keyword">the</span> test function passes', -&gt;
  <span class="keyword">set</span> = new Batman.Set(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
  <span class="keyword">equal</span> <span class="keyword">set</span>.find((x) -&gt; x % <span class="number">2</span> == <span class="number">0</span>), <span class="number">2</span>

test 'Set::find returns undefined <span class="keyword">if</span> no items pass <span class="keyword">the</span> test function', -&gt;
  <span class="keyword">set</span> = new Batman.Set(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)
  <span class="keyword">equal</span> typeof <span class="keyword">set</span>.find((x) -&gt; x &gt; <span class="number">5</span>), 'undefined'</code></pre>
<h3>forEach(iteratorFunction : function[, context: Object])</h3>
<p><code>forEach</code> calls the <code>iteratorFunction</code> with each item in the set, optionally executing the <code>iteratorFunction</code> in the passed context. Returns <code>undefined</code>.</p>
<p><em>Note</em>: Set iteration order is not defined, thus Set client code cannot rely on one item being iterated over before another, regardless of when the Set&#39;s items were added. If you need an ordered set, Batman provides <code>SetSort</code> for exactly this, while including the added benefit of observability. If you need a one time ordering of a set, you can get the array representation with <code>toArray</code> and then use vanilla JavaScript <code>sort</code> on that array.</p>
<p><em>Note</em>: Using <code>forEach()</code> in an accessor body will register the set iterated over as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated. This can become an issue if you iterate over a set and modify the set&#39;s items, as when the property recalculates that modification will potentially happen on items it&#39;s happened on previously.</p>
<pre><code>test <span class="string">'Set::forEach iterates over each item in the set'</span>, -&gt;
  sum = <span class="number">0</span>
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.Set(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
  <span class="keyword">set</span>.forEach (x) -&gt; sum += x
  equal sum, <span class="number">6</span>

test <span class="string">'Set::forEach iterates over each item in the set optionally in the provided context'</span>, -&gt;
  context = {sum: <span class="number">0</span>}
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.Set(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
  <span class="keyword">set</span>.forEach((x) -&gt;
    @sum += x
  , context)
  equal context.sum, <span class="number">6</span>

test <span class="string">'Set::forEach registers the set as a source if called in an accessor body'</span>, -&gt;
  (<span class="class"><span class="keyword">class</span> <span class="title">Team</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    <span class="title">constructor</span>: -&gt;
      @<span class="title">players</span> = <span class="title">new</span> <span class="title">Batman</span>.<span class="title">Set</span>()
    @<span class="title">accessor</span> '<span class="title">willWinTheCup</span>?', -&gt;
      <span class="title">sedinCount</span> = 0
      @<span class="title">players</span>.<span class="title">forEach</span> (<span class="title">player</span>) -&gt;
        <span class="title">sedinCount</span>++ <span class="title">if</span> <span class="title">player</span>.<span class="title">split</span>(' ')[1] == '<span class="title">Sedin</span>'
      <span class="title">sedinCount</span> &gt;= 2
  )
  <span class="title">team</span> = <span class="title">new</span> <span class="title">Team</span>()
  <span class="title">team</span>.<span class="title">observeAndFire</span> '<span class="title">willWinTheCup</span>?', (<span class="title">status</span>) -&gt; <span class="title">log</span> <span class="title">status</span>
  <span class="title">equal</span> <span class="title">team</span>.<span class="title">get</span>('<span class="title">willWinTheCup</span>?'), <span class="title">false</span>
  <span class="title">team</span>.<span class="title">get</span>('<span class="title">players</span>').<span class="title">add</span> '<span class="title">Henrik</span> <span class="title">Sedin</span>'
  <span class="title">equal</span> <span class="title">logged</span>.<span class="title">last</span>, <span class="title">false</span>
  <span class="title">team</span>.<span class="title">get</span>('<span class="title">players</span>').<span class="title">add</span> '<span class="title">Daniel</span> <span class="title">Sedin</span>'
  <span class="title">equal</span> <span class="title">logged</span>.<span class="title">last</span>, <span class="title">true</span></code></pre>
<h3>isEmpty() : boolean</h3>
<p><code>isEmpty</code> returns a boolean: <code>true</code> if the set has no items, and <code>false</code> if it has any items.</p>
<p><em>Note</em>: Using <code>isEmpty()</code> in an accessor body will register the set <code>isEmpty</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.</p>
<pre><code>test <span class="string">'Set::isEmpty returns true if the set has no items'</span>, -&gt;
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.Set()
  ok <span class="keyword">set</span>.isEmpty()
  <span class="keyword">set</span>.add(<span class="string">'a'</span>)
  equal <span class="keyword">set</span>.isEmpty(), <span class="literal">false</span>

test <span class="string">'Set::isEmpty registers the set as a source of an accessor'</span>, -&gt;
  (<span class="class"><span class="keyword">class</span> <span class="title">Team</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Object</span>
    <span class="title">constructor</span>: -&gt;
      @<span class="title">games</span> = <span class="title">new</span> <span class="title">Batman</span>.<span class="title">Set</span>()
    @<span class="title">accessor</span> '<span class="title">seasonStarted</span>?', -&gt; !@<span class="title">games</span>.<span class="title">isEmpty</span>()
  )
  <span class="title">team</span> = <span class="title">new</span> <span class="title">Team</span>
  <span class="title">equal</span> <span class="title">team</span>.<span class="title">get</span>('<span class="title">seasonStarted</span>?'), <span class="title">false</span>
  <span class="title">team</span>.<span class="title">get</span>('<span class="title">games</span>').<span class="title">add</span>({</span>win: <span class="literal">true</span>})
  equal team.<span class="keyword">get</span>(<span class="string">'seasonStarted?'</span>), <span class="literal">true</span></code></pre>
<h3>clear() : Array</h3>
<p><code>clear</code> removes all items from a set. Returns an array of all the items in the set.</p>
<p><code>clear</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set.</p>
<p><em>Note</em>: Set iteration order is not defined, so the order of the array of items returned by <code>clear</code> is undefined.</p>
<pre><code>test <span class="comment">'Set::clear empties the set', -&gt;</span>
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.<span class="keyword">Set</span>(<span class="comment">'a', 'b', 'c')</span>
  equal <span class="keyword">set</span>.<span class="built_in">isEmpty</span>(), <span class="literal">false</span>
  deepEqual <span class="keyword">set</span>.clear().sort(), [<span class="comment">'a', 'b', 'c']</span>
  ok <span class="keyword">set</span>.<span class="built_in">isEmpty</span>()

test <span class="comment">'Set::clear fires the itemsWereRemoved event with all the items in the set', -&gt;</span>
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.<span class="keyword">Set</span>(<span class="comment">'a', 'b', 'c')</span>
  <span class="keyword">set</span>.<span class="keyword">on</span>(<span class="comment">'itemsWereRemoved', (items...) -&gt; log items)</span>
  <span class="keyword">set</span>.clear()
  deepEqual logged.last.sort(), [<span class="comment">'a', 'b', 'c']</span></code></pre>
<h3>replace(collection : Enumerable) : Array</h3>
<p><code>replace</code> removes all the items in a set and then adds all the items found in another <code>collection</code>. The other collection must have a <code>toArray</code> function which returns an array representation of the collection. Returns the array of items added.</p>
<p><code>replace</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set, and then the <code>itemsWereAdded</code> event once with the items from the incoming collection.</p>
<pre><code>test <span class="attribute">'Set</span>::replace empties the set <span class="keyword">and</span> <span class="keyword">then</span> adds items from a different collection', -&gt;
  set = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  secondSet = <span class="keyword">new</span> Batman.Set(<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>')
  deepEqual set.replace(secondSet).sort(), [<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>']
  deepEqual set.toArray().sort(), [<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>']

test <span class="attribute">'Set</span>::replace fires the itemsWereRemoved event <span class="keyword">with</span> <span class="keyword">all</span> the items <span class="keyword">in</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  set.<span class="keyword">on</span>(<span class="attribute">'itemsWereRemoved</span>', (items...) -&gt; log items)
  set.replace(<span class="keyword">new</span> Batman.SimpleSet())
  deepEqual logged.last.sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>']

test <span class="attribute">'Set</span>::replace fires the itemsWereAdded event <span class="keyword">with</span> <span class="keyword">all</span> the items <span class="keyword">in</span> the incoming set', -&gt;
  set = <span class="keyword">new</span> Batman.Set()
  set.<span class="keyword">on</span>(<span class="attribute">'itemsWereAdded</span>', (items...) -&gt; log items)
  set.replace(<span class="keyword">new</span> Batman.SimpleSet(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>'))
  deepEqual logged.last.sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>']</code></pre>
<h3>toArray() : Array</h3>
<p><code>toArray</code> returns an array representation of the set.</p>
<p><em>Note</em>: Set iteration order is not defined, so the order in which the set&#39;s items appear in the array is not defined. It is however stable, so the order of the items in two successive <code>toArray</code> calls where the set was not modified in between should be the same.</p>
<p><em>Note</em>: <code>toArray</code> is also an observable property.</p>
<p><em>Note</em>: Using <code>toArray()</code> in an accessor body will register the set <code>toArray</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.</p>
<pre><code>test <span class="attribute">'Set</span>::toArray returns an <span class="keyword">array</span> representation <span class="keyword">of</span> the set', -&gt;
  set = <span class="keyword">new</span> Batman.Set()
  deepEqual set.toArray(), []
  set.add(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>']</code></pre>
<h3>merge(collections... : Enumerable) : Set</h3>
<p><code>merge</code> adds all the items in a set and all the items in the passed <code>collections</code> to a new set and returns it. A <code>collection</code> is an object which has a <code>forEach</code> function. <code>merge</code> is a non-destructive collection union, so the set <code>merge</code> is called on and each <code>collection</code> passed to <code>merge</code> are unaffected by the call.</p>
<p><em>Note</em>: Be careful about using <code>merge</code> within accessors. Calling <code>merge</code> in an accessor function body will register the set <code>merge</code> is called upon as a source of the property being calculated, which means when the set changes, that accessor will be recalculated. This means the O(n * m) merge will occur again each time, and return an entirely new <code>Set</code> instance. If the previously returned <code>Set</code> instance is retained after recalculation, this is a big memory leak. Instead of merging in accessors, try to use a <code>SetUnion</code> or a <code>SetIntersection</code>.</p>
<pre><code>test <span class="attribute">'Set</span>::merge returns a <span class="keyword">new</span> set <span class="keyword">with</span> the items <span class="keyword">of</span> the original set <span class="keyword">and</span> the passed set', -&gt;
  abc = <span class="keyword">new</span> Batman.Set(<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>')
  def = <span class="keyword">new</span> Batman.Set(<span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>')
  equal Batman.typeOf(set = abc.merge(def)), <span class="attribute">'Object</span>'
  deepEqual set.toArray().sort(), [<span class="attribute">'a</span>', <span class="attribute">'b</span>', <span class="attribute">'c</span>', <span class="attribute">'d</span>', <span class="attribute">'e</span>', <span class="attribute">'f</span>']</code></pre>
<h3>indexedBy(key : String) : SetIndex</h3>
<p><code>indexedBy</code> returns a hash of sets which buckets all the items in the callee set by the value of a particular <code>key</code>. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to a set of the items with that value at the <code>key</code> is built. This hash of sets is a smart object called a <code>SetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the set index remains up to date. <code>SetIndex</code> also has a friend named <code>UniqueSetIndex</code> which will give you a hash of items instead of a hash of sets with items for easy access if you know each item&#39;s value at the <code>key</code> is unique.</p>
<pre><code>test 'Set::indexedBy returns a new SetIndex <span class="keyword">with</span> <span class="keyword">the</span> items bucketed <span class="keyword">by</span> <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span> key', -&gt;
  <span class="keyword">set</span> = new Batman.Set(Batman(colour: 'blue'), Batman(colour: 'green'), Batman(colour: 'blue'))
  index = <span class="keyword">set</span>.indexedBy('colour')
  ok index.<span class="keyword">get</span>('blue') instanceof Batman.Set
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">2</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('green').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">1</span>

test 'Set::indexedBy returns a new SetIndex which observes <span class="keyword">the</span> <span class="keyword">set</span> <span class="keyword">for</span> new additions <span class="keyword">and</span> stays up <span class="keyword">to</span> <span class="type">date</span>', -&gt;
  <span class="keyword">set</span> = new Batman.Set(Batman(colour: 'blue'), Batman(colour: 'green'))
  index = <span class="keyword">set</span>.indexedBy('colour')
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">1</span>
  newItem = Batman(colour: 'blue')
  <span class="keyword">set</span>.add(newItem)
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">2</span>
  ok index.<span class="keyword">get</span>('blue').has(newItem)
  <span class="keyword">set</span>.remove(newItem)
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">1</span>

test 'Set::indexedBy returns a new SetIndex which observes <span class="keyword">the</span> items <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">set</span> <span class="keyword">for</span> changes <span class="keyword">to</span> <span class="keyword">the</span> observed key', -&gt;
  itemA = Batman(colour: 'blue')
  itemB = Batman(colour: 'green')
  <span class="keyword">set</span> = new Batman.Set(itemA, itemB)
  index = <span class="keyword">set</span>.indexedBy('colour')
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">1</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('green').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">1</span>
  itemA.<span class="keyword">set</span>('colour', 'green')
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">0</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('green').<span class="keyword">get</span>('<span class="property">length</span>'), <span class="number">2</span></code></pre>
<p><code>SetIndex</code>es can be created by calling the <code>indexedBy</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedBy</code> property.</p>
<pre><code>test <span class="string">"Set::get('indexedBy.someKey') returns a new SetIndex for 'someKey'"</span>, -&gt;
  <span class="keyword">set</span> = <span class="keyword">new</span> Batman.<span class="keyword">Set</span>(Batman(colour: <span class="comment">'blue'), Batman(colour: 'green'))</span>
  index = <span class="keyword">set</span>.<span class="keyword">get</span>(<span class="comment">'indexedBy.colour')</span>
  equal index.<span class="keyword">get</span>(<span class="comment">'blue').get('length'), 1</span></code></pre>
<h3>indexedByUnique(key : String) : UniqueSetIndex</h3>
<p><code>indexedByUnique</code> returns a hash of items keyed by the value of the given <code>key</code> on each item from the callee set. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to an item with that value at the <code>key</code> is built. This hash of items is a smart object called a <code>UniqueSetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the index remains up to date. Note that the semantics for which item ends up in the hash if two items have the same value for the <code>key</code> are undefined, so it is wise to only use <code>UniqueSetIndex</code>es on keys who&#39;s values are going to be unique in the set. If the values are not going to be unique, you may be interested in <code>SetIndex</code> and <code>Set::indexedBy</code>.</p>
<pre><code>test 'Set::indexedByUnique returns a new UniqueSetIndex <span class="keyword">with</span> <span class="keyword">the</span> items hashed <span class="keyword">by</span> <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span> key', -&gt;
  greenItem = Batman(colour: 'green')
  blueItem = Batman(colour: 'blue')
  <span class="keyword">set</span> = new Batman.Set(greenItem, blueItem)
  index = <span class="keyword">set</span>.indexedByUnique('colour')
  ok blueItem == index.<span class="keyword">get</span>('blue')
  ok greenItem == index.<span class="keyword">get</span>('green')
  <span class="keyword">equal</span> undefined, index.<span class="keyword">get</span>('red')

test 'Set::indexedByUnique returns a new UniqueSetIndex which observes <span class="keyword">the</span> <span class="keyword">set</span> <span class="keyword">for</span> new additions <span class="keyword">and</span> stays up <span class="keyword">to</span> <span class="type">date</span>', -&gt;
  <span class="keyword">set</span> = new Batman.Set(Batman(colour: 'blue'), Batman(colour: 'green'))
  index = <span class="keyword">set</span>.indexedByUnique('colour')
  newItem = Batman(colour: 'red')
  <span class="keyword">set</span>.add(newItem)
  ok newItem == index.<span class="keyword">get</span>('red')
  <span class="keyword">set</span>.remove(newItem)
  <span class="keyword">equal</span> undefined, index.<span class="keyword">get</span>('red')

test 'Set::indexedByUnique returns a new UniqueSetIndex which observes <span class="keyword">the</span> items <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">set</span> <span class="keyword">for</span> changes <span class="keyword">to</span> <span class="keyword">the</span> observed key', -&gt;
  itemA = Batman(colour: 'blue')
  itemB = Batman(colour: 'green')
  <span class="keyword">set</span> = new Batman.Set(itemA, itemB)
  index = <span class="keyword">set</span>.indexedByUnique('colour')
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue')?, <span class="constant">true</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('green')?, <span class="constant">true</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('red')?, <span class="constant">false</span>
  itemA.<span class="keyword">set</span>('colour', 'red')
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('blue')?, <span class="constant">false</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('green')?, <span class="constant">true</span>
  <span class="keyword">equal</span> index.<span class="keyword">get</span>('red')?, <span class="constant">true</span></code></pre>
<p><code>UniqueSetIndex</code>es can be created by calling the <code>indexedByUnique</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedByUnique</code> property.</p>
<pre><code><span class="title">test</span> <span class="string">"Set::get('indexedByUnique.someKey') returns a new UniqueSetIndex for 'someKey'"</span>, -&gt;</code></pre>
<p>  set = new Batman.Set(Batman(colour: &#39;blue&#39;), Batman(colour: &#39;green&#39;))
  index = set.get(&#39;indexedByUnique.colour&#39;)
  equal &#39;blue&#39;, index.get(&#39;blue&#39;).get(&#39;colour&#39;)</p>
<h3>sortedBy(key: String [, order: String]) : SetSort</h3>
<p><code>sortedBy</code> returns a <code>Set</code> like object containing all the items of the callee set but with a defined iteration order (unlike <code>Set</code>). The iteration order is defined as the alpha numeric sorting of the values of the passed <code>key</code> gotten from each item. The direction of the sort can be controlled with the <code>order</code> argument, which defaults to <code>asc</code> (short for ascending) or can be passed as <code>desc</code> (short for descending). This <code>Set</code> like object is a <code>SetSort</code> which encapsulates the logic to get the values from each item at the passed <code>key</code> and traverse the <code>Set</code> in the values sorted order.</p>
<p><code>SetSort</code>s are useful for getting a transform of a <code>Set</code> which sorted, but also because the sort stays up to date as items are added or removed to the sorted set, or the value at the <code>key</code> changes on any of the items in the set.</p>
<pre><code>test 'Set::sortedBy returns a new SetSort who can be iterated <span class="keyword">in</span> <span class="keyword">the</span> sorted order <span class="keyword">of</span> <span class="keyword">the</span> value <span class="keyword">of</span> <span class="keyword">the</span> key <span class="function_start"><span class="keyword">on</span> <span class="title">each</span></span> <span class="property">item</span>', -&gt;
  <span class="keyword">set</span> = new Batman.Set(Batman(place: <span class="number">3</span>, <span class="property">name</span>: 'Harry'), Batman(place: <span class="number">1</span>, <span class="property">name</span>: 'Tom'), Batman(place: <span class="number">2</span>, <span class="property">name</span>: 'Camilo'))
  sort = <span class="keyword">set</span>.sortedBy('place')
  deepEqual sort.toArray().map((<span class="property">item</span>) -&gt; <span class="property">item</span>.<span class="keyword">get</span>('<span class="property">name</span>')), ['Tom', 'Camilo', 'Harry']

test 'Set::sortedBy returns a new SetSort which observes <span class="keyword">the</span> callee <span class="keyword">set</span> <span class="keyword">for</span> additions <span class="keyword">or</span> removals <span class="keyword">and</span> puts new items <span class="keyword">in</span> <span class="keyword">the</span> sorted order', -&gt;
  <span class="keyword">set</span> = new Batman.Set(Batman(place: <span class="number">3</span>, <span class="property">name</span>: 'Harry'), Batman(place: <span class="number">1</span>, <span class="property">name</span>: 'Tom'), Batman(place: <span class="number">2</span>, <span class="property">name</span>: 'Camilo'))
  sort = <span class="keyword">set</span>.sortedBy('place')
  deepEqual sort.toArray().map((<span class="property">item</span>) -&gt; <span class="property">item</span>.<span class="keyword">get</span>('<span class="property">name</span>')), ['Tom', 'Camilo', 'Harry']
  burke = Batman(place: <span class="number">1.5</span>, <span class="property">name</span>: 'Burke')
  <span class="keyword">set</span>.add(burke)
  deepEqual sort.toArray().map((<span class="property">item</span>) -&gt; <span class="property">item</span>.<span class="keyword">get</span>('<span class="property">name</span>')), ['Tom', 'Burke', 'Camilo', 'Harry']

test 'Set::sortedBy returns a new SetSort which observes each <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> callee <span class="keyword">set</span> <span class="keyword">for</span> changes <span class="keyword">to</span> <span class="keyword">the</span> sort key', -&gt;
  harry = Batman(place: <span class="number">2</span>, <span class="property">name</span>: 'Harry')
  tom = Batman(place: <span class="number">1</span>, <span class="property">name</span>: 'Tom')
  <span class="keyword">set</span> = new Batman.Set(harry, tom)
  sort = <span class="keyword">set</span>.sortedBy('place')
  deepEqual sort.toArray().map((<span class="property">item</span>) -&gt; <span class="property">item</span>.<span class="keyword">get</span>('<span class="property">name</span>')), ['Tom', 'Harry']
  tom.<span class="keyword">set</span>('place', <span class="number">3</span>)
  deepEqual sort.toArray().map((<span class="property">item</span>) -&gt; <span class="property">item</span>.<span class="keyword">get</span>('<span class="property">name</span>')), ['Harry', 'Tom']</code></pre>
<p><code>SetSort</code>s can be created by calling the <code>sortedBy</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>sortedBy</code> property. Note that with this instantiation form you can&#39;t pass an order to the <code>SetSort</code>.</p>
<pre><code>test <span class="string">"Set::get('sortedBy.someKey') returns a new SetSort onn 'someKey'"</span>, -&gt;
  <span class="keyword">set</span> = new Batman.Set(Batman(place: <span class="number">3</span>, <span class="property">name</span>: 'Harry'), Batman(place: <span class="number">1</span>, <span class="property">name</span>: 'Tom'), Batman(place: <span class="number">2</span>, <span class="property">name</span>: 'Camilo'))
  sort = <span class="keyword">set</span>.<span class="keyword">get</span>('sortedBy.place')
  <span class="keyword">equal</span> 'Harry', sort.<span class="keyword">get</span>('toArray')[<span class="number">2</span>].<span class="keyword">get</span>('<span class="property">name</span>')</code></pre>

    <hr />
    <h2>Batman.App</h2>
    <p><code>Batman.App</code> is the central object in any Batman application. It manages the routing table and the current URL parameters, as well as the initial start of the application. It should also be used as a namespace for models and views so that other objects can find them. Batman assumes that there will only ever be one <code>Batman.App</code> in use at once.</p>

      <h3>Batman.currentApp</h3>
      <p>A Batman-wide reference to the currently running <code>Batman.App</code>.</p>

      <h3>@run() : App</h3>
      <p><code>App.run</code> is the central entry point for a Batman application. <code>@run</code> takes these steps to initialize a Batman application:</p>
<ol>
<li>Instantiate a <code>Dispatcher</code>, an internal object for mananging action dispatch to controllers.</li>
<li>Instantiate a <code>Navigator</code>, an internal object for managing the URL via pushState or hashbangs.</li>
<li>Instantiate the <code>layout</code> view according to the <code>layout</code> property on the <code>App</code>.</li>
<li>Wait for the layout view to fire it&#39;s <code>ready</code> event.</li>
<li>Start the first action dispatch by telling the <code>Navigator</code> to begin monitoring the URL.</li>
</ol>
<p><em>Note</em>: <code>@run</code> emits the <code>run</code> class event on the <code>App</code>, but not necessarily as soon as <code>@run</code> is called. Because the <code>layout</code> View renders asynchronously and may need to fetch other components, the <code>run</code> event can and often does fire long after <code>@run</code> is called. If you need to execute code as soon as the <code>App</code> has started running, add a listener to the <code>run</code> event on the <code>App</code> class. If you need to execute code as soon as the layout has rendered, you can use the <code>ready</code> event on the <code>App</code> class.</p>
<p><code>@run</code> can be called before or on the <code>load</code> DOMEvent of the window. <code>@run</code> will return the App if the commencement was successful and complete, or <code>false</code> if the App must wait for the <code>layout</code> to render or if the <code>App</code> has already run.</p>
<h4>starting an application with DOMEvents</h4>
<p><code>coffeescript
window.addEventListener &#39;load&#39;, -&gt;
  MyApp.run()</code></p>
<h4>starting an application with jQuery</h4>
<p><code>coffeescript
$ -&gt;
  MyApp.run()</code></p>

      <h3>@stop() : App</h3>
      <p><code>@stop</code> stops the <code>App</code> it&#39;s called upon. The URL will stop being monitored and no more actions will be dispatched. In usual Batman development you shouldn&#39;t have to call this.</p>

      <h3>@routes</h3>
      <p><code>@routes</code> is a class level property referencing the root level <code>NamedRouteQuery</code> which allows for binding to routes on objects. See <code>data-route</code> bindings for more information.</p>

      <h3>@controllers</h3>
      <p><code>@controllers</code> is a class level property containing the singleton <code>Batman.Controller</code> instances for each subclass in the application. This <code>controllers</code> directory puts these instances at the lowercase name of the controller. For example, the <code>TodosController</code> would be found at <code>controllers.todos</code>. <code>@controllers</code> ideally should never be bound to, but it is very useful for debugging in the console and other such workarounds.</p>
<pre><code>test <span class="string">"App.controllers references a directory of controller instances"</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Alfred</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">App</span>
  <span class="title">class</span> <span class="title">Alfred</span>.<span class="title">TodosController</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Controller</span>
  <span class="title">controller</span> = <span class="title">Alfred</span>.<span class="title">get</span>('<span class="title">controllers</span>.<span class="title">todos</span>')
  <span class="title">equal</span> <span class="title">Batman</span>.<span class="title">_functionName</span>(<span class="title">controller</span>.<span class="title">constructor</span>), "<span class="title">TodosController</span>"</code></pre>

      <h3>@layout</h3>
      
      <h3>@currentParams</h3>
      
      <h3>@paramsManager</h3>
      
      <h3>@paramsPusher</h3>
      
      <h3>&#39;run&#39; class event</h3>
      <p>The <code>run</code> class event is fired once the app has run. This indeterminately but often happens before the app&#39;s layout has finished rendering.</p>

      <h3>&#39;ready&#39; class event</h3>
      <p>The <code>ready</code> class event is fired once the app&#39;s layout is rendered.</p>

    <hr />
    <h2>Batman.App Routing</h2>
    <p>The <code>Batman</code> routing DSL is similar to Rails 3&#39;s routing DSL. It is oriented around the notion of a resource:</p>

      <h3>@resources(resourceName : String[, otherResourceNames... : String][, options : Object][, scopedCallback : Function])</h3>
      
      <h3>@member</h3>
      
      <h3>@collection</h3>
      
      <h3>@route</h3>
      
      <h3>@root</h3>
      
    <hr />
    <h2>Batman.Controller</h2>
    <p><code>Batman.Controller</code> is the base class from which all an application&#39;s controllers should descend from. <code>Batman.Controllers</code> are responsible for executing <em>actions</em> which fire off requests for model data, render views, or redirect to other actions in response to navigation state changes.</p>

      <h3>Controller Directory</h3>
      <p><code>Batman.Controller</code>s are singletons which means each controller in your application is instantiated exactly once. The instance of each controller is available on the class at the <code>@sharedContoller</code> property, or within a <code>ControllerDirectory</code> on the <code>Application</code> class. See <code>Batman.Application.controllers</code>.</p>

      <h3>Actions</h3>
      <p>Each <code>Batman.Controller</code> should have a number of instance level functions which can fetch the data needed and often render a view (or views) to display that data. These functions can be declared in typical CoffeeScript fashion like so:</p>
<p>```coffeescript
class Alfred.TodosController</p>
<p>  index: (params) -&gt;</p>
<p>  show: (params) -&gt;
```</p>
<p>Each action function receives the parameters from the dispatcher which are pulled out of the navigated-to URL. This includes both named route parameters (<code>/:foo</code> style) as well as arbitrary query paramters (<code>?foo=bar</code> style).</p>

      <h3>`routingKey` and Minification</h3>
      <p>For functionality like contextual redirects and automatic view source and class inference, Batman needs to know the name of all your <code>Controller</code> subclasses. The usual way to do this is by using <code>Function::name</code> which Batman will use in development, but this is often mangled in minified production environments. For this reason, Batman will error out on boot if a <code>Controller</code> subclass&#39; <code>routingKey</code> is not defined on the prototype. The <code>routingKey</code> is a <code>String</code> which remains unmangled after minification and thus allows Batman to continue using the aforementioned features. To disable this requirement (if you know your code won&#39;t ever be minified), set <code>Batman.config.minificationErrors</code> to false.</p>

      <h3>@beforeFilter([options : [String|Object]], filter : [String|Function])</h3>
      <p><code>@beforeFilter</code> allows controllers to declare that a function should be executed before the body of an action during action execution. <code>@beforeFilter</code> optionally accepts some options representing which action(s) to execute the filter before, and then a string naming a function or function proper to execute.</p>
<p>The <code>options</code> argument can take three forms to imply different things:</p>
<ol>
<li><code>undefined</code>: implies that this filter function should be executed before all actions.</li>
<li>a String: implies that this filter function should be executed before the action named by the string.</li>
<li><p>an Object: implies that this filter function should be executed before the actions named by an Array at the <code>only</code> key in the options object, or before all actions excluding those named by an Array at the <code>except</code> key in the options object.</p>
<p>test &quot;@beforeFilter allows declaration of filters to execute before an action&quot;, -&gt;
  class TestController extends Batman.Controller</p>
<pre><code><span class="variable">@beforeFilter</span> <span class="string">'index'</span>, -&gt; <span class="keyword">log</span> <span class="string">'before!'</span>
<span class="keyword">index</span>: -&gt;
  <span class="keyword">log</span> <span class="string">'action!'</span>
  <span class="variable">@render</span> false</code></pre>
<p>  controller = TestController.get(&#39;sharedController&#39;)
  controller.dispatch &#39;index&#39;
  equal logged[0], &#39;before!&#39;
  equal logged[1], &#39;action!&#39;</p>
<p>test &quot;@beforeFilter allows declaration of named filters to execute before an action&quot;, -&gt;
  class TodoController extends Batman.Controller</p>
<pre><code><span class="variable">@beforeFilter</span> <span class="string">'show'</span>, <span class="string">'fetchTodo'</span>
<span class="symbol">fetchTodo:</span> -&gt; <span class="variable">@set</span> <span class="string">'todo'</span>, {<span class="symbol">isDone:</span> <span class="keyword">true</span>}
<span class="symbol">show:</span> -&gt;
  <span class="variable">@render</span> <span class="keyword">false</span></code></pre>
<p>  controller = TodoController.get(&#39;sharedController&#39;)
  controller.dispatch &#39;show&#39;
  deepEqual controller.get(&#39;todo&#39;), {isDone: true}</p>
<p>test &quot;@beforeFilter allows whitelisting or blacklisting filters to execute before an action&quot;, -&gt;
  class TodoController extends Batman.Controller</p>
<pre><code>@beforeFilter {<span class="method">only:</span> [<span class="string">'show'</span>, <span class="string">'edit'</span>]}, <span class="string">'fetchTodo'</span>
@beforeFilter {<span class="method">except:</span> [<span class="string">'index'</span>]}, <span class="string">'prepareNewTodo'</span>
<span class="method">fetchTodo:</span> -&gt; @set <span class="string">'todo'</span>, {<span class="method">isDone:</span> <span class="keyword">true</span>}
<span class="method">prepareNewTodo:</span> -&gt; @set <span class="string">'newTodo'</span>, {<span class="method">isDone:</span> <span class="keyword">false</span>}
<span class="method">index:</span> -&gt; @render <span class="keyword">false</span>
<span class="method">show:</span> -&gt; @render <span class="keyword">false</span></code></pre>
<p>  controller = TodoController.get(&#39;sharedController&#39;)
  controller.dispatch &#39;show&#39;
  deepEqual controller.get(&#39;todo&#39;), {isDone: true}
  deepEqual controller.get(&#39;newTodo&#39;), {isDone: false}</p>
<p>test &quot;@beforeFilter allows declaration of filters to execute before all actions&quot;, -&gt;
  class TestController extends Batman.Controller</p>
<pre><code><span class="variable">@beforeFilter</span> -&gt; <span class="keyword">log</span> <span class="string">'before!'</span>
<span class="keyword">index</span>: -&gt;
  <span class="keyword">log</span> <span class="string">'action!'</span>
  <span class="variable">@render</span> false</code></pre>
<p>  controller = TestController.get(&#39;sharedController&#39;)
  controller.dispatch &#39;index&#39;
  equal logged[0], &#39;before!&#39;
  equal logged[1], &#39;action!&#39;</p>
</li>
</ol>

      <h3>@afterFilter([options : [String|Object]], filter : [String|Function])</h3>
      <p><code>@afterFilter</code> allows controllers to declare that a function should be run after the action body and all operations have completed during action execution. Functions declared by <code>@afterFilter</code> will thus be run after the code of the action body and also after any redirects or renders have taken place and completed. <code>@beforeFilter</code> optionally accepts some options representing which action(s) to execute the filter before, and then a string naming a function or function proper to execute. See <code>Batman.Controller.beforeFilter</code> for documentation on the structure of the options.</p>
<pre><code>test <span class="string">"@afterFilter allows declaration of filters to execute before an action"</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Controller</span>
    @<span class="title">afterFilter</span> '<span class="title">index</span>', -&gt; <span class="title">log</span> '<span class="title">after</span>!'
    <span class="title">index</span>: -&gt;
      <span class="title">log</span> '<span class="title">action</span>!'
      @<span class="title">render</span> <span class="title">false</span>

  <span class="title">controller</span> = <span class="title">TestController</span>.<span class="title">get</span>('<span class="title">sharedController</span>')
  <span class="title">controller</span>.<span class="title">dispatch</span> '<span class="title">index</span>'
  <span class="title">equal</span> <span class="title">logged</span>[0], '<span class="title">action</span>!'
  <span class="title">equal</span> <span class="title">logged</span>[1], '<span class="title">after</span>!'

<span class="title">asyncTest</span> "@<span class="title">afterFilter</span> <span class="title">filters</span> <span class="title">are</span> <span class="title">executed</span> <span class="title">after</span> <span class="title">renders</span> <span class="title">have</span> <span class="title">completed</span>", -&gt;
  <span class="title">class</span> <span class="title">MockView</span> <span class="keyword">extends</span> <span class="title">MockClass</span>
    @<span class="title">chainedCallback</span> '<span class="title">ready</span>'
    <span class="title">get</span>: <span class="title">createSpy</span>().<span class="title">whichReturns</span>("<span class="title">view</span> <span class="title">contents</span>")
    <span class="title">set</span>: -&gt;
    <span class="title">inUse</span>: -&gt; <span class="title">false</span>

  <span class="title">class</span> <span class="title">TestController</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Controller</span>
    @<span class="title">afterFilter</span> '<span class="title">index</span>', -&gt; <span class="title">log</span> '<span class="title">after</span>!'
    <span class="title">index</span>: -&gt;
      <span class="title">log</span> '<span class="title">action</span>!'
      @<span class="title">render</span> <span class="title">viewClass</span>: <span class="title">MockView</span>

  <span class="title">controller</span> = <span class="title">TestController</span>.<span class="title">get</span>('<span class="title">sharedController</span>')
  <span class="title">controller</span>.<span class="title">dispatch</span> '<span class="title">index</span>'
  <span class="title">equal</span> <span class="title">logged</span>[0], '<span class="title">action</span>!'
  <span class="title">equal</span> <span class="title">logged</span>[1], <span class="title">undefined</span>
  <span class="title">MockView</span>.<span class="title">lastInstance</span>.<span class="title">fireReady</span>()
  <span class="title">delay</span> -&gt;
    <span class="title">equal</span> <span class="title">logged</span>[1], '<span class="title">after</span>!'

<span class="title">test</span> "@<span class="title">afterFilter</span> <span class="title">allows</span> <span class="title">declaration</span> <span class="title">of</span> <span class="title">named</span> <span class="title">filters</span> <span class="title">to</span> <span class="title">execute</span> <span class="title">before</span> <span class="title">an</span> <span class="title">action</span>", -&gt;
  <span class="title">class</span> <span class="title">TodoController</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Controller</span>
    @<span class="title">afterFilter</span> '<span class="title">create</span>', '<span class="title">notify</span>'
    <span class="title">create</span>: -&gt; @<span class="title">render</span> <span class="title">false</span>
    <span class="title">notify</span>: -&gt; <span class="title">log</span> "<span class="title">Todo</span> <span class="title">created</span> <span class="title">successfully</span>."

  <span class="title">controller</span> = <span class="title">TodoController</span>.<span class="title">get</span>('<span class="title">sharedController</span>')
  <span class="title">controller</span>.<span class="title">dispatch</span> '<span class="title">create</span>'
  <span class="title">equal</span> <span class="title">logged</span>.<span class="title">last</span>, '<span class="title">Todo</span> <span class="title">created</span> <span class="title">successfully</span>.'

<span class="title">test</span> "@<span class="title">afterFilter</span> <span class="title">allows</span> <span class="title">whitelisting</span> <span class="title">or</span> <span class="title">blacklisting</span> <span class="title">filters</span> <span class="title">to</span> <span class="title">execute</span> <span class="title">before</span> <span class="title">an</span> <span class="title">action</span>", -&gt;
  <span class="title">class</span> <span class="title">TodoController</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Controller</span>
    @<span class="title">afterFilter</span> {</span>only: [<span class="string">'create'</span>, <span class="string">'update'</span>]}, <span class="string">'notify'</span>
    index: -&gt; @render <span class="literal">false</span>
    create: -&gt; @render <span class="literal">false</span>
    notify: -&gt; log <span class="string">"Todo created successfully."</span>

  controller = TodoController.<span class="keyword">get</span>(<span class="string">'sharedController'</span>)
  controller.dispatch <span class="string">'index'</span>
  equal logged.last, <span class="literal">undefined</span>
  controller.dispatch <span class="string">'create'</span>
  equal logged.last, <span class="string">'Todo created successfully.'</span>

test <span class="string">"@afterFilter allows declaration of filters to execute before all actions"</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Controller</span>
    @<span class="title">afterFilter</span> -&gt; <span class="title">log</span> '<span class="title">after</span>!'
    <span class="title">index</span>: -&gt;
      <span class="title">log</span> '<span class="title">action</span>!'
      @<span class="title">render</span> <span class="title">false</span>

  <span class="title">controller</span> = <span class="title">TestController</span>.<span class="title">get</span>('<span class="title">sharedController</span>')
  <span class="title">controller</span>.<span class="title">dispatch</span> '<span class="title">index</span>'
  <span class="title">equal</span> <span class="title">logged</span>[0], '<span class="title">action</span>!'
  <span class="title">equal</span> <span class="title">logged</span>[1], '<span class="title">after</span>!'</code></pre>

      <h3>autoScrollToHash[= true] : boolean</h3>
      <p><code>autoScrollToHash</code> is a boolean property on the instance level of a controller describing whether or not the controller should automatically scroll the browser window to the element with ID equal to the <code>hash</code> parameter. This behaviour emulates the native behaviour of the same nature, but is implemented in Batman so the functionality works after each dispatch (instead of each page refresh) and when Batman is using hash bang routing. <code>autoScrollToHash</code> is true by default.</p>

      <h3>defaultRenderYield[= &#39;main&#39;] : String</h3>
      <p><code>defaultRenderYield</code> is a <code>String</code> representing which yield a controller should automatically render into if no yield is mentioned explicitly. <code>defaultRenderYield</code> is <code>&#39;main&#39;</code> normally, which means calls to <code>@render()</code> or actions which rely on the implicit rendering render their views into the <code>main</code> yield (and end up wherever <code>data-yield=&quot;main&quot;</code> is found in your HTML).</p>

      <h3>Controller Actions</h3>
      
      <h3>executeAction</h3>
      
      <h3>render</h3>
      
      <h3>redirect</h3>
      
      <h3>scrollToHash</h3>
      
    <hr />
    <h2>Batman.Model</h2>
    <p><code>Batman.Model</code> is responsible for representing data in your application and providing a fluid interface for moving in to and out of your backend.</p>
<p><em>Note</em>: This documentation uses the term <em>model</em> to refer to the class <code>Model</code> or a <code>Model</code> subclass, and the term <em>record</em> to refer to one instance of <code>Model</code> or of a <code>Model</code> subclass.</p>

      <h3>The Asynchronous Nature of the World</h3>
      <p><code>Batman.Model</code>&#39;s operations on both the class and instance level are asynchronous and always will be. This means that the operation functions all accept node style callback functions as the last argument, and only call these callbacks when the operation is complete. Completion occurs, for example with <code>RestStorage</code>, only when the entire HTTP response has been received from the server, which can be many seconds after the original call to the operation function.</p>
<p>These callbacks follow the nodejs convention for their signatures. They should regard the first argument as an error: if it is present, an error has occurred, and if it is null or undefined, the operation was successful. Successive arguments represent the result of the operation, such as the return value from the operation function if the operation were synchronous, records returned, a boolean representing status, or response JSON.</p>

      <h3>The Identity Map</h3>
      <p>Batman uses an identity map when fetching and storing records to do its best to only ever represent a backend record with exactly one client side record. This means that if you use <code>Model.find</code> twice to fetch a record with the same ID, you will get back the same (<code>===</code>) instance in each callback. This is useful as any state the instance might be in is available and preserved no matter which piece of code asked for it, and bindings to the instance update no matter which piece of code actually updates the model.</p>
<p>Practically, the identity map is an implementation detail on Batman&#39;s end which developers shouldn&#39;t have to interact with , but knowing that you have the &quot;one true instance&quot; is helpful when reasoning about code and bindings.</p>

      <h3>Subclassing</h3>
      <p>Models in your applications should be subclasses of <code>Batman.Model</code>, or subclasses of subclasses, and so on. Extending <code>Batman.Model</code> will give your domain-modeling class all the functionality described here. Things like encoders, validations, and storage adapters will be inherited by sub-subclasses.</p>

      <h3>Storage Adapters</h3>
      <p><code>Batman.Model</code> alone only defines the logic surrounding loading and saving, but not the actual mechanism for doing so. This is left to a <code>Batman.StorageAdapter</code> subclass, 4 of which are included with Batman or in extras:</p>
<ol>
<li><code>Batman.LocalStorage</code> for storing data in the browsers&#39; <code>localStorage</code>, if available</li>
<li><code>Batman.SessionStorage</code> for storing data in the browser&#39;s <code>sessionStorage</code>, if available.</li>
<li><code>Batman.RestStorage</code> for using HTTP GET, POST, PUT, and DELETE to store data in a backend.</li>
<li><code>Batman.RailsStorage</code> which extends <code>Batman.RestStorage</code> with some handy Rails specific functionality like parsing out validation errors.</li>
</ol>

      <h3>@primaryKey : string</h3>
      <p><code>primaryKey</code> is a class level configuration option to change which key Batman uses as the primary key. Change the option using <code>set</code>, like so:</p>
<pre><code>test 'primary key can be <span class="operator"><span class="keyword">set</span> <span class="keyword">using</span> @<span class="keyword">set</span><span class="string">', -&gt;</code></pre>
<p>  class Shop extends Batman.Model
    @set &#39;primaryKey&#39;, &#39;shop_id&#39;</p>
<p>  equal Shop.get(&#39;primaryKey&#39;), &#39;shop_id&#39;</p>
<p>The <code>primaryKey</code> is what Batman uses to compare instances to see if they represent the same domain-level object: if two records have the same value at the key specified by <code>primaryKey</code>, only one will be in the identity map. The key specified by <code>primaryKey</code> is also used by the associations system when determining if a record is related to another record, and by the remote storage adapters to generate URLs for records.</p>
<p><em>Note</em>: The default primaryKey is &#39;id&#39;.</p>

      <h3>@storageKey : string</h3>
      <p><code>storageKey</code> is a class level option which gives the storage adapters something to interpolate into their specific key generation schemes. In the case of <code>LocalStorage</code> or <code>SessionStorage</code> adapters, the <code>storageKey</code> defines what namespace to store this record under in the <code>localStorage</code> or <code>sessionStorage</code> host objects, and with the case of the <code>RestStorage</code> family of adapters, the <code>storageKey</code> assists in URL generation. See the documentation for the storage adapter of your choice for more information.</p>
<p>The default <code>storageKey</code> is <code>null</code>.</p>

      <h3>@persist(mechanism : StorageAdapter) : StorageAdapter</h3>
      <p><code>@persist</code> is how a <code>Model</code> subclass is told to persist itself by means of a <code>StorageAdapter</code>. <code>@persist</code> accepts either a <code>StorageAdapter</code> class or instance and will return either the instantiated class or the instance passed to it for further modification.</p>
<pre><code>test <span class="attribute">'models</span> can be told <span class="keyword">to</span> persist via a storage adapter', -&gt;</code></pre>
<p>  class Shop extends Batman.Model
    @persist TestStorageAdapter</p>
<p>  record = new Shop
  ok record.hasStorage()</p>
<pre><code><span class="title">test</span> <span class="string">'<span class="variable">@persist</span> returns the instantiated storage adapter'</span>, -&gt;</code></pre>
<p>  adapter = false
  class Shop extends Batman.Model
    adapter = @persist TestStorageAdapter</p>
<p>  ok adapter instanceof Batman.StorageAdapter</p>
<pre><code><span class="title">test</span> <span class="string">'<span class="variable">@persist</span> accepts already instantiated storage adapters'</span>, -&gt;</code></pre>
<p>  adapter = new Batman.StorageAdapter
  adapter.someHandyConfigurationOption = true
  class Shop extends Batman.Model
    @persist adapter</p>
<p>  record = new Shop
  ok record.hasStorage()</p>

      <h3>@encode(keys...[, encoderObject : [Object|Function]])</h3>
      <p><code>@encode</code> specifies a list of <code>keys</code> a model should expect from and send back to a storage adapter, and any transforms to apply to those attributes as they enter and exit the world of Batman in the optional <code>encoderObject</code>.</p>
<p>The <code>encoderObject</code> should have an <code>encode</code> and/or a <code>decode</code> key which point to functions. The functions accept the &quot;raw&quot; data (the Batman land value in the case of <code>encode</code>, and the backend land value in the case of <code>decode</code>), and should return the data suitable for the other side of the link. The functions should have the following signatures:</p>
<p><code>coffeescript
encoderObject = {
  encode: (value, key, builtJSON, record) -&gt;
  decode: (value, key, incomingJSON, outgoingObject, record) -&gt;
}</code>
By default these functions are the identity functions. They apply no transformation. The arguments for <code>encode</code> functions are as follows:</p>
<ul>
<li><code>value</code> is the client side value of the <code>key</code> on the <code>record</code></li>
<li><code>key</code> is the key which the <code>value</code> is stored under on the <code>record</code>. This is useful when passing the same <code>encoderObject</code> which needs to pivot on what key is being encoded to different calls to <code>encode</code>.</li>
<li><code>builtJSON</code> is the object which is modified by each encoder which will eventually be returned by <code>toJSON</code>. To send the server the encoded value under a different key than the <code>key</code>, modify this object by putting the value under the desired key, and return <code>undefined</code>.</li>
<li><code>record</code> is the record on which <code>toJSON</code> has been called.</li>
</ul>
<p>For <code>decode</code> functions:</p>
<ul>
<li><code>value</code> is the server side value of the <code>key</code> which will end up on the <code>record</code>.</li>
<li><code>key</code> is the key which the <code>value</code> is stored under in the incoming JSON.</li>
<li><code>incomingJSON</code> is the JSON which is being decoded into the <code>record</code>. This can be used to create compound key decoders.</li>
<li><code>outgoingObject</code> is the object which is built up by the decoders and then <code>mixin</code>&#39;d to the record.</li>
<li><code>record</code> is the record on which <code>fromJSON</code> has been called.</li>
</ul>
<p>The <code>encode</code> and <code>decode</code> keys can also be false to avoid using the default identity function encoder or decoder.</p>
<p><em>Note</em>: <code>Batman.Model</code> subclasses have no encoders by default, except for one which automatically decodes the <code>primaryKey</code> of the model, which is usually <code>id</code>. To get any data into or out of your model, you must white-list the keys you expect from the server or storage attribute.</p>
<pre><code>test <span class="string">'@encode accepts a list of keys which are used during decoding'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>', '<span class="title">url</span>', '<span class="title">email</span>', '<span class="title">country</span>'

  <span class="title">json</span> = {</span>name: <span class="string">"Snowdevil"</span>, url: <span class="string">"snowdevil.ca"</span>}
  record = <span class="keyword">new</span> Shop()
  record.fromJSON(json)
  equal record.<span class="keyword">get</span>(<span class="string">'name'</span>), <span class="string">"Snowdevil"</span>

test <span class="string">'@encode accepts a list of keys which are used during encoding'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>', '<span class="title">url</span>', '<span class="title">email</span>', '<span class="title">country</span>'

  <span class="title">record</span> = <span class="title">new</span> <span class="title">Shop</span>(<span class="title">name</span>: "<span class="title">Snowdevil</span>", <span class="title">url</span>: "<span class="title">snowdevil</span>.<span class="title">ca</span>")
  <span class="title">deepEqual</span> <span class="title">record</span>.<span class="title">toJSON</span>(), {</span>name: <span class="string">"Snowdevil"</span>, url: <span class="string">"snowdevil.ca"</span>}

test <span class="string">'@encode accepts custom encoders'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>',
      <span class="title">encode</span>: (<span class="title">name</span>) -&gt; <span class="title">name</span>.<span class="title">toUpperCase</span>()

  <span class="title">record</span> = <span class="title">new</span> <span class="title">Shop</span>(<span class="title">name</span>: "<span class="title">Snowdevil</span>")
  <span class="title">deepEqual</span> <span class="title">record</span>.<span class="title">toJSON</span>(), {</span>name: <span class="string">"SNOWDEVIL"</span>}

test <span class="string">'@encode accepts custom decoders'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>',
      <span class="title">decode</span>: (<span class="title">name</span>) -&gt; <span class="title">name</span>.<span class="title">replace</span>('<span class="title">_</span>', ' ')

  <span class="title">record</span> = <span class="title">new</span> <span class="title">Shop</span>()
  <span class="title">record</span>.<span class="title">fromJSON</span> {</span>name: <span class="string">"Snow_devil"</span>}
  equal record.<span class="keyword">get</span>(<span class="string">'name'</span>), <span class="string">"Snow devil"</span>

test <span class="string">'@encode can be passed an encoderObject with false to prevent the default encoder or decoder'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>', {</span>encode: <span class="literal">false</span>, decode: (x) -&gt; x}
    @encode <span class="string">'url'</span>

  record = <span class="keyword">new</span> Shop()
  record.fromJSON {name: <span class="string">"Snowdevil"</span>, url: <span class="string">"snowdevil.ca"</span>}
  equal record.<span class="keyword">get</span>(<span class="string">'name'</span>), <span class="string">'Snowdevil'</span>
  equal record.<span class="keyword">get</span>(<span class="string">'url'</span>), <span class="string">"snowdevil.ca"</span>
  deepEqual record.toJSON(), {url: <span class="string">"snowdevil.ca"</span>}, <span class="string">'The name key is absent because of encode: false'</span></code></pre>
<p>Some more handy examples:</p>
<pre><code>test <span class="string">'@encode can be used to turn comma separated values into arrays'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">tags</span>',
      <span class="title">decode</span>: (<span class="title">string</span>) -&gt; <span class="title">string</span>.<span class="title">split</span>(', ')
      <span class="title">encode</span>: (<span class="title">array</span>) -&gt; <span class="title">array</span>.<span class="title">join</span>(', ')

  <span class="title">record</span> = <span class="title">new</span> <span class="title">Post</span>()
  <span class="title">record</span>.<span class="title">fromJSON</span>({</span>tags: <span class="string">'new, hot, cool'</span>})
  deepEqual record.<span class="keyword">get</span>(<span class="string">'tags'</span>), [<span class="string">'new'</span>, <span class="string">'hot'</span>, <span class="string">'cool'</span>]
  deepEqual record.toJSON(), {tags: <span class="string">'new, hot, cool'</span>}

test <span class="string">'@encode can be used to turn arrays into sets'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">tags</span>',
      <span class="title">decode</span>: (<span class="title">array</span>) -&gt; <span class="title">new</span> <span class="title">Batman</span>.<span class="title">Set</span>(<span class="title">array</span>...)
      <span class="title">encode</span>: (<span class="title">set</span>) -&gt; <span class="title">set</span>.<span class="title">toArray</span>()

  <span class="title">record</span> = <span class="title">new</span> <span class="title">Post</span>()
  <span class="title">record</span>.<span class="title">fromJSON</span>({</span>tags: [<span class="string">'new'</span>, <span class="string">'hot'</span>, <span class="string">'cool'</span>]})
  ok record.<span class="keyword">get</span>(<span class="string">'tags'</span>) <span class="keyword">instanceof</span> Batman.Set
  deepEqual record.toJSON(), {tags: [<span class="string">'new'</span>, <span class="string">'hot'</span>, <span class="string">'cool'</span>]}</code></pre>

      <h3>@validate(keys...[, options : [Object|Function]])</h3>
      <p>Validations allow a model to be marked as <code>valid</code> or <code>invalid</code> based on a set of programmatic rules. By validating a model&#39;s data before it gets to the server we can provide immediate feedback to the user about what they have entered and forgo waiting on a round trip to the server. <code>validate</code> allows the attachment of validations to the model on particular keys, where the validation is either a built in one (invoked by use of options to pass to them) or a custom one (invoked by use of a custom function as the second argument).</p>
<p><em>Note</em>: Validation in Batman is always asynchronous, despite the fact that none of the validations may use an asynchronous operation to check for validity. This is so that the API is consistent regardless of the validations used.</p>
<p>Built in validators are attached by calling <code>@validate</code> with options designating how to calculate the validity of the key:</p>
<pre><code>test <span class="string">'@validate accepts options to check for validity'</span>, -&gt;
  QUnit.expect(<span class="number">0</span>)
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">validate</span> '<span class="title">title</span>', '<span class="title">body</span>', {</span>presence: <span class="keyword">true</span>}</code></pre>
<p>The built in validation options are listed below:</p>
<ul>
<li><code>presence : boolean</code>: Assert that the string value is existent (not undefined or null) and has length greather than 0.</li>
<li><code>numeric : true</code>: Assert that the value is or can be coerced into a number using <code>parseFloat</code>.</li>
<li><code>greaterThan : number</code>: Assert that the value is greater than the given number.</li>
<li><code>greaterThanOrEqualTo : number</code>: Assert that the value is greater than or equal to the given number.</li>
<li><code>equalTo : number</code>: Assert that the value is equal to the given number.</li>
<li><code>lessThan : number</code>: Assert that the value is less than the given number.</li>
<li><code>lessThanOrEqualTo : number</code>: Assert that the value is less than or equal to the given number.</li>
<li><code>minLength : number</code>: Assert that the value&#39;s <code>length</code> property is greater than the given number.</li>
<li><code>maxLength : number</code>: Assert that the value&#39;s <code>length</code> property is less than the given number.</li>
<li><code>length : number</code>: Assert that the value&#39;s <code>length</code> property is exactly the given number.</li>
<li><code>lengthWithin : [number, number]</code> or <code>lengthIn : [number, number]</code>: Assert that the value&#39;s <code>length</code> property is within the ranger specified by the given array of two numbers, where the first number is the lower bound and the second number is the upper bound.</li>
<li><code>inclusion : in : [list, of, acceptable, values]</code>: Assert that the value is equal to one of the values in an array.</li>
<li><code>exclusion : in : [list, of, unacceptable, values]</code>: Assert that the value is not equal to any of the values in an array.</li>
</ul>
<p>Custom validators should have the signature <code>(errors, record, key, callback)</code>. The arguments are as follows:</p>
<ul>
<li><code>errors</code>: an <code>ErrorsSet</code> instance which expects to have <code>add</code> called on it to add errors to the model</li>
<li><code>record</code>: the record being validated</li>
<li><code>key</code>: the key to which the validation has been attached</li>
<li><code>callback</code>: a function to call once validation has been completed. Calling this function is <strong>mandatory</strong>.</li>
</ul>
<p>See <code>Model::validate</code> for information on how to get a particular record&#39;s validity.</p>

      <h3>@loaded : Set</h3>
      <p>The <code>loaded</code> set is available on every model class and holds every model instance seen by the system in order to function as an identity map. Successfully loading or saving individual records or batches of records will result in those records being added to the <code>loaded</code> set. Destroying instances will remove records from the identity set.</p>
<pre><code>test <span class="string">'the loaded set stores all records seen'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">persist</span> <span class="title">TestStorageAdapter</span>
    @<span class="title">encode</span> '<span class="title">name</span>'

  <span class="title">ok</span> <span class="title">Post</span>.<span class="title">get</span>('<span class="title">loaded</span>') <span class="title">instanceof</span> <span class="title">Batman</span>.<span class="title">Set</span>
  <span class="title">equal</span> <span class="title">Post</span>.<span class="title">get</span>('<span class="title">loaded</span>.<span class="title">length</span>'), 0
  <span class="title">post</span> = <span class="title">new</span> <span class="title">Post</span>()
  <span class="title">post</span>.<span class="title">save</span>()
  <span class="title">equal</span> <span class="title">Post</span>.<span class="title">get</span>('<span class="title">loaded</span>.<span class="title">length</span>'), 1

<span class="title">test</span> '<span class="title">the</span> <span class="title">loaded</span> <span class="title">adds</span> <span class="title">new</span> <span class="title">records</span> <span class="title">caused</span> <span class="title">by</span> <span class="title">loads</span> <span class="title">and</span> <span class="title">removes</span> <span class="title">records</span> <span class="title">caused</span> <span class="title">by</span> <span class="title">destroys</span>', -&gt;
  <span class="title">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>'

  <span class="title">adapter</span> = <span class="title">new</span> <span class="title">TestStorageAdapter</span>(<span class="title">Post</span>)
  <span class="title">adapter</span>.<span class="title">storage</span> =
      '<span class="title">posts1</span>': {</span>name: <span class="string">"One"</span>, id:<span class="number">1</span>}
      <span class="string">'posts2'</span>: {name: <span class="string">"Two"</span>, id:<span class="number">2</span>}

  Post.persist(adapter)
  Post.load()
  equal Post.<span class="keyword">get</span>(<span class="string">'loaded.length'</span>), <span class="number">2</span>
  post = <span class="literal">false</span>
  Post.find(<span class="number">1</span>, (err, result) -&gt; post = result)
  post.destroy()
  equal Post.<span class="keyword">get</span>(<span class="string">'loaded.length'</span>), <span class="number">1</span></code></pre>

      <h3>@all : Set</h3>
      <p>The <code>all</code> set is an alias to the <code>loaded</code> set but with an added implicit <code>load</code> on the model. <code>Model.get(&#39;all&#39;)</code> will synchronously return the <code>loaded</code> set and asynchronously call <code>Model.load()</code> without options to load a batch of records and populate the set originally returned (the <code>loaded</code> set) with the records returned by the server.</p>
<p><em>Note</em>: The notion of &quot;all the records&quot; is relative only to the client. It completely depends on the storage adapter in use and any backends which they may contact to determine what comes back during a <code>Model.load</code>. This means that if for example your API paginates records, the set found in <code>all</code> may hold on the first 50 records instead of the entire backend set.</p>
<p><code>all</code> is useful for listing every instance of a model in a view, and since the <code>loaded</code> set will change when the <code>load</code> returns, it can be safely bound to.</p>
<pre><code>asyncTest <span class="string">'the all set asynchronously fetches records when gotten'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>'

  <span class="title">adapter</span> = <span class="title">new</span> <span class="title">AsyncTestStorageAdapter</span>(<span class="title">Post</span>)
  <span class="title">adapter</span>.<span class="title">storage</span> =
      '<span class="title">posts1</span>': {</span>name: <span class="string">"One"</span>, id:<span class="number">1</span>}
      <span class="string">'posts2'</span>: {name: <span class="string">"Two"</span>, id:<span class="number">2</span>}

  Post.persist(adapter)
  equal Post.<span class="keyword">get</span>(<span class="string">'all.length'</span>), <span class="number">0</span>, <span class="string">"The synchronously returned set is empty"</span>
  delay -&gt;
    equal Post.<span class="keyword">get</span>(<span class="string">'all.length'</span>), <span class="number">2</span>, <span class="string">"After the async load the set is populated"</span></code></pre>

      <h3>@clear() : Set</h3>
      <p><code>Model.clear()</code> empties that <code>Model</code>&#39;s identity map. This is useful for tests and other unnatural situations where records new to the system are guaranteed to be as such.</p>
<pre><code>test <span class="string">'clearing a model removes all records from the identity map'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>'

  <span class="title">adapter</span> = <span class="title">new</span> <span class="title">TestStorageAdapter</span>(<span class="title">Post</span>)
  <span class="title">adapter</span>.<span class="title">storage</span> =
      '<span class="title">posts1</span>': {</span>name: <span class="string">"One"</span>, id:<span class="number">1</span>}
      <span class="string">'posts2'</span>: {name: <span class="string">"Two"</span>, id:<span class="number">2</span>}
  Post.persist(adapter)
  Post.load()
  equal Post.<span class="keyword">get</span>(<span class="string">'loaded.length'</span>), <span class="number">2</span>
  Post.clear()
  equal Post.<span class="keyword">get</span>(<span class="string">'loaded.length'</span>), <span class="number">0</span>, <span class="string">"After clear() the loaded set is empty"</span></code></pre>

      <h3>@find(id, callback : Function) : Model</h3>
      <p><code>Model.find()</code> retrieves a record with the specified <code>id</code> from the storage adapter and calls back with an error if one occurred and the record if the operation was successful. <code>find</code> delegates to the storage adapter the <code>Model</code> has been <code>@persist</code>ed with, so it is up to the storage adapter&#39;s semantics to determine what type of errors may return and the timeline on which the callback may be called. The <code>callback</code> is a required function which should adopt the node style callback signature which accepts two arguments: an error, and the record asked for. <code>find</code> returns an &quot;unloaded&quot; record which, following the load completion, will be populated with the data from the storage adapter.</p>
<p><em>Note</em>: <code>find</code> gives two results to calling code: one immediately, and one later. <code>find</code> returns a record synchronously as it is called and calls back with a record, and importantly these two records are <strong>not</strong> guaranteed to be the same instance. This is because Batman maps the identities of incoming and outgoing records such that there is only ever one canonical instance representing a record, which is useful so bindings are always bound to the same thing. In practice, this means that calling code should use the record <code>find</code> calls back with if anything is going to bind to that object, which is most of the time. The returned record however remains useful for state inspection and bookkeeping.</p>
<pre><code>asyncTest <span class="string">'@find calls back the requested model if no error occurs'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span></span>
    <span class="annotation">@encode</span> <span class="string">'name'</span>
    <span class="annotation">@persist</span> AsyncTestStorageAdapter,
      storage:
        <span class="string">'posts2'</span>: {name: <span class="string">"Two"</span>, id:<span class="number">2</span>}

  post = Post.find <span class="number">2</span>, (err, result) -&gt;
    <span class="keyword">throw</span> err <span class="keyword">if</span> err
    post = result
  equal post.get(<span class="string">'name'</span>), undefined
  delay -&gt;
    equal post.get(<span class="string">'name'</span>), <span class="string">"Two"</span></code></pre>
<p><em>Note</em>: <code>find</code> must be passed a callback function. This is for two reasons: calling code must be aware that <code>find</code>&#39;s return value is not necessarily the canonical instance, and calling code must be able to handle errors.</p>
<pre><code>asyncTest <span class="string">'@find calls back with the error if an error occurs'</span>, -&gt;
  <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">Model</span>
    @<span class="title">encode</span> '<span class="title">name</span>'
    @<span class="title">persist</span> <span class="title">AsyncTestStorageAdapter</span>

  <span class="title">error</span> = <span class="title">false</span>
  <span class="title">post</span> = <span class="title">Post</span>.<span class="title">find</span> 3, (<span class="title">err</span>, <span class="title">result</span>) -&gt;
    <span class="title">error</span> = <span class="title">err</span>
  <span class="title">delay</span> -&gt;
    <span class="title">ok</span> <span class="title">error</span> <span class="title">instanceof</span> <span class="title">Error</span></code></pre>

      <h3>@load(options = {}, callback : Function)</h3>
      <p><code>Model.load()</code> retrieves an array of records according to the given <code>options</code> from the storage adapter and calls back with an error if one occurred and the set of records if the operation was successful. <code>load</code> delegates to the storage adapter the <code>Model</code> has been <code>@persist</code>ed with, so it is up to the storage adapter&#39;s semantics to determine what the options do, what kind of errors may arise, and the timeline on which the callback may be called. The <code>callback</code> is a required function which should adopt the node style callback signature which accepts two arguments, an error, and the array of records. <code>load</code> returns undefined.</p>
<p>For the two main <code>StorageAdapter</code>s Batman provides, the <code>options</code> do different things:</p>
<ul>
<li>For <code>Batman.LocalStorage</code>, <code>options</code> act as a filter. The adapter will scan all the records in <code>localStorage</code> and return only those records which match all the key/value pairs given in the options.</li>
<li><p>For <code>Batman.RestStorage</code>, <code>options</code> are serialized into query parameters on the <code>GET</code> request.</p>
<p>asyncTest &#39;@load calls back an array of records retrieved from the storage adapter&#39;, -&gt;
  class Post extends Batman.Model</p>
<pre><code>@encode <span class="string">'name'</span>
@persist <span class="class">TestStorageAdapter</span>,
  <span class="method">storage:</span>
    <span class="string">'posts1'</span>: {<span class="method">name:</span> <span class="comment">"One"</span>, <span class="method">id:</span><span class="number">1</span>}
    <span class="string">'posts2'</span>: {<span class="method">name:</span> <span class="comment">"Two"</span>, <span class="method">id:</span><span class="number">2</span>}</code></pre>
<p>  posts = false
  Post.load (err, result) -&gt;</p>
<pre><code><span class="title">throw</span> err <span class="keyword">if</span> err
<span class="title">posts</span> = result</code></pre>
<p>  delay -&gt;</p>
<pre><code><span class="keyword">equal</span> posts.<span class="property">length</span>, <span class="number">2</span>
<span class="keyword">equal</span> posts[<span class="number">0</span>].<span class="keyword">get</span>('<span class="property">name</span>'), <span class="string">"One"</span>

asyncTest '@load calls <span class="keyword">back</span> <span class="keyword">with</span> an empty array <span class="keyword">if</span> no records are found', -&gt;</code></pre>
<p>  class Post extends Batman.Model</p>
<pre><code><span class="variable">@encode</span> <span class="string">'name'</span>
<span class="variable">@persist</span> <span class="constant">TestStorageAdapter</span></code></pre>
<p>  posts = false
  Post.load (err, result) -&gt;</p>
<pre><code><span class="title">throw</span> err <span class="keyword">if</span> err
<span class="title">posts</span> = result</code></pre>
<p>  delay -&gt;</p>
<pre><code><span class="built_in">equal</span> posts.<span class="built_in">length</span>, <span class="number">0</span></code></pre>
</li>
</ul>

      <h3>@create(attributes = {}, callback) : Model</h3>
      
      <h3>@findOrCreate(attributes = {}, callback) : Model</h3>
      
      <h3>id : value</h3>
      
      <h3>dirtyKeys : Set</h3>
      
      <h3>errors : ErrorsSet</h3>
      
      <h3>constructor(idOrAttributes = {}) : Model</h3>
      
      <h3>isNew() : boolean</h3>
      
      <h3>updateAttributes(attributes) : Model</h3>
      
      <h3>toString() : string</h3>
      
      <h3>toJSON() : Object</h3>
      
      <h3>fromJSON() : Model</h3>
      
      <h3>toParam() : value</h3>
      
      <h3>state() : string</h3>
      
      <h3>hasStorage() : boolean</h3>
      
      <h3>load(options = {}, callback)</h3>
      
      <h3>save(options = {}, callback)</h3>
      
      <h3>destroy(options = {}, callback)</h3>
      
      <h3>validate(callback)</h3>
      
    <hr />
    <h2>Batman.ValidationError</h2>
    
    <hr />
    <h2>Batman.ErrorsSet</h2>
    
    <hr />
    <h2>Batman.View</h2>
    
    <hr />
    <h2>Batman View Bindings</h2>
    <p>Batman&#39;s view bindings are how data gets shown and collected from the user. They center on the notion of &quot;bindings&quot;: that the view representation and the JavaScript land value are always guaranteed to be in sync, such that when one changes, the other will reflect it.</p>

      <h3>How to use bindings</h3>
      <p>Bindings are declared as attributes on nodes under the <code>data</code> namespace. In practice, it looks like this:</p>
<p>```html</p>
<p><div data-bind="name"></div>
```</p>
<p>This instantiates a binding on the <code>div</code> node which will update the node&#39;s <code>innerHTML</code> with the value found at the <code>name</code> keypath in the <a href="#batman-view-bindings-binding-contexts">current context</a>. Whenever the <code>name</code> key changes, the div&#39;s <code>innerHTML</code> will update to the new value.</p>
<p>Nodes can have multiple bindings:</p>
<p>```html</p>
<p data-bind="body" data-showif="isPublished"></p>
<code>or attribute bindings:</code>html
<p data-bind-id="currentID"></p>
<code>and bindings can be on inputs which the user can change:</code>html
<input type="text" data-bind="title"></input>
<code>When the `title` property changes on the JavaScript object this `input` is bound to, the `input`&#39;s value will be updated. When the user types into the `input` (and `change` or `keyup` events are triggered), the `title` property in JavaScript land will be updated.

## Binding Keypaths

A `keypath` is the value of the HTML attribute a binding references. Importantly, keypaths can have multiple segments:</code>html
<p data-bind="order.customer.name"></p>
<code>The keypath in the above HTML is `order.customer.name`. When you create a binding to a keypath like this (with dots separating segments), the binding will update the HTML value when _any_ of those segments change. In the above example, this means the `p` tag&#39;s `innerHTML` will be updated when:

 1. the order changes,
 2. the order&#39;s customer changes,
 3. or the order&#39;s customer&#39;s name changes.

This is important because it means you can rely on a binding to &quot;just work&quot; when anything it depends on changes. If say you had a `&lt;select&gt;` on the page which changed the `order`&#39;s `customer` property, bindings which bind to `order.customer.name` will update each time you change that select to reflect the new customer&#39;s name.

## Binding Contexts

All bindings render in a context. Binding contexts, known internally to Batman as `RenderContext`s, are objects which emulate the notion of variable scope in JavaScript code. When a controller action renders, it passes a context to the view consisting of itself, the `App`, and an object with a `window` key pointing to the host `window` object.

## Keypath Filters

Bindings can bind to filtered keypaths:</code>html
<p data-bind="post.body | truncate 100"></p>
<code>The above `&lt;p&gt;` will have 100 characters worth of the post&#39;s body. Whenever the post&#39;s body changes, it will be retruncated and the `&lt;p&gt;`&#39;s `innerHTML` will be updated.

Filter chains can be arbitrarily long:</code>html
<span data-bind="knight.title | prepend 'Sir' | append ', the honourable'."></span>
<code>and filter chains can use other keypaths as arguments to the filters:</code>html
<span data-bind="person.name | prepend ' ' | prepend person.title"></span>
<code>The above `&lt;span&gt;`&#39;s `innerHTML` will be updated whenever the person&#39;s name or title changes.

#### Two Way Bindings and Filters

Note that filtered keypaths cannot propagate DOM land changes because values can&#39;t always be &quot;unfiltered&quot;. For example, if we bind an input to the truncated version of a string:</code>html
<input data-bind="post.body | truncate 100"></input>
<code>The `&lt;input&gt;`&#39;s value can be updated when the `post.body` property changes but if a user types into this input field, they will edit the truncated body. If Batman updated the `post.body` property with the contents of the input, all characters which had been truncated will be lost to the nether. To avoid this loss of information and inconsistency, bindings to filtered keypaths will _only update from JavaScript land to HTML_, and never vice versa.

## Keypath Literals

Keypaths also support a select few literals within them. Numbers, strings, and booleans can be passed as arguments to filters or used as the actual value of the keypath.

The following are all valid, albeit contrived, bindings:</code>html
<!-- String literal used as an argument -->
<p data-bind="body | append ' ... '"></p>

<p><!-- Boolean literal used as an argument --></p>
<p data-showif="shouldShow | default true"></p>

<p><!-- Number literal used as an argument --></p>
<p data-bind="body | truncate 100"></p>

<p><!-- String literal used as the value --></p>
<p data-bind="'Hardcoded'"></p>

<p><!-- Boolean literal used as the value --></p>
<p><p data-showif="true"></p>
```</p>

      <h3>data-bind</h3>
      <p><code>data-bind</code> creates a two way binding between a property on a <code>Batman.Object</code> and an HTML element. Bindings created via <code>data-bind</code> will update the HTML element with the value of the JS land property as soon as they are created and each time the property changes after, and if the HTML element can be observed for changes, it will update the JS land property with the value from the HTML.</p>
<p><code>data-bind</code> will change its behaviour depending on what kind of tag it is attached to:</p>
<ul>
<li><code>&lt;input type=&quot;checkbox&quot;&gt;</code>: the binding will edit the <code>checked</code> property of the checkbox and populate the keypath with a boolean.</li>
<li><code>&lt;input type=&quot;text&quot;&gt;</code> and similar, <code>&lt;textarea</code>&gt;: the binding will edit the <code>value</code> property of the input and populate the keypath with the string found at <code>value</code>.</li>
<li><code>&lt;input type=&quot;file&quot;&gt;</code>: the binding will <em>not</em> edit the <code>value</code> property of the input, but it will update the keypath with a host <code>File</code> object or objects if the node has the <code>multiple</code> attribute.</li>
<li><code>&lt;select&gt;</code>: the binding will edit the <code>selected</code> property of each <code>&lt;option&gt;</code> tag within the <code>&lt;select&gt;</code> matching the property at the keypath. If the <code>&lt;select&gt;</code> has the multiple attribute, the value at the keypath can be an array of selected <code>&lt;option&gt;</code> values. You can also use <code>data-bind-selected</code> bindings on the individual options to toggle option selectedness.</li>
<li>All other tags: the binding will edit the <code>innerHTML</code> property of the tag and will not populate the keypath.</li>
</ul>
<p><code>data-bind</code> can also be used to bind an attribute of a node to a JavaScript property. Since attributes can&#39;t be observed for changes, this is a one way binding which will never update the JavaScript land property. Specify which attribute to bind using the &quot;double dash&quot; syntax like so: <code>data-bind-attribute=&quot;some.keypath&quot;</code>. For example, to bind the <code>placeholder</code> attribute of an input, use <code>data-bind-placeholder</code>.</p>
<p>```html</p>
<p><input type="text" data-bind-placeholder="'Specify a subtitle for product ' | append product.name">
```</p>
<p><em>Note</em>: <code>data-bind</code> will not update a JavaScript property if filters are used in the keypath.</p>

      <h3>data-source</h3>
      <p><code>data-source</code> creates a one way binding which propagates only changes from JavaScript land to the DOM, and never vice versa. <code>data-source</code> has the same semantics with regards to how it operates on different tags as <code>data-bind</code>, but it will only ever update the DOM and never the JavaScript land property.</p>
<p>For example, the HTML below will never update the <code>title</code> property on the product, even if the user changes it. Each time the <code>title</code> attribute changes from a <code>set</code> in JavaScript land, the value of the input will be updated to the new value of <code>title</code>, erasing any potential changes that have been made to the value of the input by the user.</p>
<p>```html</p>
<p><input type="text" data-source="product.title">
```</p>
<p><em>Note</em>: <code>data-source-attribute</code> is equivalent to <code>data-bind-attribute</code>, since the former is defined as never making JS land changes, and the latter is unable to.</p>

      <h3>data-target</h3>
      <p><code>data-target</code> creates a one way binding which propagates only changes from the DOM to JavaScript land, and never vice versa. <code>data-target</code> has the same semantics with regards to how it operates on different tags as <code>data-bind</code>, but it will never update the DOM even if the JavaScript land value changes.</p>
<p><em>Note</em>: <code>data-target-attribute</code> is unavailable, because DOM changes to node attributes can&#39;t be monitored.</p>

      <h3>data-showif &#x2F; data-hideif</h3>
      <p><code>data-showif</code> and <code>data-hideif</code> bind to keypaths and show or hide the node they appear on based on the truthiness of the result. <code>data-showif</code> will show a node if the given keypath evaluates to something truthy, and <code>data-hideif</code> will leave a node visible until its given keypath becomes truthy, at which point the node will be hidden. <code>data-showif</code> and <code>data-hideif</code> show and hide nodes by adding <code>display: none !important;</code> to the node&#39;s <code>style</code> attribute.</p>
<p>For example, if the HTML below is rendered where the keypath <code>product.published</code> evaluated to true, the <code>&lt;button&gt;</code> will be visible.</p>
<p>```html</p>
<p><button data-showif="product.published">Unpublish Product</button>
```</p>
<p>This is the Batman equivalent of a templating language&#39;s <code>if</code> construct, where else branches are implemented using the opposite binding.</p>
<p>```html</p>
<p><button data-showif="product.published">Unpublish Product</button></p>
<p><button data-hideif="product.published">Publish Product</button>
```</p>

      <h3>data-addclass &#x2F; data-removeclass</h3>
      <p><code>data-addclass</code> and <code>data-removeclass</code> bindings can be used to conditionally add or remove a class from a node based on a boolean keypath. Specify the class to add using the &quot;double dash&quot; syntax; for example,<code>data-addclass-big=&quot;some.keypath&quot;</code> on a node will add the &quot;big&quot; class to that node&#39;s classes if <code>some.keypath</code> is truthy. <code>data-removeclass</code> will remove a class (usually one which is present in the HTML) if the keypath passed to it is truthy.</p>
<p>The outer span in the HTML below will have an &quot;error&quot; class when the <code>product.errors.length</code> keypath evaluates to anything other than 0, since 0 is falsy and other numbers are truthy.</p>
<p><code>html
&lt;span data-addclass-error=&quot;product.errors.length&quot;&gt;This product has &lt;span data-bind=&quot;product.errors.length&quot;&gt;&lt;/span&gt; errors.&lt;/button&gt;</code></p>

      <h3>data-foreach</h3>
      <p><code>data-foreach</code> is used to loop over an iterable object in Batman views. <code>data-foreach</code> duplicates the node it occurs on for each item in the collection found at the keypath given to it, and renders each duplicated node with that node&#39;s object from the collection by putting it in the context under a name passed to it using the &quot;double dash&quot; syntax.</p>
<p>The <code>&lt;option&gt;</code> node below will be duplicated for each item in the <code>Set</code> at the <code>products</code> keypath.</p>
<p>```html</p>
<p><select>
  <option data-foreach-product="products" data-bind="product.name"></option>
</select>
```</p>
<p>Batman will execute the <code>data-foreach</code> binding before the <code>data-bind</code> on the <code>&lt;option&gt;</code> node, which means that the <code>data-bind</code> will be processed for each duplicated node with each separate Product in the <code>products</code> Set in scope for each separate node. If there were say 3 Products in the <code>products</code> set, the HTML would look similar to this once rendered:</p>
<p>```html</p>
<p><select>
  <option data-bind="product.name">Product A</option>
  <option data-bind="product.name">Product B</option>
  <option data-bind="product.name">Product C</option>
  <!-- end products -->
</select>
```</p>
<p><code>data-foreach</code> can be used to iterate over <code>Batman.Set</code>s, and most often should be, because it observes any Sets and will update the DOM with new nodes if items are added to the set, or remove nodes from the DOM if their corresponding nodes are removed from the set. <code>data-foreach</code>, like every other binding, is keypath aware, such that if the <code>Set</code> instance at the keypath changes, or any previous segment of the keypath changes, <code>data-foreach</code> will remove all the nodes currently in the DOM, and add new nodes for each new item in the incoming <code>Set</code>.</p>
<p><em>Note</em>: <code>data-foreach</code> expects to find an iterable object at the keypath given to it, and will emit a warning if it finds <code>undefined</code>.</p>
<p><em>Note</em>: <code>data-foreach</code> expects the passed enumerable to be unique. It creates a map of nodes to items, so every node needs to be able to reference exactly one object. If you simply have a set of values that you&#39;re iterating over, you should wrap your values in objects, e.g. <code>[{value: true}, {value: true}]</code>.</p>

      <h3>data-formfor</h3>
      <p><code>data-formfor</code> creates a special addition to the context stack to represent an object under edit within a form. Usually this object is a model. Using the double dash syntax, the name for the model to reside under can be specified.</p>
<p>==== Automatic Validation Display</p>
<p><code>data-formfor</code> also has some handy functionality for displaying the result of validating the object under edit in the form. This will only be enabled if the object has an <code>errors</code> Set, like <code>Batman.Models</code> do.</p>
<p>If a tag matching the relative selector <code>.errors</code> is found, it will populate this element with a list of the errors found during validation on the object. The selector for the errors container can be changed by adding a <code>data-errors-list</code> attribute with the value of the selector to the form with the <code>data-formfor</code> binding on it, or editing <code>Batman.DOM.FormBinding::defaultErrorsListSelector</code>.</p>
<p>If value bindings are made using <code>data-bind</code> to attributes on the model within the form, automatic <code>data-addclass-error</code> bindings will be added to the elements on which the <code>data-bind</code> occurs to add the &quot;error&quot; class when the model has errors on the attribute which <code>data-bind</code> binds to.</p>
<p>In the HTML below, an automatic <code>data-addclass-error</code> will be added to the <code>&lt;input&gt;</code> which activates when the <code>product</code> model has validation errors on the <code>name</code> attribute.</p>
<p>```html</p>
<p><form data-formfor-product="currentProduct">
  <input type="text" data-bind="product.name"></input>
</form>
```</p>
<p>The class which gets automatically added to inputs binding to invalid attributes can be customized by editing <code>Batman.DOM.FormBinding::errorClass</code>.</p>

      <h3>data-context</h3>
      <p><code>data-context</code> bindings add the object found at the key to the context stack, optionally under a key using the double dash syntax.</p>
<p>For example, if a <code>product</code> object exists in the current context, the <code>data-context</code> binding below will expose its attributes at the root level of the context:</p>
<p>```html</p>
<p><div data-context="product">
  <span data-bind="name"></span>
  <span data-bind="cost"></span>
</div>
```</p>
<p>Contexts added to the stack can also be scoped under a key using <code>data-context-</code>:</p>
<p>```html</p>
<p><div data-context-currentProduct="product">
  <span data-bind="currentProduct"></span>
  <span data-bind="currentProduct"></span>
</div>
```</p>
<p>This is a useful mechanism for passing local variables to partial views.</p>

      <h3>data-event</h3>
      <p><code>data-event</code> bindings add DOM event listeners to the nodes they exist on which call the function found at the passed keypath. <code>data-event</code> bindings use the double dash syntax to specify the name of the event to listen for.</p>
<p>In the HTML below, if the keypath <code>controller.nextAction</code> resolves to a function, that function will be executed each time the <code>&lt;button&gt;</code> element is clicked.</p>
<p>```html</p>
<p><button data-event-click="controller.nextAction"></button>
```</p>
<p>Functions which <code>data-event</code> calls will be passed the node and the <code>DOMEvent</code> object: <code>(node, event) -&gt;</code>.</p>
<p><code>data-event</code> supports the following types of events formally and should &quot;do the right thing&quot; when attached to elements which fire these events:</p>
<ul>
<li>click</li>
<li>doubleclick</li>
<li>change</li>
<li>submit</li>
</ul>
<p>If the event name used doesn&#39;t match the above events, the event name used will just fall through and be passed to <code>window.addEventListener</code>.</p>

      <h3>data-route</h3>
      <p><code>data-route</code> bindings are used to dispatch a new controller action upon the clicking of the node they bind to. <code>data-route</code> expects to find either a string or a <code>NamedRouteQuery</code> at the keypath passed to it. With this route, it will add an event handler to the <code>click</code> action of the element which dispatches the route and prevents the default action of the DOMEvent. <code>data-route</code> will also populate the <code>href</code> attribute if it occurs on an <code>&lt;a&gt;</code> tag so that other functons like &quot;Copy Link Address&quot; and Alt+Click continue to work on the link.</p>
<p>The first way to use <code>data-route</code> is by passing it a string, which can be built using filters or an accessor, but the preferred way is to use the <code>NamedRouteQuery</code>. These objects are generated for you by starting keypaths at the <code>App.routes</code> property. All <code>Batman.App</code>s have a <code>routes</code> property which holds a nested list of all the routes, which you descend into by passing various key segments and objects. Since the <code>App</code> object is present in the default context stack, <code>data-route</code> keypaths can just start with <code>routes</code>.</p>
<p>For example, assume the following routes definition in the current <code>Batman.App</code>:</p>
<p><code>coffeescript
class Alfred extends Batman.App
  @resources &#39;todos&#39;</code></p>
<p>This means that routes like <code>/todos</code> and <code>/todos/:id</code> exist. To route to the collection action, use the plural name of the resource:</p>
<p><code>html
&lt;a data-route=&quot;routes.todos&quot;&gt;&lt;/a&gt;</code></p>
<p>To route to an individual todo things get a bit more complicated. If we have a Todo model with ID# <code>42</code> in the context as <code>todo</code>, use the <code>get</code> filter shorthand on the <code>NamedRouteQuery</code> returned by <code>routes.todos</code> to generate a member route:</p>
<p><code>html
&lt;a data-route=&quot;routes.todos[todo]&quot;&gt;&lt;/a&gt;</code></p>
<p>Underneath, this is calling <code>Alfred.get(&#39;routes.todos&#39;).get(todo)</code>; the todo object is being passed as a key to the <code>NamedRouteQuery</code>, which knows how to generate a member route when given a record. The above HTML when rendered will look like this:</p>
<p><code>html
&lt;a data-route=&quot;routes.todos[todo]&quot; href=&quot;/todos/42&quot;&gt;&lt;/a&gt;</code></p>
<p>This syntax can be extended to nested routes. If we have nested routes, we can use chained gets to generated nested routes</p>
<p><code>coffeescript
class Tracker extends Batman.App
  @resources &#39;villains&#39;, -&gt;
    @resources &#39;crimes&#39;</code></p>
<p>Routes for collection and member crimes should look like <code>/villains/:villain_id/crimes</code> and <code>/villains/:villain_id/crimes/:id</code> respectively. Assuming the presence of a <code>villain</code> and a <code>crime</code> in the context, chained <code>get</code>s on <code>NamedRouteQuery</code>s achieve this:</p>
<p><code>html
&lt;!-- Collection of crimes for a particular villain --&gt;
&lt;a data-route=&quot;routes.villains[villain].crimes&quot;&gt;&lt;/a&gt;
&lt;!-- One crime of a particular villain --&gt;
&lt;a data-route=&quot;routes.villains[villain].crimes[crime]&quot;&gt;&lt;/a&gt;</code></p>
<p><em>Note</em>: <code>data-route</code> bindings route only to internal dispatch, and not external links. Use a regular <code>&lt;a&gt;</code> tag to link away from the application.</p>

      <h3>data-view</h3>
      <p><code>data-view</code> bindings attach custom <code>Batman.View</code> instances or instantiate custom <code>View</code> subclasses to / on a node. <code>data-view</code> expects either a <code>Batman.View</code> instance or subclass at the keypath passed to it. If an instance is passed, it will <code>set</code> the <code>node</code> property of the view to the node the <code>data-view</code> occurs on. If a class is passed, that class will be instantiated with the context the <code>data-view</code> binding executed in and with the node it occurred upon. See <code>Batman.View</code> for more information on custom Views and their uses.</p>
<p><em>Note</em>: <code>data-view</code> bindings will bind to the passed keypath until it exists, that is to say until the value of it is not <code>undefined</code>. After the <code>View</code> has been set up, the <code>data-view</code> binding will remove itself and stop observing the keypath.</p>

      <h3>data-partial</h3>
      <p><code>data-partial</code> pulls in a partial template and renders it in the current context of the node the <code>data-partial</code> occurs in. <code>data-partial</code> expects the name of the view to render in the value of the HTML attribute. <strong>Warning</strong>: This value is not a keypath. The HTML attribute&#39;s value is interpreted as a string, and the template which resides at that view path will be rendered.</p>
<p>If we have this HTML at <code>views/villains/_stub.html</code> in our app:</p>
<p><code>html
&lt;span data-bind=&quot;villain.name&quot;&gt;&lt;/span&gt;</code></p>
<p>and in <code>views/villains/show.html</code> we have this HTML:</p>
<p>```html</p>
<p><h1>A villain!</h1></p>
<p><div data-partial="villains/_stub"></div>
```</p>
<p>the contents of the <code>stub</code> partial will be inserted and rendered in the <code>&lt;div&gt;</code> above.</p>

      <h3>data-mixin</h3>
      
      <h3>data-defineview</h3>
      
      <h3>data-renderif</h3>
      
      <h3>data-yield</h3>
      
      <h3>data-contentfor</h3>
      
      <h3>data-replace</h3>
      
    <hr />
    <h2>Batman View Filters</h2>
    
      <h3>raw(value) : string</h3>
      <p>The <code>raw</code> filter renders the unescaped value.</p>
<p><code>html
&lt;span data-bind=&quot;someHTMLyString | raw&quot;&gt;&lt;/span&gt;</code></p>

      <h3>get(value, key) : value</h3>
      
      <h3>value[key] : value</h3>
      <p>Shorthand for the <code>get</code> filter.</p>

      <h3>equals(left, right) : boolean</h3>
      
      <h3>not(value) : boolean</h3>
      
      <h3>matches(value, string) : boolean</h3>
      
      <h3>truncate(value, length, end = &#39;...&#39;) : string</h3>
      
      <h3>default(value, defaultValue) : value</h3>
      
      <h3>prepend(value, string) : string</h3>
      
      <h3>append(value, string) : string</h3>
      
      <h3>replace(value, searchString, replaceString[, flags]) : string</h3>
      
      <h3>downcase(value) : string</h3>
      
      <h3>upcase(value) : string</h3>
      
      <h3>pluralize(value, count) : string</h3>
      
      <h3>humanize(string) : string</h3>
      
      <h3>join(value, separator = &#39;&#39;) : string</h3>
      
      <h3>sort(value) : value</h3>
      
      <h3>map(iterable) : value</h3>
      
      <h3>has(iterable, item) : boolean</h3>
      
      <h3>first(iterable) : value</h3>
      
      <h3>meta(value, keypath) : value</h3>
      
      <h3>interpolate(string, valuesObject) : string</h3>
      
      <h3>withArguments(function, curriedArguments...) : function</h3>
      
      <h3>routeToAction(model, action) : string</h3>
      
      <h3>escape(value) : string</h3>
      
    <hr />
</div>
