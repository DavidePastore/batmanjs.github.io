---
layout: docs
title: Views
prev_section: bindings
next_section: testing
---

<p><a href="/docs/api/batman.view.html"><code>Batman.View</code></a>s connect a batman.js application to a user by:</p>
<ul>
<li>rendering HTML templates</li>
<li>maintaining <a href="/docs/bindings.html">view bindings</a>, which bind application objects to the DOM.</li>
</ul>
<p>Views can be rendered in two ways:</p>
<ol>
<li><strong>Controller actions render views into yields.</strong> Yields are defined in the layout view with <a href="/docs/api/batman.view_bindings.html#data-yield"><code>data-yield</code> bindings</a>. Content for yields (other than <code>&quot;main&quot;</code>) is provided with <a href="http://batmanjs.org/docs/api/batman.view_bindings.html#data-contentfor"><code>data-contentfor</code> bindings</a>. This is analagous to the <a href="http://guides.rubyonrails.org/layouts_and_rendering.html#understanding-yield">Rails yield pattern</a>.</li>
<li><strong>Views render other views with <a href="/docs/api/batman.view_bindings.html#data-view"><code>data-view</code> bindings</a>.</strong> Custom views are a great choice for encapsulating UI and display components.</li>
</ol>
<p><h2  class="guide-heading" id="rendering-by-controller-actions"><a href='#rendering-by-controller-actions'>Rendering by Controller Actions</a></h2>
</p>
<p>Batman.js handles URLs by dispatching <a href="/docs/controllers.html">controller actions</a>, which render views. Controller actions may render views <em>explicitly</em> or <em>implicitly</em>. See the <a href="/docs/controllers.html">controller guide</a> for more information about how controller actions render views.</p>
<p>Everything in &quot;Custom Views&quot; below also applies default views which are rendered by controller actions. To customize a default view, simply define a class with the expected default name.</p>
<p>For example, this view is automatically rendered by the <code>products#index</code> action:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">App</span>.<span class="title">ProductsIndexView</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">View</span></span>
  <span class="comment"># source is "products/index" by default</span>

  <span class="comment"># can be bound in HTML: `data-bind='myCustomAccessor'`</span>
  <span class="property">@accessor</span> <span class="string">'myCustomAccessor'</span> -&gt; <span class="comment"># ...</span>

  <span class="comment"># can be bound in HTML: `data-event-click="myClickHandler"`</span>
  myClickHandler: -&gt; <span class="comment"># ...</span></code></pre>
<p><h2  class="guide-heading" id="rendering-with-data-view-bindings"><a href='#rendering-with-data-view-bindings'>Rendering with &quot;data-view&quot; Bindings</a></h2>
</p>
<p>Views can be <em>inserted into other views</em> by using <a href="/docs/api/batman.view_bindings.html#data-view"><code>data-view</code> bindings</a>. This allows you to simplify your HTML and view classes by extracting markup and logic in to reusable custom views.</p>
<p>To use a custom view, pass its name (relative to the app namespace) to <a href="/docs/api/batman.view_bindings.html#data-view"><code>data-view</code></a>. For example:</p>
<pre><code class="lang-html">&lt;div data-view=<span class="string">'ProductListItemView'</span>&gt;
  &lt;!-- batman.js will instantiate App.ProductListItemView <span class="reserved">with</span> <span class="keyword">this</span> node --&gt;
&lt;/div&gt;</code></pre>
<p>If the custom view has its own HTML, that HTML will replace the contents of the <a href="/docs/api/batman.view_bindings.html#data-view"><code>data-view</code></a> node.</p>
<p><h2  class="guide-heading" id="custom-views"><a href='#custom-views'>Custom Views</a></h2>
</p>
<p>Views are useful for creating reusable, configurable UI components. They are defined by extending <a href="/docs/api/batman.view.html"><code>Batman.View</code></a> and they are used by adding <a href="/docs/api/batman.view_bindings.html#data-view"><code>data-view</code> bindings</a> inside HTML templates.</p>
<p><h3  class="guide-heading" id="defining-custom-views"><a href='#defining-custom-views'>Defining Custom Views</a></h3>
</p>
<p>To define a custom view, extend <a href="/docs/api/batman.view.html"><code>Batman.View</code></a>. (You can also extend any subclass of <a href="/docs/api/batman.view.html"><code>Batman.View</code></a>, such as another custom view.)</p>
<p>For example, here&#39;s a custom view that uses <a href="http://jqueryui.com/autocomplete/">jQueryUI Autocomplete</a>:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">App</span>.<span class="title">AutocompleteView</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">View</span></span>
  html: <span class="string">"&lt;input id='autocomplete' type='text' /&gt;"</span>

  <span class="property">@accessor</span> <span class="string">'autocompleteSource'</span>, -&gt; []

  viewDidAppear: -&gt;
    <span class="comment"># @node is the container for the view</span>
    input = $(<span class="property">@node</span>).find(<span class="string">"#autocomplete"</span>)
    $(input).autocomplete
      source: <span class="property">@get</span>(<span class="string">'autocompleteSource'</span>)</code></pre>
<p>Obviously this isn&#39;t much use by itself, but we can extend it and provide more useful <code>autocompleteSource</code>s:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">App</span>.<span class="title">VillainAutocompleteView</span> <span class="keyword">extends</span> <span class="title">App</span>.<span class="title">AutocompleteView</span></span>
  <span class="property">@accessor</span> <span class="string">'autocompleteSource'</span>, -&gt; App.Villian.get(<span class="string">'all'</span>).mapToProperty(<span class="string">'name'</span>)</code></pre>
<p>Now, when we instantiate <code>App.VillianAutocompleteView</code>, it will have more interesting options!</p>
<p><h3  class="guide-heading" id="providing-html-for-custom-views"><a href='#providing-html-for-custom-views'>Providing HTML for Custom Views</a></h3>
</p>
<p>Your custom views can get HTML in three ways:</p>
<ul>
<li>wrap existing HTML</li>
<li>define an HTML string</li>
<li>define a <em>source path</em> that points to an HTML temlate.</li>
</ul>
<p>To <em>wrap existing HTML</em>, simply add a <a href="/docs/api/batman.view_bindings.html#data-view"><code>data-view</code> binding</a> to a node with HTML inside it:</p>
<pre><code class="lang-html">&lt;div data-view=<span class="string">'CustomListView'</span>&gt;
  &lt;ul&gt;
    &lt;li data-foreach-item=<span class="string">'items'</span> data-bind=<span class="string">'item.name'</span>&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</code></pre>
<p>This will instantiate a new <code>CustomListView</code> with the <code>&lt;div&gt;</code> as its <a href="/docs/api/batman.view.html#prototype_accessor_node"><code>node</code></a>. All the HTML inside the <code>CustomListView</code> will stay where it is.</p>
<p>To <em>define an HTML string</em>, set the <a href="/docs/api/batman.view.html#prototype_accessor_html"><code>html</code> attribute</a> in your view class:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">App</span>.<span class="title">SearchView</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">View</span></span>
  html: <span class="string">"&lt;input type='text' id='search' placeholder='Enter a Search Term'&gt;&lt;/input&gt;"</span></code></pre>
<p>The HTML you specify will be rendered inside a node with a <code>data-view=&quot;SearchView&quot;</code> binding.</p>
<p>To <em>define a source path</em>,  set the <a href="/docs/api/batman.view.html#prototype_accessor_source"><code>source</code> attribute</a> in your view class:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">App</span>.<span class="title">HeaderNavigationView</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">View</span></span>
  source: <span class="string">'layouts/_header_navigation'</span>
  <span class="comment"># will lookup template layouts/_header_navigation.html</span></code></pre>
<p>Your app will try to load a file relative to <a href="/docs/configuration.html"><code>Batman.config.pathToHTML</code></a> to use as this view&#39;s HTML. You don&#39;t need to add <code>.html</code> to the <code>source</code> string.</p>
<p><h3  class="guide-heading" id="accessors-and-handlers"><a href='#accessors-and-handlers'>Accessors and Handlers</a></h3>
</p>
<p>Accessors and functions inside a custom view are accessible by that <a href="/docs/bindings.html">view&#39;s bindings</a>. That allows you to slim down controllers and other views by moving things into a custom view.</p>
<p>Functions defined in custom views are available as event handlers. For example, <code>deleteItem</code> can be used in a <a href="/docs/api/batman.view_bindings.html#data-event"><code>data-event-click</code></a> binding:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span>.<span class="title">ListItemView</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">View</span></span>
  deleteItem: (item) -&gt;
    item.destroy (err, record) -&gt;
      <span class="keyword">throw</span> err <span class="keyword">if</span> err?</code></pre>
<pre><code class="lang-html">&lt;button data-event-click=<span class="string">'deleteItem | withArguments item'</span>&gt;Delete!&lt;/button&gt;</code></pre>
<p>Accessors are also available to bindings. <code>itemDescription</code> is available inside the view:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span>.<span class="title">ListItemView</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">View</span></span>
  <span class="property">@option</span> <span class="string">'item'</span> <span class="comment"># accepts value from data-view-item binding</span>
  <span class="property">@accessor</span> <span class="string">'itemDescription'</span>, -&gt;
    item = <span class="property">@lookupKeypath</span>(<span class="string">'item'</span>)
    <span class="string">"<span class="subst">#{item.get('name'}</span>, circa <span class="subst">#{item.get('year')}</span>"</span></code></pre>
<pre><code class="lang-html">&lt;ul&gt;
  &lt;li data-foreach-item=<span class="string">'items'</span> data-view=<span class="string">'ListItemView'</span> data-view-item=<span class="string">'item'</span>&gt;
    &lt;p data-bind=<span class="string">'itemDescription'</span>&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>(See <a href="/docs/api/batman.view.html#class_function_option"><code>View.option</code> docs</a> for more about view options.)</p>
<p><h2  class="guide-heading" id="view-lifecycle"><a href='#view-lifecycle'>View Lifecycle</a></h2>
</p>
<p>As a view is rendered, it fires several lifecycle events. Some events &quot;bubble up&quot; from subviews, so these events may be fired more than once.</p>
<p>One useful event is <code>viewDidAppear</code>, which is called after the view has been added to the DOM. You can initialize your view on <code>viewDidAppear</code> by defining a function with that name:</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span>.<span class="title">CustomView</span> <span class="keyword">extends</span> <span class="title">Batman</span>.<span class="title">View</span></span>
  viewDidAppear: -&gt;
    <span class="keyword">if</span> !initialized
      initialized = <span class="literal">true</span>
      $(<span class="property">@node</span>).find(<span class="string">'.date-input'</span>).datepicker()
      <span class="property">@_otherInitialization</span>()</code></pre>
<p>See the <a href="/docs/api/batman.view_lifecycle.html"><code>Batman.View</code> lifecycle API docs</a> for more information on those events and how to use them.</p>
<p><h2  class="guide-heading" id="view-hierarchy"><a href='#view-hierarchy'>View Hierarchy</a></h2>
</p>
<p>Batman.js stores all active views in a <em>tree</em>, with the <a href="/docs/api/batman.app.html#class_property_layout"><code>layout</code> view</a> as its root. Every view has one <a href="/docs/api/batman.view.html#prototype_property_superview"><code>superview</code></a> and any number of <a href="/docs/api/batman.view.html#prototype_property_subviews"><code>subviews</code></a>. Batman.js manages the view tree internally, so a developer rarely interacts with it directly.</p>
<p>The view tree serves as a rendering context for <a href="/docs/bindings.html">view bindings</a>, which climb the tree to evaluate keypaths with <a href="/docs/api/batman.view.html#prototype_function_lookupkeypath"><code>Batman.View::lookupKeypath</code></a>.</p>
<p><h2  class="guide-heading" id="debugging"><a href='#debugging'>Debugging</a></h2>
</p>
<p>Batman.js exports the global <code>$context</code> function for debugging views. <code>$context</code> takes a DOM node and returns the batman.js view for that node. For example:</p>
<pre><code class="lang-javascript">allItems = $(<span class="string">'#all_items'</span>)[<span class="number">0</span>]
view = $context(allItems)
view <span class="comment"># =&gt; App.ItemsIndexView instance</span></code></pre>
<p>In Chrome, right-click -&gt; &quot;inspect element&quot;, assigns the node to <code>$0</code>. Then you can inspect the view with <code>$context($0)</code>.</p>
<p>When you have the view, you can inspect its superview and lookup keypaths in its context:</p>
<pre><code class="lang-javascript">view.get(<span class="string">'superview'</span>)       <span class="comment"># =&gt; Layout view</span>
view.lookupKeypath(<span class="string">'items'</span>) <span class="comment"># =&gt; Batman.Set</span></code></pre>

