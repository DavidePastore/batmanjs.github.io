---
layout: api_docs
title: Batman.Enumerable
meta: 
  grouping: Data Structures
  parent: !<tag:yaml.org,2002:js/undefined> ""
sub: 
  - title: length
    meta: 
      type: property
      level: prototype
      params: !<tag:yaml.org,2002:js/undefined> ""
      returnType: number
    tokens: []
    id: prototype_property_length
    html: "<p>The number of elements.</p>\n"
  - title: forEach
    meta: 
      type: function
      level: prototype
      params: func
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    tokens: []
    id: prototype_function_foreach
    html: "<p>Calls <code>func</code> once for each element.\n<code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test <span class=\"string\">\"forEach runs n times\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  count = <span class=\"number\">0</span>\n  set.forEach -&gt; count++\n  equal count, <span class=\"number\">2</span></code></pre>\n"
  - title: map
    meta: 
      type: function
      level: prototype
      params: "func[, context = Batman.container]"
      returnType: Array
    tokens: []
    id: prototype_function_map
    html: "<p>Calls <code>func</code> once for each element, and returns an array composed of the return\nvalue at each iteration.  <code>func</code> receives the arguments <code>(element, value,\nthis)</code></p>\n<pre><code>test <span class=\"string\">\"forEach runs n times\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>, <span class=\"number\">2</span>)\n  deepEqual [<span class=\"number\">2</span>, <span class=\"number\">3</span>], set.map (x) -&gt; x + <span class=\"number\">1</span></code></pre>\n"
  - title: mapToProperty
    meta: 
      type: function
      level: prototype
      params: "key : string"
      returnType: Array
    tokens: []
    id: prototype_function_maptoproperty
    html: "<p>Returns an array composed of the property specified of each item.\n<code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test <span class=\"string\">\"mapToProperty pulls out the property specified\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set({key: <span class=\"string\">'a'</span>}, {key: <span class=\"string\">'b'</span>})\n  deepEqual [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>], set.mapToProperty(<span class=\"string\">'key'</span>)</code></pre>\n"
  - title: every
    meta: 
      type: function
      level: prototype
      params: "func[, context = Batman.container]"
      returnType: boolean
    tokens: []
    id: prototype_function_every
    html: "<p>Calls <code>func</code> once for each element, and returns true if <code>func</code> returns true for\nevery iteration.  <code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test <span class=\"string\">\"every is false when any element doesn't satisfy the selector function\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>)\n  equal <span class=\"literal\">false</span>, set.every (x) -&gt; x</code></pre>\n"
  - title: some
    meta: 
      type: function
      level: prototype
      params: "func[, context = Batman.container]"
      returnType: boolean
    tokens: []
    id: prototype_function_some
    html: "<p>Calls <code>func</code> once for each element, and returns true if <code>func</code> returns true for\nany iteration.  <code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test <span class=\"string\">\"some is true when any element satisfies the selector function\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>)\n  equal <span class=\"literal\">true</span>, set.some (x) -&gt; x</code></pre>\n"
  - title: reduce
    meta: 
      type: function
      level: prototype
      params: "func[, accumulator]"
      returnType: Array
    tokens: []
    id: prototype_function_reduce
    html: "<p>Calls <code>func</code> once for each element, accumulating the result as it goes along.\nIf you pass your own <code>accumulator</code> it will retain its initial value, otherwise\nthe first element will become the initial accumulator value.  <code>func</code> receives\nthe arguments <code>(accumulator, element, value, index, this)</code></p>\n<pre><code>test <span class=\"string\">\"reduce can implement a sum\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  equal <span class=\"number\">6</span>, set.reduce (accumulator, x) -&gt; accumulator + x</code></pre>\n"
  - title: filter
    meta: 
      type: function
      level: prototype
      params: func
      returnType: Object
    tokens: []
    id: prototype_function_filter
    html: "<p>Creates a new instance of the current type, and adds every element for which\n<code>func</code> returns true.  <code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test <span class=\"string\">\"filter strips out the crud\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'wheat'</span>, <span class=\"string\">'crud'</span>, <span class=\"string\">'grain'</span>)\n  deepEqual [<span class=\"string\">'wheat'</span>, <span class=\"string\">'grain'</span>], (set.filter (x) -&gt; x != <span class=\"string\">'crud'</span>).toArray()</code></pre>\n"
  - title: count
    meta: 
      type: function
      level: prototype
      params: func
      returnType: number
    tokens: []
    id: prototype_function_count
    html: "<p>Returns the number of elements for which <code>func</code> returns true, or the total\nnumber of elements if you don&#39;t pass a <code>func</code>.  <code>func</code> receives the arguments\n<code>(element, value, this)</code></p>\n<pre><code>test <span class=\"string\">\"count counts\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  equal <span class=\"number\">3</span>, set.count()\n  equal <span class=\"number\">2</span>, set.count (x) -&gt; x &gt; <span class=\"number\">1</span></code></pre>\n"
  - title: "Implementing your own `Batman.Enumerable`"
    tokens: []
    id: "implementing_your_own_%60batman.enumerable%60"
    html: "<p>To make these methods available for a new type, all you need to do is define\n<code>forEach()</code> and <code>length</code>. Then, in your type, you can just <code>Batman.extend\n@prototype, Batman.Enumerable</code> to copy the <code>Enumerable</code> methods onto your\nprototype.</p>\n"
tokens: []
id: batman.enumerable
html: "<p><a href=\"/docs/api/batman.enumerable.html\"><code>Batman.Enumerable</code></a> is a mixin that defines methods available for every\nenumerable type (<a href=\"/docs/api/batman.set.html\"><code>Batman.Set</code></a> and <a href=\"/docs/api/batman.hash.html\"><code>Batman.Hash</code></a> being the main two).</p>\n<p>Note that where the signature of the callback functions is defined, <code>element</code>\nis the value of the current element being iterated over, and <code>value</code> is\n<code>null</code>â€”except in the case of <a href=\"/docs/api/batman.hash.html\"><code>Batman.Hash</code></a> where <code>element</code> is the key and\n<code>value</code> is the value.</p>\n"

---

{{ page.html }}
<ul class="api-list">
{% for s in page.sub %}
  <li class="api-list-item">
    <h3 class="api-title">
      <a id="{{ s.id }}" class="anchor-target"></a>
      <a href="#{{ s.id }}" class="anchor-link">
      <span class="{% if s.meta %}monospace-heading{% endif %}">{% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}{% if s.meta.type == 'property' %}<span class="params">{{ s.meta.params }}</span>{% else %}<span class="params">({{ s.meta.params }})</span>  {% endif %}{% endif %}{% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}</span>
      </a>
    </h3>
    {{ s.html }}
  </li>
{% endfor %}
</ul>
