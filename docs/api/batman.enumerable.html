---
layout: api_docs
title: Batman.Enumerable
sub: 
  - title: length
    tokens: []
    meta: 
      type: property
      level: prototype
      params: !<tag:yaml.org,2002:js/undefined> ""
      returnType: number
    id: prototype_property_length
    html: "<p>The number of elements.</p>\n"
  - title: forEach
    tokens: []
    meta: 
      type: function
      level: prototype
      params: func
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_foreach
    html: "<p>Calls <code>func</code> once for each element.\n<code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test \"forEach runs n times\", -&gt;\n  <span class=\"operator\"><span class=\"keyword\">set</span> = new Batman.<span class=\"keyword\">Set</span>(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  <span class=\"aggregate\">count</span> = <span class=\"number\">0</span>\n  <span class=\"keyword\">set</span>.forEach -&gt; <span class=\"aggregate\">count</span>++\n  equal <span class=\"aggregate\">count</span>, <span class=\"number\">2</span></code></pre>\n"
  - title: map
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "func[, context = Batman.container]"
      returnType: Array
    id: prototype_function_map
    html: "<p>Calls <code>func</code> once for each element, and returns an array composed of the return\nvalue at each iteration.  <code>func</code> receives the arguments <code>(element, value,\nthis)</code></p>\n<pre><code><span class=\"comment\">test</span> <span class=\"comment\">\"forEach</span> <span class=\"comment\">runs</span> <span class=\"comment\">n</span> <span class=\"comment\">times\"</span>, <span class=\"literal\">-</span>&gt;\n  <span class=\"comment\">set</span> <span class=\"comment\">=</span> <span class=\"comment\">new</span> <span class=\"comment\">Batman</span>.<span class=\"comment\">Set(1</span>, <span class=\"comment\">2)</span>\n  <span class=\"comment\">deepEqual</span> <span class=\"title\">[</span><span class=\"comment\">2</span>, <span class=\"comment\">3</span>]<span class=\"string\">,</span> <span class=\"comment\">set</span>.<span class=\"comment\">map</span> <span class=\"comment\">(x)</span> <span class=\"literal\">-</span>&gt; <span class=\"comment\">x</span> <span class=\"literal\">+</span> <span class=\"comment\">1</code></pre>\n"
  - title: mapToProperty
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string"
      returnType: Array
    id: prototype_function_maptoproperty
    html: "<p>Returns an array composed of the property specified of each item.\n<code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test \"mapToProperty pulls out the property specified\", -&gt;\n  <span class=\"operator\"><span class=\"keyword\">set</span> = new Batman.<span class=\"keyword\">Set</span>({<span class=\"keyword\">key</span>: <span class=\"string\">'a'</span>}, {<span class=\"keyword\">key</span>: <span class=\"string\">'b'</span>})\n  deepEqual [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>], <span class=\"keyword\">set</span>.mapToProperty(<span class=\"string\">'key'</span>)</code></pre>\n"
  - title: every
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "func[, context = Batman.container]"
      returnType: boolean
    id: prototype_function_every
    html: "<p>Calls <code>func</code> once for each element, and returns true if <code>func</code> returns true for\nevery iteration.  <code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test \"every is false when any element doesn't satisfy the selector function\", -&gt;\n  <span class=\"operator\"><span class=\"keyword\">set</span> = new Batman.<span class=\"keyword\">Set</span>(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)\n  equal <span class=\"keyword\">false</span>, <span class=\"keyword\">set</span>.every (x) -&gt; x</code></pre>\n"
  - title: some
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "func[, context = Batman.container]"
      returnType: boolean
    id: prototype_function_some
    html: "<p>Calls <code>func</code> once for each element, and returns true if <code>func</code> returns true for\nany iteration.  <code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test \"some is true when any element satisfies the selector function\", -&gt;\n  <span class=\"operator\"><span class=\"keyword\">set</span> = new Batman.<span class=\"keyword\">Set</span>(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)\n  equal <span class=\"keyword\">true</span>, <span class=\"keyword\">set</span>.<span class=\"keyword\">some</span> (x) -&gt; x</code></pre>\n"
  - title: reduce
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "func[, accumulator]"
      returnType: Array
    id: prototype_function_reduce
    html: "<p>Calls <code>func</code> once for each element, accumulating the result as it goes along.\nIf you pass your own <code>accumulator</code> it will retain its initial value, otherwise\nthe first element will become the initial accumulator value.  <code>func</code> receives\nthe arguments <code>(accumulator, element, value, index, this)</code></p>\n<pre><code>test \"reduce can implement a sum\", -&gt;\n  <span class=\"operator\"><span class=\"keyword\">set</span> = new Batman.<span class=\"keyword\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  equal <span class=\"number\">6</span>, <span class=\"keyword\">set</span>.reduce (accumulator, x) -&gt; accumulator + x</code></pre>\n"
  - title: filter
    tokens: []
    meta: 
      type: function
      level: prototype
      params: func
      returnType: Object
    id: prototype_function_filter
    html: "<p>Creates a new instance of the current type, and adds every element for which\n<code>func</code> returns true.  <code>func</code> receives the arguments <code>(element, value, this)</code></p>\n<pre><code>test <span class=\"string\">\"filter strips out the crud\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'wheat</span>', <span class=\"attribute\">'crud</span>', <span class=\"attribute\">'grain</span>')\n  deepEqual [<span class=\"attribute\">'wheat</span>', <span class=\"attribute\">'grain</span>'], (set.filter (x) -&gt; x != <span class=\"attribute\">'crud</span>').toArray()</code></pre>\n"
  - title: count
    tokens: []
    meta: 
      type: function
      level: prototype
      params: func
      returnType: number
    id: prototype_function_count
    html: "<p>Returns the number of elements for which <code>func</code> returns true, or the total\nnumber of elements if you don&#39;t pass a <code>func</code>.  <code>func</code> receives the arguments\n<code>(element, value, this)</code></p>\n<pre><code>test \"count counts\", -&gt;\n  <span class=\"operator\"><span class=\"keyword\">set</span> = new Batman.<span class=\"keyword\">Set</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  equal <span class=\"number\">3</span>, <span class=\"keyword\">set</span>.<span class=\"aggregate\">count</span>()\n  equal <span class=\"number\">2</span>, <span class=\"keyword\">set</span>.<span class=\"aggregate\">count</span> (x) -&gt; x &gt; <span class=\"number\">1</span></code></pre>\n"
  - title: "Implementing your own `Batman.Enumerable`"
    tokens: []
    id: "implementing_your_own_%60batman.enumerable%60"
    html: "<p>To make these methods available for a new type, all you need to do is define\n<code>forEach()</code> and <code>length</code>. Then, in your type, you can just <code>Batman.extend\n@prototype, Batman.Enumerable</code> to copy the <code>Enumerable</code> methods onto your\nprototype.</p>\n"
tokens: []
id: batman.enumerable
html: "<p><code>Batman.Enumerable</code> is a mixin that defines methods available for every\nenumerable type (<code>Batman.Set</code> and <code>Batman.Hash</code> being the main two).</p>\n<p>Note that where the signature of the callback functions is defined, <code>element</code>\nis the value of the current element being iterated over, and <code>value</code> is\n<code>null</code>â€”except in the case of <code>Batman.Hash</code> where <code>element</code> is the key and\n<code>value</code> is the value.</p>\n"

---

{{ page.html }}
{% for s in page.sub %}
  <h3>
    <a id="{{ s.id }}" class="anchor-target"></a>
    <a href="#{{ s.id }}" class="anchor-link">
    <span class="{% if s.meta %}monospace-heading{% endif %}">
      {% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}<span class="params">({{ s.meta.params }})</span>{% endif %}
    {% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}
    </span>
    </a>
  </h3>
  {{ s.html }}
{% endfor %}
