---
layout: api_docs
title: Batman.Set
sub: 
  - title: constructor(items...)
    tokens: []
    id: 4_0_constructor(items...)
    html: "<p>When creating a <code>Set</code>, items forming the initial set can be passed as separate arguments to the constructor</p>\n<pre><code>test <span class=\"attribute\">'new</span> Set constructor can be called without arguments', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set\n  deepEqual set.toArray(), []\n\ntest <span class=\"attribute\">'new</span> Set constructor can be passed items <span class=\"keyword\">to</span> add <span class=\"keyword\">to</span> the set.', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>')\n  deepEqual set.toArray().sort(), [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>']</code></pre>\n"
  - title: "length : number"
    tokens: []
    id: "4_1_length_%3A_number"
    html: "<p>A count of the items in a <code>Set</code> can be found at its <code>length</code> property.</p>\n"
  - title: "isEmpty : boolean"
    tokens: []
    id: "4_2_isEmpty_%3A_boolean"
    html: "<p>Observable property for <code>isEmpty()</code></p>\n"
  - title: "toArray : Array"
    tokens: []
    id: "4_3_toArray_%3A_Array"
    html: "<p>Observable property for <code>toArray()</code>. Whenever items are added or removed on the set, the <code>toArray</code> property will change. This is the mechanism by which Batman&#39;s view bindings get notified of collection updates.</p>\n<pre><code>test <span class=\"attribute\">'observers</span> <span class=\"keyword\">on</span> the toArray <span class=\"keyword\">property</span> fire <span class=\"keyword\">when</span> the set changes', -&gt;\n  results = <span class=\"keyword\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>')\n  set.observe(<span class=\"attribute\">'toArray</span>', (newArray) -&gt; results = newArray.sort())\n  deepEqual set.add(<span class=\"attribute\">'d</span>'), [<span class=\"attribute\">'d</span>']\n  deepEqual results, [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>', <span class=\"attribute\">'d</span>']\n  deepEqual set.remove(<span class=\"attribute\">'b</span>'), [<span class=\"attribute\">'b</span>']\n  deepEqual results, [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'c</span>', <span class=\"attribute\">'d</span>']</code></pre>\n"
  - title: "has(item) : Boolean"
    tokens: []
    id: "4_4_has(item)_%3A_Boolean"
    html: "<p><code>has</code> returns a boolean describing if the given <code>item</code> is a member of the set.</p>\n<p><em>Note</em>: Using <code>has(item)</code> in an accessor body will register the set <code>has</code> is called upon as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated, because the set may now have or not have the item in question.</p>\n<pre><code>test <span class=\"string\">'Set::has indicates if an item is a member of the set or not.'</span>, -&gt;\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  ok <span class=\"keyword\">set</span>.has(<span class=\"string\">'a'</span>)\n  equal <span class=\"keyword\">set</span>.has(<span class=\"string\">'d'</span>), <span class=\"literal\">false</span>\n\ntest <span class=\"string\">'Set::has registers the set as a source of an accessor'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Team</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    <span class=\"title\">constructor</span>: -&gt;\n      @<span class=\"title\">awards</span> = <span class=\"title\">new</span> <span class=\"title\">Batman</span>.<span class=\"title\">Set</span>()\n\n    @<span class=\"title\">accessor</span> '<span class=\"title\">bestEver</span>?', -&gt; @<span class=\"title\">get</span>('<span class=\"title\">awards</span>').<span class=\"title\">has</span>('<span class=\"title\">Stanley</span> <span class=\"title\">Cup</span>')\n\n  <span class=\"title\">result</span> = <span class=\"title\">null</span>\n  <span class=\"title\">team</span> = <span class=\"title\">new</span> <span class=\"title\">Team</span>\n  <span class=\"title\">team</span>.<span class=\"title\">observeAndFire</span> '<span class=\"title\">bestEver</span>?', (<span class=\"title\">status</span>) -&gt; <span class=\"title\">result</span> = <span class=\"title\">status</span>\n  <span class=\"title\">team</span>.<span class=\"title\">get</span>('<span class=\"title\">awards</span>').<span class=\"title\">add</span> '<span class=\"title\">Eastern</span> <span class=\"title\">Conference</span> <span class=\"title\">Champs</span>'\n  <span class=\"title\">equal</span> <span class=\"title\">result</span>, <span class=\"title\">false</span>\n  <span class=\"title\">team</span>.<span class=\"title\">get</span>('<span class=\"title\">awards</span>').<span class=\"title\">add</span> '<span class=\"title\">Stanley</span> <span class=\"title\">Cup</span>'\n  <span class=\"title\">equal</span> <span class=\"title\">result</span>, <span class=\"title\">true</span></code></pre>\n"
  - title: add(items...)
    tokens: []
    id: 4_5_add(items...)
    html: "<p><code>add</code> adds 0 or more new items to the set. <code>add</code> returns an array of the items which have been newly added to the set, which is to say the intersection of the argument items and the set&#39;s complement before addition.</p>\n<p><code>add</code> fires the <code>itemsWereAdded</code> event with the list of items newly added to the set if that list has length greater than 0. This is to say the event will not be fired if the items passed to add were all already members of the set.</p>\n<pre><code>test <span class=\"attribute\">'Set</span>::add adds an item <span class=\"keyword\">to</span> the set', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set()\n  equal set.has(<span class=\"attribute\">'a</span>'), false\n  deepEqual set.add(<span class=\"attribute\">'a</span>'), [<span class=\"attribute\">'a</span>']\n  equal set.has(<span class=\"attribute\">'a</span>'), true\n\ntest <span class=\"attribute\">'Set</span>::add returns only the <span class=\"keyword\">new</span> items that weren\\<span class=\"attribute\">'t</span> previously <span class=\"keyword\">in</span> the set', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>')\n  deepEqual set.add(<span class=\"attribute\">'b</span>',<span class=\"attribute\">'c</span>',<span class=\"attribute\">'d</span>').sort(), [<span class=\"attribute\">'c</span>', <span class=\"attribute\">'d</span>']\n  deepEqual set.toArray().sort(), [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>', <span class=\"attribute\">'d</span>']\n\ntest <span class=\"attribute\">'Set</span>::add fires the itemsWereAdded event <span class=\"keyword\">with</span> the items newly added <span class=\"keyword\">to</span> the set', -&gt;\n  results = <span class=\"keyword\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>')\n  set.<span class=\"keyword\">on</span>(<span class=\"attribute\">'itemsWereAdded</span>', (item) -&gt; results = item)\n  set.add(<span class=\"attribute\">'b</span>',<span class=\"attribute\">'c</span>',<span class=\"attribute\">'d</span>')\n  deepEqual results.sort(), [<span class=\"attribute\">'c</span>',<span class=\"attribute\">'d</span>']\n\ntest <span class=\"attribute\">'Set</span>::add does <span class=\"keyword\">not</span> fire the itemsWereAdded event <span class=\"keyword\">if</span> the added items were already <span class=\"keyword\">in</span> the set.', -&gt;\n  results = undefined\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>')\n  set.<span class=\"keyword\">on</span>(<span class=\"attribute\">'itemsWereAdded</span>', (items) -&gt; results = items)\n  set.add(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>')\n  equal typeof results, <span class=\"attribute\">'undefined</span>'</code></pre>\n"
  - title: remove(items...)
    tokens: []
    id: 4_6_remove(items...)
    html: "<p><code>remove</code> removes 0 or more items from the set. <code>remove</code> returns an array of the items which were successfully removed from the set, which is to say the intersection of the argument items and the set itself before removal.</p>\n<p><code>remove</code> fires the <code>itemsWereRemoved</code> event with the list of removed items if that list has length greater than 0. This is to say the event will not be fired if none of the passed items were members of the set.</p>\n<pre><code>test <span class=\"attribute\">'Set</span>::remove removes an item from the set', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>')\n  equal set.has(<span class=\"attribute\">'a</span>'), true\n  deepEqual set.remove(<span class=\"attribute\">'a</span>'), [<span class=\"attribute\">'a</span>']\n  equal set.has(<span class=\"attribute\">'a</span>'), false\n\ntest <span class=\"attribute\">'Set</span>::remove returns only the <span class=\"keyword\">new</span> items that were previously <span class=\"keyword\">in</span> the set', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>')\n  deepEqual set.remove(<span class=\"attribute\">'b</span>',<span class=\"attribute\">'c</span>',<span class=\"attribute\">'d</span>').sort(), [<span class=\"attribute\">'b</span>']\n  deepEqual set.toArray(), [<span class=\"attribute\">'a</span>']\n\ntest <span class=\"attribute\">'Set</span>::remove fires the itemsWereRemoved event <span class=\"keyword\">with</span> the items removed <span class=\"keyword\">to</span> the set', -&gt;\n  results = <span class=\"keyword\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>')\n  set.<span class=\"keyword\">on</span>(<span class=\"attribute\">'itemsWereRemoved</span>', (items) -&gt; results = items)\n  set.remove(<span class=\"attribute\">'b</span>',<span class=\"attribute\">'c</span>')\n  deepEqual results.sort(), [<span class=\"attribute\">'b</span>',<span class=\"attribute\">'c</span>']\n\ntest <span class=\"attribute\">'Set</span>::remove does <span class=\"keyword\">not</span> fire the itemsWereRemoved event <span class=\"keyword\">if</span> the removed items were <span class=\"keyword\">not</span> already members <span class=\"keyword\">of</span> the set.', -&gt;\n  results = undefined\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>')\n  set.<span class=\"keyword\">on</span>(<span class=\"attribute\">'itemsWereRemoved</span>', (items) -&gt; results = items)\n  set.remove(<span class=\"attribute\">'c</span>', <span class=\"attribute\">'d</span>')\n  equal typeof results, <span class=\"attribute\">'undefined</span>'</code></pre>\n"
  - title: "find(testFunction : function) : [Object]"
    tokens: []
    id: "4_7_find(testFunction_%3A_function)_%3A_%5BObject%5D"
    html: "<p><code>find</code> returns the first item within the set for which the <code>testFunction</code> called with the item returns <code>true</code>, or <code>undefined</code> if no item passes the test.</p>\n<p><em>Note</em>: <code>find</code> returns the first item the test passes for, but since set iteration has no specified order, no guarantee can be made about which item will be returned if more than one item in the set passes the test. However, set iteration order is stable, so <code>find</code> called on the same set twice should return the same item.</p>\n<pre><code>test 'Set::find returns <span class=\"keyword\">the</span> <span class=\"keyword\">first</span> <span class=\"property\">item</span> <span class=\"keyword\">for</span> which <span class=\"keyword\">the</span> test function passes', -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  <span class=\"keyword\">equal</span> <span class=\"keyword\">set</span>.find((x) -&gt; x % <span class=\"number\">2</span> == <span class=\"number\">0</span>), <span class=\"number\">2</span>\n\ntest 'Set::find returns undefined <span class=\"keyword\">if</span> no items pass <span class=\"keyword\">the</span> test function', -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  <span class=\"keyword\">equal</span> typeof <span class=\"keyword\">set</span>.find((x) -&gt; x &gt; <span class=\"number\">5</span>), 'undefined'</code></pre>\n"
  - title: "forEach(iteratorFunction : function[, context: Object])"
    tokens: []
    id: "4_8_forEach(iteratorFunction_%3A_function%5B%2C_context%3A_Object%5D)"
    html: "<p><code>forEach</code> calls the <code>iteratorFunction</code> with each item in the set, optionally executing the <code>iteratorFunction</code> in the passed context. Returns <code>undefined</code>.</p>\n<p><em>Note</em>: Set iteration order is not defined, thus Set client code cannot rely on one item being iterated over before another, regardless of when the Set&#39;s items were added. If you need an ordered set, Batman provides <code>SetSort</code> for exactly this, while including the added benefit of observability. If you need a one time ordering of a set, you can get the array representation with <code>toArray</code> and then use vanilla JavaScript <code>sort</code> on that array.</p>\n<p><em>Note</em>: Using <code>forEach()</code> in an accessor body will register the set iterated over as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated. This can become an issue if you iterate over a set and modify the set&#39;s items, as when the property recalculates that modification will potentially happen on items it&#39;s happened on previously.</p>\n<pre><code>test <span class=\"string\">'Set::forEach iterates over each item in the set'</span>, -&gt;\n  sum = <span class=\"number\">0</span>\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)\n  <span class=\"keyword\">set</span>.forEach (x) -&gt; sum += x\n  equal sum, <span class=\"number\">6</span>\n\ntest <span class=\"string\">'Set::forEach iterates over each item in the set optionally in the provided context'</span>, -&gt;\n  context = {sum: <span class=\"number\">0</span>}\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)\n  <span class=\"keyword\">set</span>.forEach((x) -&gt;\n    @sum += x\n  , context)\n  equal context.sum, <span class=\"number\">6</span>\n\ntest <span class=\"string\">'Set::forEach registers the set as a source if called in an accessor body'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Team</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    <span class=\"title\">constructor</span>: -&gt;\n      @<span class=\"title\">players</span> = <span class=\"title\">new</span> <span class=\"title\">Batman</span>.<span class=\"title\">Set</span>()\n    @<span class=\"title\">accessor</span> '<span class=\"title\">willWinTheCup</span>?', -&gt;\n      <span class=\"title\">sedinCount</span> = 0\n      @<span class=\"title\">players</span>.<span class=\"title\">forEach</span> (<span class=\"title\">player</span>) -&gt;\n        <span class=\"title\">sedinCount</span>++ <span class=\"title\">if</span> <span class=\"title\">player</span>.<span class=\"title\">split</span>(' ')[1] == '<span class=\"title\">Sedin</span>'\n      <span class=\"title\">sedinCount</span> &gt;= 2\n\n  <span class=\"title\">result</span> = <span class=\"title\">null</span>\n  <span class=\"title\">team</span> = <span class=\"title\">new</span> <span class=\"title\">Team</span>()\n  <span class=\"title\">team</span>.<span class=\"title\">observeAndFire</span> '<span class=\"title\">willWinTheCup</span>?', (<span class=\"title\">status</span>) -&gt; <span class=\"title\">result</span> = <span class=\"title\">status</span>\n  <span class=\"title\">equal</span> <span class=\"title\">team</span>.<span class=\"title\">get</span>('<span class=\"title\">willWinTheCup</span>?'), <span class=\"title\">false</span>\n  <span class=\"title\">team</span>.<span class=\"title\">get</span>('<span class=\"title\">players</span>').<span class=\"title\">add</span> '<span class=\"title\">Henrik</span> <span class=\"title\">Sedin</span>'\n  <span class=\"title\">equal</span> <span class=\"title\">result</span>, <span class=\"title\">false</span>\n  <span class=\"title\">team</span>.<span class=\"title\">get</span>('<span class=\"title\">players</span>').<span class=\"title\">add</span> '<span class=\"title\">Daniel</span> <span class=\"title\">Sedin</span>'\n  <span class=\"title\">equal</span> <span class=\"title\">result</span>, <span class=\"title\">true</span></code></pre>\n"
  - title: "isEmpty() : boolean"
    tokens: []
    id: "4_9_isEmpty()_%3A_boolean"
    html: "<p><code>isEmpty</code> returns a boolean: <code>true</code> if the set has no items, and <code>false</code> if it has any items.</p>\n<p><em>Note</em>: Using <code>isEmpty()</code> in an accessor body will register the set <code>isEmpty</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.</p>\n<pre><code>test <span class=\"string\">'Set::isEmpty returns true if the set has no items'</span>, -&gt;\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.Set()\n  ok <span class=\"keyword\">set</span>.isEmpty()\n  <span class=\"keyword\">set</span>.add(<span class=\"string\">'a'</span>)\n  equal <span class=\"keyword\">set</span>.isEmpty(), <span class=\"literal\">false</span>\n\ntest <span class=\"string\">'Set::isEmpty registers the set as a source of an accessor'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Team</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    <span class=\"title\">constructor</span>: -&gt;\n      @<span class=\"title\">games</span> = <span class=\"title\">new</span> <span class=\"title\">Batman</span>.<span class=\"title\">Set</span>()\n    @<span class=\"title\">accessor</span> '<span class=\"title\">seasonStarted</span>?', -&gt; !@<span class=\"title\">games</span>.<span class=\"title\">isEmpty</span>()\n\n  <span class=\"title\">team</span> = <span class=\"title\">new</span> <span class=\"title\">Team</span>\n  <span class=\"title\">equal</span> <span class=\"title\">team</span>.<span class=\"title\">get</span>('<span class=\"title\">seasonStarted</span>?'), <span class=\"title\">false</span>\n  <span class=\"title\">team</span>.<span class=\"title\">get</span>('<span class=\"title\">games</span>').<span class=\"title\">add</span>({</span>win: <span class=\"literal\">true</span>})\n  equal team.<span class=\"keyword\">get</span>(<span class=\"string\">'seasonStarted?'</span>), <span class=\"literal\">true</span></code></pre>\n"
  - title: "clear() : Array"
    tokens: []
    id: "4_10_clear()_%3A_Array"
    html: "<p><code>clear</code> removes all items from a set. Returns an array of all the items in the set.</p>\n<p><code>clear</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set.</p>\n<p><em>Note</em>: Set iteration order is not defined, so the order of the array of items returned by <code>clear</code> is undefined.</p>\n<pre><code>test <span class=\"comment\">'Set::clear empties the set', -&gt;</span>\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.<span class=\"keyword\">Set</span>(<span class=\"comment\">'a', 'b', 'c')</span>\n  equal <span class=\"keyword\">set</span>.<span class=\"built_in\">isEmpty</span>(), <span class=\"literal\">false</span>\n  deepEqual <span class=\"keyword\">set</span>.clear().sort(), [<span class=\"comment\">'a', 'b', 'c']</span>\n  ok <span class=\"keyword\">set</span>.<span class=\"built_in\">isEmpty</span>()\n\ntest <span class=\"comment\">'Set::clear fires the itemsWereRemoved event with all the items in the set', -&gt;</span>\n  result = <span class=\"literal\">null</span>\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.<span class=\"keyword\">Set</span>(<span class=\"comment\">'a', 'b', 'c')</span>\n  <span class=\"keyword\">set</span>.<span class=\"keyword\">on</span>(<span class=\"comment\">'itemsWereRemoved', (items) -&gt; result = items)</span>\n  <span class=\"keyword\">set</span>.clear()\n  deepEqual result.sort(), [<span class=\"comment\">'a', 'b', 'c']</span></code></pre>\n"
  - title: "replace(collection : Enumerable) : Array"
    tokens: []
    id: "4_11_replace(collection_%3A_Enumerable)_%3A_Array"
    html: "<p><code>replace</code> removes all the items in a set and then adds all the items found in another <code>collection</code>. The other collection must have a <code>toArray</code> function which returns an array representation of the collection. Returns the array of items added.</p>\n<p><code>replace</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set, and then the <code>itemsWereAdded</code> event once with the items from the incoming collection.</p>\n<pre><code>test <span class=\"attribute\">'Set</span>::replace empties the set <span class=\"keyword\">and</span> <span class=\"keyword\">then</span> adds items from a different collection', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>')\n  secondSet = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'d</span>', <span class=\"attribute\">'e</span>', <span class=\"attribute\">'f</span>')\n  set.replace(secondSet)\n  deepEqual set.toArray().sort(), [<span class=\"attribute\">'d</span>', <span class=\"attribute\">'e</span>', <span class=\"attribute\">'f</span>']\n\ntest <span class=\"attribute\">'Set</span>::replace fires the itemsWereRemoved event <span class=\"keyword\">with</span> <span class=\"keyword\">all</span> the items <span class=\"keyword\">in</span> the set', -&gt;\n  result = <span class=\"keyword\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>')\n  set.<span class=\"keyword\">on</span>(<span class=\"attribute\">'itemsWereRemoved</span>', (items) -&gt; result = items)\n  set.replace(<span class=\"keyword\">new</span> Batman.SimpleSet())\n  deepEqual result.sort(), [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>']\n\ntest <span class=\"attribute\">'Set</span>::replace fires the itemsWereAdded event <span class=\"keyword\">with</span> <span class=\"keyword\">all</span> the items <span class=\"keyword\">in</span> the incoming set', -&gt;\n  result = <span class=\"keyword\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set()\n  set.<span class=\"keyword\">on</span>(<span class=\"attribute\">'itemsWereAdded</span>', (items) -&gt; result = items)\n  set.replace(<span class=\"keyword\">new</span> Batman.SimpleSet(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>'))\n  deepEqual result.sort(), [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>']</code></pre>\n"
  - title: "toArray() : Array"
    tokens: []
    id: "4_12_toArray()_%3A_Array"
    html: "<p><code>toArray</code> returns an array representation of the set.</p>\n<p><em>Note</em>: Set iteration order is not defined, so the order in which the set&#39;s items appear in the array is not defined. It is however stable, so the order of the items in two successive <code>toArray</code> calls where the set was not modified in between should be the same.</p>\n<p><em>Note</em>: <code>toArray</code> is also an observable property.</p>\n<p><em>Note</em>: Using <code>toArray()</code> in an accessor body will register the set <code>toArray</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.</p>\n<pre><code>test <span class=\"attribute\">'Set</span>::toArray returns an <span class=\"keyword\">array</span> representation <span class=\"keyword\">of</span> the set', -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set()\n  deepEqual set.toArray(), []\n  set.add(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>')\n  deepEqual set.toArray().sort(), [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>']</code></pre>\n"
  - title: "merge(collections... : Enumerable) : Set"
    tokens: []
    id: "4_13_merge(collections..._%3A_Enumerable)_%3A_Set"
    html: "<p><code>merge</code> adds all the items in a set and all the items in the passed <code>collections</code> to a new set and returns it. A <code>collection</code> is an object which has a <code>forEach</code> function. <code>merge</code> is a non-destructive collection union, so the set <code>merge</code> is called on and each <code>collection</code> passed to <code>merge</code> are unaffected by the call.</p>\n<p><em>Note</em>: Be careful about using <code>merge</code> within accessors. Calling <code>merge</code> in an accessor function body will register the set <code>merge</code> is called upon as a source of the property being calculated, which means when the set changes, that accessor will be recalculated. This means the O(n * m) merge will occur again each time, and return an entirely new <code>Set</code> instance. If the previously returned <code>Set</code> instance is retained after recalculation, this is a big memory leak. Instead of merging in accessors, try to use a <code>SetUnion</code> or a <code>SetIntersection</code>.</p>\n<pre><code>test <span class=\"attribute\">'Set</span>::merge returns a <span class=\"keyword\">new</span> set <span class=\"keyword\">with</span> the items <span class=\"keyword\">of</span> the original set <span class=\"keyword\">and</span> the passed set', -&gt;\n  abc = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>')\n  def = <span class=\"keyword\">new</span> Batman.Set(<span class=\"attribute\">'d</span>', <span class=\"attribute\">'e</span>', <span class=\"attribute\">'f</span>')\n  equal Batman.typeOf(set = abc.merge(def)), <span class=\"attribute\">'Object</span>'\n  deepEqual set.toArray().sort(), [<span class=\"attribute\">'a</span>', <span class=\"attribute\">'b</span>', <span class=\"attribute\">'c</span>', <span class=\"attribute\">'d</span>', <span class=\"attribute\">'e</span>', <span class=\"attribute\">'f</span>']</code></pre>\n"
  - title: "indexedBy(key : String) : SetIndex"
    tokens: []
    id: "4_14_indexedBy(key_%3A_String)_%3A_SetIndex"
    html: "<p><code>indexedBy</code> returns a hash of sets which buckets all the items in the callee set by the value of a particular <code>key</code>. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to a set of the items with that value at the <code>key</code> is built. This hash of sets is a smart object called a <code>SetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the set index remains up to date. <code>SetIndex</code> also has a friend named <code>UniqueSetIndex</code> which will give you a hash of items instead of a hash of sets with items for easy access if you know each item&#39;s value at the <code>key</code> is unique.</p>\n<pre><code>test 'Set::indexedBy returns a new SetIndex <span class=\"keyword\">with</span> <span class=\"keyword\">the</span> items bucketed <span class=\"keyword\">by</span> <span class=\"keyword\">the</span> value <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> key', -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(Batman(colour: 'blue'), Batman(colour: 'green'), Batman(colour: 'blue'))\n  index = <span class=\"keyword\">set</span>.indexedBy('colour')\n  ok index.<span class=\"keyword\">get</span>('blue') instanceof Batman.Set\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">2</span>\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('green').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">1</span>\n\ntest 'Set::indexedBy returns a new SetIndex which observes <span class=\"keyword\">the</span> <span class=\"keyword\">set</span> <span class=\"keyword\">for</span> new additions <span class=\"keyword\">and</span> stays up <span class=\"keyword\">to</span> <span class=\"type\">date</span>', -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(Batman(colour: 'blue'), Batman(colour: 'green'))\n  index = <span class=\"keyword\">set</span>.indexedBy('colour')\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">1</span>\n  newItem = Batman(colour: 'blue')\n  <span class=\"keyword\">set</span>.add(newItem)\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">2</span>\n  ok index.<span class=\"keyword\">get</span>('blue').has(newItem)\n  <span class=\"keyword\">set</span>.remove(newItem)\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">1</span>\n\ntest 'Set::indexedBy returns a new SetIndex which observes <span class=\"keyword\">the</span> items <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> <span class=\"keyword\">set</span> <span class=\"keyword\">for</span> changes <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> observed key', -&gt;\n  itemA = Batman(colour: 'blue')\n  itemB = Batman(colour: 'green')\n  <span class=\"keyword\">set</span> = new Batman.Set(itemA, itemB)\n  index = <span class=\"keyword\">set</span>.indexedBy('colour')\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">1</span>\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('green').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">1</span>\n  itemA.<span class=\"keyword\">set</span>('colour', 'green')\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">0</span>\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('green').<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">2</span></code></pre>\n<p><code>SetIndex</code>es can be created by calling the <code>indexedBy</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedBy</code> property.</p>\n<pre><code>test <span class=\"string\">\"Set::get('indexedBy.someKey') returns a new SetIndex for 'someKey'\"</span>, -&gt;\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.<span class=\"keyword\">Set</span>(Batman(colour: <span class=\"comment\">'blue'), Batman(colour: 'green'))</span>\n  index = <span class=\"keyword\">set</span>.<span class=\"keyword\">get</span>(<span class=\"comment\">'indexedBy.colour')</span>\n  equal index.<span class=\"keyword\">get</span>(<span class=\"comment\">'blue').get('length'), 1</span></code></pre>\n"
  - title: "indexedByUnique(key : String) : UniqueSetIndex"
    tokens: []
    id: "4_15_indexedByUnique(key_%3A_String)_%3A_UniqueSetIndex"
    html: "<p><code>indexedByUnique</code> returns a hash of items keyed by the value of the given <code>key</code> on each item from the callee set. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to an item with that value at the <code>key</code> is built. This hash of items is a smart object called a <code>UniqueSetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the index remains up to date. Note that the semantics for which item ends up in the hash if two items have the same value for the <code>key</code> are undefined, so it is wise to only use <code>UniqueSetIndex</code>es on keys who&#39;s values are going to be unique in the set. If the values are not going to be unique, you may be interested in <code>SetIndex</code> and <code>Set::indexedBy</code>.</p>\n<pre><code>test 'Set::indexedByUnique returns a new UniqueSetIndex <span class=\"keyword\">with</span> <span class=\"keyword\">the</span> items hashed <span class=\"keyword\">by</span> <span class=\"keyword\">the</span> value <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> key', -&gt;\n  greenItem = Batman(colour: 'green')\n  blueItem = Batman(colour: 'blue')\n  <span class=\"keyword\">set</span> = new Batman.Set(greenItem, blueItem)\n  index = <span class=\"keyword\">set</span>.indexedByUnique('colour')\n  ok blueItem == index.<span class=\"keyword\">get</span>('blue')\n  ok greenItem == index.<span class=\"keyword\">get</span>('green')\n  <span class=\"keyword\">equal</span> undefined, index.<span class=\"keyword\">get</span>('red')\n\ntest 'Set::indexedByUnique returns a new UniqueSetIndex which observes <span class=\"keyword\">the</span> <span class=\"keyword\">set</span> <span class=\"keyword\">for</span> new additions <span class=\"keyword\">and</span> stays up <span class=\"keyword\">to</span> <span class=\"type\">date</span>', -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(Batman(colour: 'blue'), Batman(colour: 'green'))\n  index = <span class=\"keyword\">set</span>.indexedByUnique('colour')\n  newItem = Batman(colour: 'red')\n  <span class=\"keyword\">set</span>.add(newItem)\n  ok newItem == index.<span class=\"keyword\">get</span>('red')\n  <span class=\"keyword\">set</span>.remove(newItem)\n  <span class=\"keyword\">equal</span> undefined, index.<span class=\"keyword\">get</span>('red')\n\ntest 'Set::indexedByUnique returns a new UniqueSetIndex which observes <span class=\"keyword\">the</span> items <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> <span class=\"keyword\">set</span> <span class=\"keyword\">for</span> changes <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> observed key', -&gt;\n  itemA = Batman(colour: 'blue')\n  itemB = Batman(colour: 'green')\n  <span class=\"keyword\">set</span> = new Batman.Set(itemA, itemB)\n  index = <span class=\"keyword\">set</span>.indexedByUnique('colour')\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue')?, <span class=\"constant\">true</span>\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('green')?, <span class=\"constant\">true</span>\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('red')?, <span class=\"constant\">false</span>\n  itemA.<span class=\"keyword\">set</span>('colour', 'red')\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('blue')?, <span class=\"constant\">false</span>\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('green')?, <span class=\"constant\">true</span>\n  <span class=\"keyword\">equal</span> index.<span class=\"keyword\">get</span>('red')?, <span class=\"constant\">true</span></code></pre>\n<p><code>UniqueSetIndex</code>es can be created by calling the <code>indexedByUnique</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedByUnique</code> property.</p>\n<pre><code>test <span class=\"string\">\"Set::get('indexedByUnique.someKey') returns a new UniqueSetIndex for 'someKey'\"</span>, -&gt;\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.<span class=\"keyword\">Set</span>(Batman(colour: <span class=\"comment\">'blue'), Batman(colour: 'green'))</span>\n  index = <span class=\"keyword\">set</span>.<span class=\"keyword\">get</span>(<span class=\"comment\">'indexedByUnique.colour')</span>\n  equal <span class=\"comment\">'blue', index.get('blue').get('colour')</span></code></pre>\n"
  - title: "sortedBy(key: String [, order: String]) : SetSort"
    tokens: []
    id: "4_16_sortedBy(key%3A_String_%5B%2C_order%3A_String%5D)_%3A_SetSort"
    html: "<p><code>sortedBy</code> returns a <code>Set</code> like object containing all the items of the callee set but with a defined iteration order (unlike <code>Set</code>). The iteration order is defined as the alpha numeric sorting of the values of the passed <code>key</code> gotten from each item. The direction of the sort can be controlled with the <code>order</code> argument, which defaults to <code>asc</code> (short for ascending) or can be passed as <code>desc</code> (short for descending). This <code>Set</code> like object is a <code>SetSort</code> which encapsulates the logic to get the values from each item at the passed <code>key</code> and traverse the <code>Set</code> in the values sorted order.</p>\n<p><code>SetSort</code>s are useful for getting a transform of a <code>Set</code> which sorted, but also because the sort stays up to date as items are added or removed to the sorted set, or the value at the <code>key</code> changes on any of the items in the set.</p>\n<pre><code>test 'Set::sortedBy returns a new SetSort who can be iterated <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> sorted order <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> value <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> key <span class=\"function_start\"><span class=\"keyword\">on</span> <span class=\"title\">each</span></span> <span class=\"property\">item</span>', -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(Batman(place: <span class=\"number\">3</span>, <span class=\"property\">name</span>: 'Harry'), Batman(place: <span class=\"number\">1</span>, <span class=\"property\">name</span>: 'Tom'), Batman(place: <span class=\"number\">2</span>, <span class=\"property\">name</span>: 'Camilo'))\n  sort = <span class=\"keyword\">set</span>.sortedBy('place')\n  deepEqual sort.toArray().map((<span class=\"property\">item</span>) -&gt; <span class=\"property\">item</span>.<span class=\"keyword\">get</span>('<span class=\"property\">name</span>')), ['Tom', 'Camilo', 'Harry']\n\ntest 'Set::sortedBy returns a new SetSort which observes <span class=\"keyword\">the</span> callee <span class=\"keyword\">set</span> <span class=\"keyword\">for</span> additions <span class=\"keyword\">or</span> removals <span class=\"keyword\">and</span> puts new items <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> sorted order', -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(Batman(place: <span class=\"number\">3</span>, <span class=\"property\">name</span>: 'Harry'), Batman(place: <span class=\"number\">1</span>, <span class=\"property\">name</span>: 'Tom'), Batman(place: <span class=\"number\">2</span>, <span class=\"property\">name</span>: 'Camilo'))\n  sort = <span class=\"keyword\">set</span>.sortedBy('place')\n  deepEqual sort.toArray().map((<span class=\"property\">item</span>) -&gt; <span class=\"property\">item</span>.<span class=\"keyword\">get</span>('<span class=\"property\">name</span>')), ['Tom', 'Camilo', 'Harry']\n  burke = Batman(place: <span class=\"number\">1.5</span>, <span class=\"property\">name</span>: 'Burke')\n  <span class=\"keyword\">set</span>.add(burke)\n  deepEqual sort.toArray().map((<span class=\"property\">item</span>) -&gt; <span class=\"property\">item</span>.<span class=\"keyword\">get</span>('<span class=\"property\">name</span>')), ['Tom', 'Burke', 'Camilo', 'Harry']\n\ntest 'Set::sortedBy returns a new SetSort which observes each <span class=\"property\">item</span> <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> callee <span class=\"keyword\">set</span> <span class=\"keyword\">for</span> changes <span class=\"keyword\">to</span> <span class=\"keyword\">the</span> sort key', -&gt;\n  harry = Batman(place: <span class=\"number\">2</span>, <span class=\"property\">name</span>: 'Harry')\n  tom = Batman(place: <span class=\"number\">1</span>, <span class=\"property\">name</span>: 'Tom')\n  <span class=\"keyword\">set</span> = new Batman.Set(harry, tom)\n  sort = <span class=\"keyword\">set</span>.sortedBy('place')\n  deepEqual sort.toArray().map((<span class=\"property\">item</span>) -&gt; <span class=\"property\">item</span>.<span class=\"keyword\">get</span>('<span class=\"property\">name</span>')), ['Tom', 'Harry']\n  tom.<span class=\"keyword\">set</span>('place', <span class=\"number\">3</span>)\n  deepEqual sort.toArray().map((<span class=\"property\">item</span>) -&gt; <span class=\"property\">item</span>.<span class=\"keyword\">get</span>('<span class=\"property\">name</span>')), ['Harry', 'Tom']</code></pre>\n<p><code>SetSort</code>s can be created by calling the <code>sortedBy</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>sortedBy</code> property. Note that with this instantiation form you can&#39;t pass an order to the <code>SetSort</code>.</p>\n<pre><code>test <span class=\"string\">\"Set::get('sortedBy.someKey') returns a new SetSort onn 'someKey'\"</span>, -&gt;\n  <span class=\"keyword\">set</span> = new Batman.Set(Batman(place: <span class=\"number\">3</span>, <span class=\"property\">name</span>: 'Harry'), Batman(place: <span class=\"number\">1</span>, <span class=\"property\">name</span>: 'Tom'), Batman(place: <span class=\"number\">2</span>, <span class=\"property\">name</span>: 'Camilo'))\n  sort = <span class=\"keyword\">set</span>.<span class=\"keyword\">get</span>('sortedBy.place')\n  <span class=\"keyword\">equal</span> 'Harry', sort.<span class=\"keyword\">get</span>('toArray')[<span class=\"number\">2</span>].<span class=\"keyword\">get</span>('<span class=\"property\">name</span>')</code></pre>\n"
tokens: []
id: 4_Batman.Set
html: "<p><code>Set</code> is an observable, <code>Batman.Object</code> wrapper around <code>SimpleSet</code>.</p>\n<h3>SimpleSet vs Set</h3>\n<p><code>SimpleSet</code> and <code>Set</code> are two distinct classes in Batman. <code>SimpleSet</code> implements the basic set semantics, but it is <em>not</em> a <code>Batman.Object</code>, so properties on it (like its <code>length</code> or <code>toArray</code>) cannot be bound. <code>Set</code> is a <code>Batman.Object</code>, so it can be observed, and thus plays nicely with the accessor system. Use a <code>SimpleSet</code> only when you know nothing will need to be observed on the set you are creating, which usually isn&#39;t a valid assumption. If it is in fact valid, consider using a native array as well, as iteration and membership checks will be faster.</p>\n"

---

{{ page.html }}
{% for s in page.sub %}
  <h3 id="{{ s.id }}">{{ s.title }}</h3>
  {{ s.html }}
{% endfor %}
