---
layout: api_docs
title: Batman.Observable
meta: 
  grouping: Data Structures
  parent: Batman.Object
sub: 
  - title: isObservable
    meta: 
      type: property
      level: prototype
      params: "[= true]"
      returnType: Boolean
    tokens: []
    id: prototype_property_isobservable
    html: "<p>Returns <code>true</code>. Shows that <code>Observable</code> was mixed into the object.</p>\n"
  - title: get
    meta: 
      type: function
      level: prototype
      params: "keypath: String"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    tokens: []
    id: prototype_function_get
    html: "<p>Retrieves the value at <code>keypath</code> on an object.</p>\n<pre><code>test <span class=\"string\">\"get retrieves properties on Batman.Objects\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object\n    length: <span class=\"number\">340</span>\n    artist: <span class=\"keyword\">new</span> Batman.Object\n      name: <span class=\"string\">\"Harry\"</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>, <span class=\"string\">\"but `get` works\"</span>\n  equal song.get(<span class=\"string\">\"artist.name\"</span>), <span class=\"string\">\"Harry\"</span>, <span class=\"string\">\"retrieves nested properties\"</span>\n\ntest <span class=\"string\">\"get retrieves properties o when . doesn't\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Model(length: <span class=\"number\">340</span>)\n  equal song.length, <span class=\"literal\">undefined</span>, <span class=\"string\">\"dot-notation doesn't work\"</span>\n  equal song.get(<span class=\"string\">'length'</span>), <span class=\"number\">340</span>, <span class=\"string\">\"get works\"</span></code></pre>\n<p><strong>Note:</strong> <code>get</code> must be used for retrieving properties from <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a>s. Under the hood, batman.js uses <code>get</code>, <code>set</code>, and <code>unset</code> for dependency calculation and data binding.</p>\n"
  - title: set
    meta: 
      type: function
      level: prototype
      params: "keypath: String, newValue"
      returnType: newValue
    tokens: []
    id: prototype_function_set
    html: "<p>Stores <code>newValue</code> at <code>keypath</code> on  the object.</p>\n<p><em>Note</em>: Custom setters can mutate the value during setting, so the value which was passed to <code>set</code> and <code>set</code>&#39;s return value are not guaranteed to be identical.</p>\n<pre><code>test <span class=\"string\">\"set stores properties on Batman.Objects\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object\n    length: <span class=\"number\">340</span>\n    artist: <span class=\"keyword\">new</span> Batman.Object\n      name: <span class=\"string\">\"Harry\"</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">1000</span>), <span class=\"number\">1000</span>, <span class=\"string\">\"`set` returns the value\"</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">1000</span>, <span class=\"string\">\"the new value is set on the object\"</span>\n  equal song.set(<span class=\"string\">\"artist.name\"</span>, <span class=\"string\">\"Nick\"</span>), <span class=\"string\">\"Nick\"</span>\n  equal song.get(<span class=\"string\">\"artist.name\"</span>), <span class=\"string\">\"Nick\"</span>, <span class=\"string\">\"The nested keypath returns the new value\"</span>\n  artist = song.get(<span class=\"string\">'artist'</span>)\n  equal artist.get(<span class=\"string\">\"name\"</span>), <span class=\"string\">\"Nick\"</span>, <span class=\"string\">\"Value was set on the nested object.\"</span></code></pre>\n<p><strong>Note:</strong> <code>set</code> must be used for updating properties on <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a>s. Under the hood, batman.js uses <code>get</code>, <code>set</code>, and <code>unset</code> for dependency calculation and data binding.</p>\n"
  - title: unset
    meta: 
      type: function
      level: prototype
      params: "keypath: String"
      returnType: value
    tokens: []
    id: prototype_function_unset
    html: "<p>Removes the value at <code>keypath</code>, leaving it <code>undefined</code>.</p>\n<p>Although the default <code>unset</code> implementation is roughly equivalent to <code>set(keypath, undefined)</code>, some accessors may reimplement <code>unset</code> for their own purposes. Always use <code>unset</code> to clear a property.</p>\n<pre><code>test <span class=\"string\">\"unset removes properties on Batman.Objects\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object\n    length: <span class=\"number\">340</span>\n    artist: <span class=\"keyword\">new</span> Batman.Object\n      name: <span class=\"string\">\"Harry\"</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n  equal song.unset(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>, <span class=\"string\">\"`unset` returns the value\"</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"literal\">undefined</span>, <span class=\"string\">\"the property is undefined\"</span>\n  equal song.unset(<span class=\"string\">\"artist.name\"</span>), <span class=\"string\">\"Harry\"</span>\n  equal song.get(<span class=\"string\">\"artist.name\"</span>), <span class=\"literal\">undefined</span>\n  artist = song.get(<span class=\"string\">'artist'</span>)\n  equal artist.get(<span class=\"string\">\"name\"</span>), <span class=\"literal\">undefined</span>, <span class=\"string\">\"Value was unset on the nested object.\"</span></code></pre>\n<p><strong>Note:</strong> <code>unset</code> must be used for clearing properties on <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a>s. Under the hood, batman.js uses <code>get</code>, <code>set</code>, and <code>unset</code> for dependency calculation and data binding.</p>\n"
  - title: getOrSet
    meta: 
      type: function
      level: prototype
      params: "keypath: String, valueFunction: Function"
      returnType: value
    tokens: []
    id: prototype_function_getorset
    html: "<p>If the value at <code>keypath</code> is falsey, calls <code>valueFunction</code> and sets returned value at <code>keypath</code>. Returns the value of the property after the operation, whether it has changed or not. Roughly equivalent to the <code>||=</code> operator.</p>\n<pre><code>test <span class=\"string\">\"getOrSet sets the property if it falsey\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.getOrSet(<span class=\"string\">\"length\"</span>, -&gt; <span class=\"number\">500</span>), <span class=\"number\">340</span>, <span class=\"string\">\"it returns an existing value at `keypath`\"</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>, <span class=\"string\">\"it doesn't override truthy values\"</span>\n  equal song.getOrSet(<span class=\"string\">\"artist\"</span>, -&gt; <span class=\"string\">\"Elvis\"</span>), <span class=\"string\">\"Elvis\"</span>, <span class=\"string\">\"returns a new value at keypath\"</span>\n  equal song.get(<span class=\"string\">\"artist\"</span>), <span class=\"string\">\"Elvis\"</span>, <span class=\"string\">\"it overrides falsey values\"</span></code></pre>\n"
  - title: observe
    meta: 
      type: function
      level: prototype
      params: "keypath: String, observerCallback: Function"
      returnType: Observable
    tokens: []
    id: prototype_function_observe
    html: "<p>Adds <code>observerCallback</code> as a handler to call when the value of <code>get(keypath)</code> changes.</p>\n<p><code>observerCallback</code> is invoked with <code>newValue, oldValue</code>, whenever the value at <code>keypath</code> changes.</p>\n<p>Returns the <code>Observable</code>.</p>\n<pre><code>test <span class=\"string\">\"observe attaches handlers which get called upon change\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object\n    length: <span class=\"number\">340</span>\n    artist: <span class=\"keyword\">new</span> Batman.Object\n      name: <span class=\"string\">\"Harry\"</span>\n  song.observe <span class=\"string\">\"length\"</span>, (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>], <span class=\"string\">\"observe tracks keypaths\"</span>\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">300</span>, <span class=\"number\">200</span>], <span class=\"string\">\"observe tracks keypaths continuously\"</span>\n  song.observe <span class=\"string\">\"artist.name\"</span>, (newName, oldName) -&gt;\n    result = [newName, oldName]\n  newArtist = <span class=\"keyword\">new</span> Batman.Object({name: <span class=\"string\">\"James\"</span>})\n  song.set <span class=\"string\">\"artist\"</span>, newArtist\n  deepEqual result, [<span class=\"string\">\"James\"</span>, <span class=\"string\">\"Harry\"</span>], <span class=\"string\">\"The observer fired when the 'artist' segment of the keypath changed.\"</span></code></pre>\n"
  - title: forget
    meta: 
      type: function
      level: prototype
      params: "[keypath: String[, observerCallback: Function]]"
      returnType: Observable
    tokens: []
    id: prototype_function_forget
    html: "<p>If <code>observerCallback</code> and <code>keypath</code> are given, <code>observerCallback</code> is removed from the observers on <code>keypath</code>. If only <code>keypath</code> is given, all observers on that key are removed. If no <code>keypath</code> is given, all observers on all keys are removed.</p>\n<p>Returns the <code>Observable</code>.</p>\n<pre><code>test <span class=\"string\">\"forget removes an observer from a key if the key and the observer are given\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"function\"><span class=\"title\">observer</span></span> = (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  song.observe <span class=\"string\">\"length\"</span>, observer\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>]\n  song.forget <span class=\"string\">\"length\"</span>, observer\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>], <span class=\"string\">\"The logged values haven't changed because the observer hasn't fired again.\"</span>\n\ntest <span class=\"string\">\"forget removes all observers from a key if only the key is given\"</span>, -&gt;\n  results = []\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"function\"><span class=\"title\">observerA</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  <span class=\"function\"><span class=\"title\">observerB</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  song.observe <span class=\"string\">\"length\"</span>, observerA\n  song.observe <span class=\"string\">\"length\"</span>, observerB\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  equal results.length, <span class=\"number\">2</span>, <span class=\"string\">\"Both length observers fired.\"</span>\n  song.forget(<span class=\"string\">\"length\"</span>)\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  equal results.length, <span class=\"number\">2</span>, <span class=\"string\">\"Nothing more has been added because neither observer fired.\"</span>\n\ntest <span class=\"string\">\"forget removes all observers from all keys if no key is given\"</span>, -&gt;\n  results = []\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"function\"><span class=\"title\">observerA</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  <span class=\"function\"><span class=\"title\">observerB</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  song.observe <span class=\"string\">\"length\"</span>, observerA\n  song.observe <span class=\"string\">\"bpm\"</span>, observerB\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"The length observer fired.\"</span>\n  song.forget()\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  equal song.set(<span class=\"string\">\"bpm\"</span>, <span class=\"number\">130</span>), <span class=\"number\">130</span>\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"Nothing more has been logged because neither observer fired.\"</span></code></pre>\n"
  - title: observeAndFire
    meta: 
      type: function
      level: prototype
      params: "keypath: String, observerCallback: Function"
      returnType: Observable
    tokens: []
    id: prototype_function_observeandfire
    html: "<p>Adds <code>observerCallback</code> as an observer to <code>keypath</code> and fires it immediately with the current value at <code>keypath</code>.</p>\n<p><em>Note</em>: During the initial synchronous firing of <code>observerCallback</code>, <code>newValue</code> and <code>oldValue</code> will be the same: the current value of the property. The old value was not cached and is therefore unavailable. If your observer needs the old value of the property, you must attach it before the <code>set</code> on the property happens.</p>\n<pre><code>test <span class=\"string\">\"observeAndFire calls the observer upon attaching it with the currentValue of the property\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  song.observeAndFire <span class=\"string\">\"length\"</span>, (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  deepEqual result, [<span class=\"number\">340</span>, <span class=\"number\">340</span>]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">300</span>, <span class=\"number\">340</span>]</code></pre>\n"
  - title: observeOnce
    meta: 
      type: function
      level: prototype
      params: "keypath: String, observerCallback: Function"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    tokens: []
    id: prototype_function_observeonce
    html: "<p>Like <code>Observable::observe</code>, except that after <code>observerCallback</code> has been called once, it will remove itself from the observers on <code>keypath</code>.</p>\n<pre><code>test <span class=\"string\">\"observeOnce only calls observerCallback when key is modified for the first time\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  song.observeOnce <span class=\"string\">\"length\"</span>, (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>], <span class=\"string\">\"The observer was not fired for the second update\"</span></code></pre>\n"
tokens: []
id: batman.observable
html: "<p><a href=\"/docs/api/batman.observable.html\"><code>Batman.Observable</code></a> is a mixin which gives objects the ability to notify subscribers to changes on its properties.</p>\n<p><a href=\"/docs/api/batman.observable.html\"><code>Batman.Observable</code></a> is mixed in to <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a> and <code>Batman.Object.prototype</code>, so all classes (contstructor, prototype and instance) that extend <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a> are also observable.</p>\n<pre><code class=\"lang-coffeescript\">gotham = <span class=\"keyword\">new</span> Batman.Object(isCrisis: <span class=\"literal\">false</span>)\n\n<span class=\"comment\"># set up an observer:</span>\ngotham.observe <span class=\"string\">\"isCrisis\"</span>, (newValue, oldValue) -&gt;\n  <span class=\"keyword\">if</span> newValue <span class=\"keyword\">is</span> <span class=\"literal\">true</span>\n    console.log(<span class=\"string\">\"Activate the Batsignal!\"</span>)\n  <span class=\"keyword\">if</span> newValue <span class=\"keyword\">is</span> <span class=\"literal\">false</span>\n    console.log(<span class=\"string\">\"All is well\"</span>)\n\ngotham.get(<span class=\"string\">'isCrisis'</span>)        <span class=\"comment\"># =&gt; false</span>\ngotham.set(<span class=\"string\">'isCrisis'</span>, <span class=\"literal\">true</span>)  <span class=\"comment\"># =&gt; true</span>\n<span class=\"comment\"># in the log: \"Activate the Batsignal!\"</span>\ngotham.set(<span class=\"string\">'isCrisis'</span>, <span class=\"literal\">false</span>) <span class=\"comment\"># =&gt; false</span>\n<span class=\"comment\"># in the log: \"All is well\"</span></code></pre>\n"

---

{{ page.html }}
<ul class="api-list">
{% for s in page.sub %}
  <li class="api-list-item">
    <h3 class="api-title">
      <a id="{{ s.id }}" class="anchor-target"></a>
      <a href="#{{ s.id }}" class="anchor-link">
      <span class="{% if s.meta %}monospace-heading{% endif %}">{% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}{% if s.meta.type == 'property' %}<span class="params">{{ s.meta.params }}</span>{% else %}<span class="params">({{ s.meta.params }})</span>  {% endif %}{% endif %}{% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}</span>
      </a>
    </h3>
    {{ s.html }}
  </li>
{% endfor %}
</ul>
