---
layout: api_docs
title: Batman.Object
sub: 
  - title: "@accessor([keys...], objectOrFunction)"
    tokens: []
    id: "4_0_%40accessor(%5Bkeys...%5D%2C_objectOrFunction)"
    html: "<p>Accessors are used to create properties on a class, prototype, or instance which can be fetched, set, and unset. These properties can be static, computed as functions of the other properties on the object the accessor belongs to, or properties of any Batman object in the system. <code>accessor</code> is a Batman and old browser friendly version of ES5 <code>Object.defineProperty</code>.</p>\n<p>The value of custom accessors can be observed just like any property. Accessors also track which other properties they rely on for computation, and recalculate eagerly when those other properties change. This way, when a source value is changed, any dependent accessors will automatically update any bindings to them with a new value. Accessors accomplish this feat by tracking <code>get</code> calls, so be sure to use <code>get</code> to retrieve properties on Batman Objects inside accessors so those properties can be tracked as dependencies. The property dependencies of an accessor are called &quot;sources&quot; in the Batman world.</p>\n<p>Importantly, accessors are also inherited, so accessors defined anywhere in an object&#39;s prototype chain will be used. Following this, <code>@accessor</code> is meant to be used during the class definition of a class extending <code>Batman.Object</code>.</p>\n<h4>Arguments</h4>\n<p><code>@accessor</code> can be called with zero, one, or many keys for the accessor to define. This has the following effects:</p>\n<ul>\n<li>zero: create a <code>defaultAccessor</code>, which will be called when no other properties or accessors on an object match a keypath. This is similar to <code>method_missing</code> in Ruby or <code>#doesNotUnderstand</code> in Smalltalk.</li>\n<li>one: create a <code>keyAccessor</code> at the given key, which will only be called when that key is gotten, set, or unset.</li>\n<li>many: create <code>keyAccessors</code> for each given key, which will then be called whenever each one of the listed keys is gotten, set, or unset.</li>\n</ul>\n<p><code>@accessor</code> accepts as the last argument either an object with any combination of the <code>get</code>, <code>set</code>, and <code>unset</code> keys defined, or a function. Functions which implement the behaviour for those particular actions on the property should reside at these keys. <code>@accessor</code> also accepts a function as the last argument, which is a shorthand for specifying the <code>get</code> implementation for the accessor.</p>\n<h4>Uses</h4>\n<p>Accessors are a really useful addition to the world of JavaScript. You can now define transforms on simple properties which will automatically update when the properties they transform change: for example, you might want to truncate a potentially long piece of text to display a summary elsewhere, or you might want to capitalize or <code>encodeURIComponent</code> a value before putting it in the view or the current URL.</p>\n<pre><code>test <span class=\"string\">'@accessor can be called on a class to define how a property is calculated'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">accessor</span> '<span class=\"title\">summary</span>', -&gt; @<span class=\"title\">get</span>('<span class=\"title\">body</span>').<span class=\"title\">slice</span>(0, 10) + \"...\"\n\n  <span class=\"title\">post</span> = <span class=\"title\">new</span> <span class=\"title\">Post</span>(<span class=\"title\">body</span>: \"<span class=\"title\">Why</span> <span class=\"title\">Batman</span> <span class=\"title\">is</span> <span class=\"title\">Useful</span>: <span class=\"title\">A</span> <span class=\"title\">lengthy</span> <span class=\"title\">post</span> <span class=\"title\">on</span> <span class=\"title\">an</span> <span class=\"title\">important</span> <span class=\"title\">subject</span>\")\n  <span class=\"title\">equal</span> <span class=\"title\">post</span>.<span class=\"title\">get</span>('<span class=\"title\">summary</span>'), \"<span class=\"title\">Why</span> <span class=\"title\">Batman</span>...\"</code></pre>\n<p>You can also use accessors to combine properties; the colloquial <code>fullName</code> example comes to mind, but all sorts of other complex logic can be abstracted away using the accessor pattern.</p>\n<pre><code>test <span class=\"string\">'@accessor can define a transform on several properties'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">accessor</span> '<span class=\"title\">fullName</span>', -&gt; @<span class=\"title\">get</span>('<span class=\"title\">firstName</span>') + \" \" + @<span class=\"title\">get</span>('<span class=\"title\">lastName</span>')\n\n  <span class=\"title\">tim</span> = <span class=\"title\">new</span> <span class=\"title\">User</span>(<span class=\"title\">firstName</span>: \"<span class=\"title\">Tim</span>\", <span class=\"title\">lastName</span>: \"<span class=\"title\">Thomas</span>\")\n  <span class=\"title\">equal</span> <span class=\"title\">tim</span>.<span class=\"title\">get</span>('<span class=\"title\">fullName</span>'), \"<span class=\"title\">Tim</span> <span class=\"title\">Thomas</span>\"\n  <span class=\"title\">tim</span>.<span class=\"title\">set</span>('<span class=\"title\">firstName</span>', \"<span class=\"title\">Timmy</span>\")\n  <span class=\"title\">equal</span> <span class=\"title\">tim</span>.<span class=\"title\">get</span>('<span class=\"title\">fullName</span>'), \"<span class=\"title\">Timmy</span> <span class=\"title\">Thomas</span>\"</code></pre>\n<p>Accessors can define custom <code>get</code>, <code>set</code>, and <code>unset</code> functions to support each operation on the property:</p>\n<pre><code>test <span class=\"string\">'@accessor can define the get, set, and unset methods for the property'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbsoluteNumber</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">accessor</span> '<span class=\"title\">value</span>',\n      <span class=\"title\">get</span>: -&gt; @<span class=\"title\">_value</span>\n      <span class=\"title\">set</span>: (<span class=\"title\">_</span>, <span class=\"title\">value</span>) -&gt; @<span class=\"title\">_value</span> = <span class=\"title\">Math</span>.<span class=\"title\">abs</span>(<span class=\"title\">value</span>)\n      <span class=\"title\">unset</span>: -&gt; <span class=\"title\">delete</span> @<span class=\"title\">_value</span>\n\n  <span class=\"title\">number</span> = <span class=\"title\">new</span> <span class=\"title\">AbsoluteNumber</span>(<span class=\"title\">value</span>: -10)\n  <span class=\"title\">equal</span> <span class=\"title\">number</span>.<span class=\"title\">get</span>('<span class=\"title\">value</span>'), 10</code></pre>\n<p>Importantly, it is also safe to use branching, loops, or whatever logic you want in accessor bodies:</p>\n<pre><code>test <span class=\"string\">'@accessor can use arbitrary logic to define the value'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">accessor</span> '<span class=\"title\">score</span>', -&gt;\n      <span class=\"title\">if</span> @<span class=\"title\">get</span>('<span class=\"title\">played</span>')\n        (@<span class=\"title\">get</span>('<span class=\"title\">goals</span>') * 2) + (@<span class=\"title\">get</span>('<span class=\"title\">assists</span>') * 1)\n      <span class=\"title\">else</span>\n        0\n\n  <span class=\"title\">rick</span> = <span class=\"title\">new</span> <span class=\"title\">Player</span>(<span class=\"title\">played</span>: <span class=\"title\">false</span>, <span class=\"title\">goals</span>: 0, <span class=\"title\">assists</span>: 0)\n  <span class=\"title\">equal</span> <span class=\"title\">rick</span>.<span class=\"title\">get</span>('<span class=\"title\">score</span>'), 0\n  <span class=\"title\">rick</span>.<span class=\"title\">set</span>('<span class=\"title\">played</span>', <span class=\"title\">true</span>)\n  <span class=\"title\">equal</span> <span class=\"title\">rick</span>.<span class=\"title\">get</span>('<span class=\"title\">score</span>'), 0\n  <span class=\"title\">rick</span>.<span class=\"title\">set</span>('<span class=\"title\">goals</span>', 3)\n  <span class=\"title\">equal</span> <span class=\"title\">rick</span>.<span class=\"title\">get</span>('<span class=\"title\">score</span>'), 6\n  <span class=\"title\">rick</span>.<span class=\"title\">set</span>('<span class=\"title\">assists</span>', 1)\n  <span class=\"title\">equal</span> <span class=\"title\">rick</span>.<span class=\"title\">get</span>('<span class=\"title\">score</span>'), 7</code></pre>\n<h4>Caveats</h4>\n<p>Accessors are extremely useful, but keep these items in mind when using them:</p>\n<ol>\n<li>Accessors should be pure functions so they are predictable and can be cached.</li>\n</ol>\n<p>Batman automatically memoizes the return value of accessors, and will not re-execute the body until one of the accessor&#39;s sources changes. If you need the accessor to recalculate every time the property is gotten, pass <code>false</code> for the <code>cache</code> option in the accessor descriptor object (the last argument to the <code>@accessor</code> function).</p>\n<pre><code>test <span class=\"string\">\"@accessor usually caches results\"</span>, -&gt;\n  counter = <span class=\"number\">0</span>\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">accessor</span> '<span class=\"title\">cachedCounter</span>', -&gt; ++<span class=\"title\">counter</span>\n    @<span class=\"title\">accessor</span> '<span class=\"title\">notCachedCounter</span>',\n      <span class=\"title\">get</span>: -&gt; ++<span class=\"title\">counter</span>\n      <span class=\"title\">cache</span>: <span class=\"title\">false</span>\n\n  <span class=\"title\">example</span> = <span class=\"title\">new</span> <span class=\"title\">Example</span>()\n  <span class=\"title\">equal</span> <span class=\"title\">example</span>.<span class=\"title\">get</span>('<span class=\"title\">cachedCounter</span>'), 1\n  <span class=\"title\">equal</span> <span class=\"title\">example</span>.<span class=\"title\">get</span>('<span class=\"title\">cachedCounter</span>'), 1\n  <span class=\"title\">equal</span> <span class=\"title\">example</span>.<span class=\"title\">get</span>('<span class=\"title\">cachedCounter</span>'), 1, \"<span class=\"title\">The</span> <span class=\"title\">second</span> <span class=\"title\">and</span> <span class=\"title\">third</span> <span class=\"title\">calls</span> <span class=\"title\">do</span> <span class=\"title\">not</span> <span class=\"title\">execute</span> <span class=\"title\">the</span> <span class=\"title\">function</span>\"\n  <span class=\"title\">equal</span> <span class=\"title\">example</span>.<span class=\"title\">get</span>('<span class=\"title\">notCachedCounter</span>'), 2\n  <span class=\"title\">equal</span> <span class=\"title\">example</span>.<span class=\"title\">get</span>('<span class=\"title\">notCachedCounter</span>'), 3, \"<span class=\"title\">Passing</span> <span class=\"title\">cache</span>: <span class=\"title\">false</span> <span class=\"title\">does</span> <span class=\"title\">re</span>-<span class=\"title\">execute</span> <span class=\"title\">the</span> <span class=\"title\">function</span>\"\n  <span class=\"title\">equal</span> <span class=\"title\">example</span>.<span class=\"title\">get</span>('<span class=\"title\">cachedCounter</span>'), 1</code></pre>\n<ol>\n<li>Accessors <em>must</em> use <code>get</code> to access properties they use for computation</li>\n</ol>\n<p>Batman tracks an accessor&#39;s sources by adding a global hook to all <code>get</code>s done, so if you don&#39;t use <code>get</code> to access properties on objects, Batman can&#39;t know that that property is a source of the property your accessor defines, so it can&#39;t recompute that property when the source property changes. All properties on <code>Batman.Object</code> should be accessed using <code>get</code> and <code>set</code> whether or not the code occurs in an accessor body, but it is critical to do so in accessors so the sources of the accessor can be tracked.</p>\n<ol>\n<li>Accessors can create memory leaks or performance bottlenecks</li>\n</ol>\n<p>If you return a brand new object, say by merging a number of <code>Batman.Set</code>s or doing any sort of major and complete re-computation, you run the risk of creating performance problems. This is because accessors can be called frequently and unpredictably, as they are recomputed every time one of their sources changes and for every call to <code>set</code>. Instead of recomputing expensive things every time the accessor is called, try to use objects which do smart re-computation using observers. Practically, this translates to using things like <code>new SetUnion(@get(&#39;setA&#39;), @get(&#39;setB&#39;))</code> instead of <code>@get(&#39;setA&#39;).merge(@get(&#39;setB&#39;))</code> in an accessor body, since <code>SetUnion</code> will observe its constituents and update itself when they change, instead of the <code>merge</code> resulting in the accessor recomputing every time <code>setA</code> or <code>setB</code> changed.</p>\n"
  - title: "@classAccessor([keys...], objectOrFunction)"
    tokens: []
    id: "4_1_%40classAccessor(%5Bkeys...%5D%2C_objectOrFunction)"
    html: "<p><code>classAccessor</code> defines an accessor on the class: <code>get</code>s and <code>set</code>s done to the class will use the accessor definition as an implementation. <code>@accessor</code> called on a class will define an accessor for all instances of that class, whereas <code>@classAccessor</code> defines accessors on the class object itself. See <code>@accessor</code> for the details surrounding accessors.</p>\n<pre><code>test <span class=\"string\">'@classAccessor defines an accessor on the class'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDooDad</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">classAccessor</span> '<span class=\"title\">instance</span>', -&gt; <span class=\"title\">new</span> @()\n\n  <span class=\"title\">instance</span> = <span class=\"title\">SingletonDooDad</span>.<span class=\"title\">get</span>('<span class=\"title\">instance</span>')      # \"<span class=\"title\">classAccessor</span> <span class=\"title\">defines</span> <span class=\"title\">accessors</span> <span class=\"title\">for</span> <span class=\"title\">gets</span> <span class=\"title\">done</span> <span class=\"title\">on</span> <span class=\"title\">the</span> <span class=\"title\">class</span> <span class=\"title\">its</span> <span class=\"title\">self</span>\"\n  <span class=\"title\">ok</span> <span class=\"title\">SingletonDooDad</span>.<span class=\"title\">get</span>('<span class=\"title\">instance</span>') == <span class=\"title\">instance</span>  # \"<span class=\"title\">A</span> <span class=\"title\">second</span> <span class=\"title\">get</span> <span class=\"title\">returns</span> <span class=\"title\">the</span> <span class=\"title\">same</span> <span class=\"title\">instance</span>\"</code></pre>\n"
  - title: "@mixin(objects...) : prototype"
    tokens: []
    id: "4_2_%40mixin(objects...)_%3A_prototype"
    html: "<p><code>@mixin</code> is a handy function for mixing in <code>object</code>s to a class&#39; prototype. <code>@mixin</code> is implemented on top of the Batman level <code>mixin</code> helper, which means that keys from incoming <code>objects</code> will be applied using <code>set</code>, and any <code>initialize</code> functions on the <code>objects</code> will be called with the prototype being mixed into. Returns the prototype being mixed into.</p>\n<p><em>Note</em>: <code>@mixin</code>, similar to <code>@accessor</code>, applies to all instances of a class. If you need to mix in to the class itself, look at <code>classMixin</code>. <code>@mixin</code> is intended for use during the class definition of a <code>Batman.Object</code> subclass.</p>\n<pre><code>test <span class=\"string\">'@mixin extends the prototype of a Batman.Object subclass'</span>, -&gt;\n  FishBehaviour = {canBreathUnderwater: <span class=\"keyword\">true</span>}\n  MammalBehaviour = {canBreathAboveWater: <span class=\"keyword\">true</span>}\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Platypus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">mixin</span> <span class=\"title\">FishBehaviour</span>, <span class=\"title\">MammalBehaviour</span>\n\n  <span class=\"title\">platypus</span> = <span class=\"title\">new</span> <span class=\"title\">Platypus</span>\n  <span class=\"title\">ok</span> <span class=\"title\">platypus</span>.<span class=\"title\">get</span>('<span class=\"title\">canBreathAboveWater</span>')\n  <span class=\"title\">ok</span> <span class=\"title\">platypus</span>.<span class=\"title\">get</span>('<span class=\"title\">canBreathUnderwater</span>')</code></pre>\n"
  - title: "@classMixin(objects...) : this"
    tokens: []
    id: "4_3_%40classMixin(objects...)_%3A_this"
    html: "<p><code>@classMixin</code> allows mixing in objects to a class during that class&#39; definition. See <code>@mixin</code> for information about the arguments passed to mixin, but note that <code>@classMixin</code> applies to the class object itself, and <code>@mixin</code> applies to all instances of the class. Returns the class being mixed into.</p>\n<pre><code>test <span class=\"string\">'@classMixin extends the Batman.Object subclass'</span>, -&gt;\n  Singleton =\n    initialze: (subject) -&gt;\n      subject.accessor <span class=\"string\">'instance'</span>, -&gt; <span class=\"keyword\">new</span> subject\n\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Highlander</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">classMixin</span> <span class=\"title\">Singleton</span>\n\n  <span class=\"title\">instance</span> = <span class=\"title\">Highlander</span>.<span class=\"title\">get</span>('<span class=\"title\">instance</span>')\n  <span class=\"title\">ok</span> <span class=\"title\">instance</span> == <span class=\"title\">Highlander</span>.<span class=\"title\">get</span>('<span class=\"title\">instance</span>'), \"<span class=\"title\">There</span> <span class=\"title\">can</span> <span class=\"title\">only</span> <span class=\"title\">be</span> <span class=\"title\">one</span>.\"</code></pre>\n"
  - title: "@observeAll(key, callback : function) : prototype"
    tokens: []
    id: "4_4_%40observeAll(key%2C_callback_%3A_function)_%3A_prototype"
    html: "<p><code>@observeAll</code> extends the <code>Batman.Object</code> implementation of <code>Batman.Observable</code> with the ability to observe all instances of the class (and subclasses). Observers attached with <code>@observeAll</code> function exactly as if they were attached to the object directly. Returns the prototype of the class.</p>\n<p><em>Note</em>: <code>@observeAll</code> is intended to be used during the class definition for a <code>Batman.Object</code> subclass, but it can be called after the class has been defined as a function on the class. It supports being called after instances of the class have been instantiated as well.</p>\n<pre><code>test <span class=\"string\">\"@observeAll attaches handlers which get called upon change\"</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">observeAll</span> '<span class=\"title\">length</span>', (<span class=\"title\">newValue</span>, <span class=\"title\">oldValue</span>) -&gt; <span class=\"title\">log</span> <span class=\"title\">newValue</span>\n\n  <span class=\"title\">song</span> = <span class=\"title\">new</span> <span class=\"title\">Song</span>({</span>length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.set(<span class=\"string\">'length'</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual logged.last, <span class=\"number\">200</span>\n\ntest <span class=\"string\">\"@observeAll can attach handlers after instance instantiation\"</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n\n  <span class=\"title\">song</span> = <span class=\"title\">new</span> <span class=\"title\">Song</span>({</span>length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.set(<span class=\"string\">'length'</span>, <span class=\"number\">360</span>), <span class=\"number\">360</span>\n  deepEqual logged.last, undefined\n  Song.observeAll <span class=\"string\">'length'</span>, (newValue, oldValue) -&gt; log newValue\n  equal song.set(<span class=\"string\">'length'</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual logged.last, <span class=\"number\">200</span></code></pre>\n"
  - title: constructor(objects...)
    tokens: []
    id: 4_5_constructor(objects...)
    html: "<p>To create a new <code>Batman.Object</code>, the <code>Batman.Object</code> constructor can be used, or, the <code>Batman</code> namespace is also a utility function for creating Batman objects. Each object passed in to the constructor will have all its properties applied to the new <code>Batman.Object</code> using <code>get</code> and <code>set</code>, so any custom getters or setters will be respected. Objects passed in last will have precedence over objects passed in first in the event that they share the same keys. The property <code>copy</code> from these objects is shallow.</p>\n<pre><code>test 'Batman() function allows <span class=\"keyword\">for</span> handy creation <span class=\"keyword\">of</span> Batman.Objects', -&gt;\n  object = Batman(foo: 'bar')\n  <span class=\"keyword\">equal</span> typeof object.<span class=\"keyword\">get</span>, 'function'\n\ntest 'Batman.Object constructor function accepts multiple mixin arguments <span class=\"keyword\">and</span> later mixins take precedence.', -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">100</span>, bpm: <span class=\"number\">120</span>}, {bpm: <span class=\"number\">130</span>})\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">100</span>\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('bpm'), <span class=\"number\">130</span>, <span class=\"string\">\"The property from the second object passed to the constructor overwrites that from the first.\"</span></code></pre>\n"
  - title: "toJSON() : object"
    tokens: []
    id: "4_6_toJSON()_%3A_object"
    html: "<p><code>toJSON</code> returns a vanilla JavaScript object representing this <code>Batman.Object</code>.</p>\n<pre><code>test <span class=\"string\">'toJSON returns a vanilla JS object'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">object</span> = <span class=\"title\">Batman</span><span class=\"params\">(foo: <span class=\"string\">'bar'</span>)</span></span>\n  deepEqual <span class=\"keyword\">object</span>.toJSON(), {foo: <span class=\"string\">'bar'</span>}</code></pre>\n"
  - title: "hashKey() : string"
    tokens: []
    id: "4_7_hashKey()_%3A_string"
    html: "<p><code>hashKey</code> returns a unique string identifying this particular <code>Batman.Object</code>. No two <code>Batman.Object</code>s will have the same <code>hashKey</code>. Feel free to override the implmentation of this function on your objects if you have a better hashing scheme for a domain object of yours.</p>\n"
  - title: "accessor([keys...], objectOrFunction)"
    tokens: []
    id: "4_8_accessor(%5Bkeys...%5D%2C_objectOrFunction)"
    html: "<p><code>accessor</code> defines an accessor on one instance of an object instead of on all instances like the class level <code>@accessor</code>. See <code>@accessor</code> for the details surrounding accessors.</p>\n<pre><code>test <span class=\"string\">'accessor can be called on an instance of Batman.Object to define an accessor just on that instance'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n    @<span class=\"title\">accessor</span> '<span class=\"title\">summary</span>', -&gt; @<span class=\"title\">get</span>('<span class=\"title\">body</span>').<span class=\"title\">slice</span>(0, 10) + \"...\"\n\n  <span class=\"title\">post</span> = <span class=\"title\">new</span> <span class=\"title\">Post</span>(<span class=\"title\">body</span>: \"<span class=\"title\">Why</span> <span class=\"title\">Batman</span> <span class=\"title\">is</span> <span class=\"title\">Useful</span>: <span class=\"title\">A</span> <span class=\"title\">lengthy</span> <span class=\"title\">post</span> <span class=\"title\">on</span> <span class=\"title\">an</span> <span class=\"title\">important</span> <span class=\"title\">subject</span>\")\n  <span class=\"title\">equal</span> <span class=\"title\">post</span>.<span class=\"title\">get</span>('<span class=\"title\">summary</span>'), \"<span class=\"title\">Why</span> <span class=\"title\">Batman</span>...\"\n  <span class=\"title\">post</span>.<span class=\"title\">accessor</span>('<span class=\"title\">longSummary</span>', -&gt; @<span class=\"title\">get</span>('<span class=\"title\">body</span>').<span class=\"title\">slice</span>(0, 20) + \"...\")  # \"<span class=\"title\">Instance</span> <span class=\"title\">level</span> <span class=\"title\">accessor</span> <span class=\"title\">defines</span> <span class=\"title\">accessors</span> <span class=\"title\">just</span> <span class=\"title\">for</span> <span class=\"title\">that</span> <span class=\"title\">instance</span>\"\n  <span class=\"title\">equal</span> <span class=\"title\">post</span>.<span class=\"title\">get</span>('<span class=\"title\">longSummary</span>'), \"<span class=\"title\">Why</span> <span class=\"title\">Batman</span> <span class=\"title\">is</span> <span class=\"title\">Useful</span>...\"\n\n<span class=\"title\">test</span> '<span class=\"title\">defining</span> <span class=\"title\">an</span> <span class=\"title\">accessor</span> <span class=\"title\">on</span> <span class=\"title\">an</span> <span class=\"title\">instance</span> <span class=\"title\">does</span> <span class=\"title\">not</span> <span class=\"title\">affect</span> <span class=\"title\">the</span> <span class=\"title\">other</span> <span class=\"title\">instances</span>', -&gt;\n  <span class=\"title\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n\n  <span class=\"title\">post</span> = <span class=\"title\">new</span> <span class=\"title\">Post</span>(<span class=\"title\">body</span>: \"<span class=\"title\">Why</span> <span class=\"title\">Batman</span> <span class=\"title\">is</span> <span class=\"title\">Useful</span>: <span class=\"title\">A</span> <span class=\"title\">lengthy</span> <span class=\"title\">post</span> <span class=\"title\">on</span> <span class=\"title\">an</span> <span class=\"title\">important</span> <span class=\"title\">subject</span>\")\n  <span class=\"title\">otherPost</span> = <span class=\"title\">new</span> <span class=\"title\">Post</span>(<span class=\"title\">body</span>: \"<span class=\"title\">Why</span> <span class=\"title\">State</span> <span class=\"title\">Machines</span> <span class=\"title\">Are</span> <span class=\"title\">Useful</span>: <span class=\"title\">Another</span> <span class=\"title\">lengthy</span> <span class=\"title\">post</span>\")\n  <span class=\"title\">post</span>.<span class=\"title\">accessor</span> '<span class=\"title\">longSummary</span>', -&gt; @<span class=\"title\">get</span>('<span class=\"title\">body</span>').<span class=\"title\">slice</span>(0, 20) + \"...\"\n  <span class=\"title\">equal</span> <span class=\"title\">post</span>.<span class=\"title\">get</span>('<span class=\"title\">longSummary</span>'), \"<span class=\"title\">Why</span> <span class=\"title\">Batman</span> <span class=\"title\">is</span> <span class=\"title\">Useful</span>...\"\n  <span class=\"title\">equal</span> <span class=\"title\">otherPost</span>.<span class=\"title\">get</span>('<span class=\"title\">longSummary</span>'), <span class=\"title\">undefined</span></code></pre>\n"
  - title: "mixin(objects...) : this"
    tokens: []
    id: "4_9_mixin(objects...)_%3A_this"
    html: "<p><code>mixin</code> extends the object it&#39;s called on with the passed <code>objects</code> using the <code>Batman.mixin</code> helper. Returns the object it&#39;s called upon.</p>\n<p><em>Note</em>: Since the <code>Batman.mixin</code> helper is used, mixin functionality like using <code>set</code> to apply properties and calling <code>initialize</code> functions is included in the instance level <code>mixin</code> function.</p>\n<pre><code>test <span class=\"string\">'mixin on an instance applies the keys from the mixed in object to the instance'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snake</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span>\n\n  <span class=\"title\">snake</span> = <span class=\"title\">new</span> <span class=\"title\">Snake</span>()\n  <span class=\"title\">snake</span>.<span class=\"title\">mixin</span> {</span>canSlither: <span class=\"keyword\">true</span>}, {canHiss: <span class=\"keyword\">true</span>}\n  ok snake.get(<span class=\"string\">'canSlither'</span>)\n  ok snake.get(<span class=\"string\">'canHiss'</span>)</code></pre>\n"
tokens: []
id: 4_Batman.Object
html: "<p><code>Batman.Object</code> is the superclass for virtually all objects in a Batman application. <code>Batman.Object</code> mixes in <code>Batman.Observable</code> and <code>Batman.EventEmitter</code> for things like <code>get</code>, <code>set</code>, <code>observe</code>, and <code>fire</code>, and then defines some more useful things for tying everything together.</p>\n"

---

{{ page.html }}
{% for s in page.sub %}
  <h3 id="{{ s.id }}">{{ s.title }}</h3>
  {{ s.html }}
{% endfor %}
