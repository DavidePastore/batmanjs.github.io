---
layout: api_docs
title: Batman.Observable
sub: 
  - title: "get(keypath) : value"
    tokens: []
    id: "3_0_get(keypath)_%3A_value"
    html: "<p>Retrieves the value at a <code>key</code> on an object. Accepts keypaths.</p>\n<p><em>Note</em>: <code>get</code> must be used for property access on any object in <code>Batman</code>&#39;s world. This is so that Batman can implement neat things like automatic dependency calculation for computed properties, property caching where it is safe, and smart storage mechanisms. With Batman, you must use <code>get</code> instead of normal <code>.</code> property access.</p>\n<pre><code>test '<span class=\"keyword\">get</span> retrieves properties <span class=\"function_start\"><span class=\"keyword\">on</span> <span class=\"title\">Batman</span></span> objects', -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">340</span>\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('bpm'), <span class=\"number\">120</span>\n\ntest '<span class=\"keyword\">get</span> retrieves properties <span class=\"function_start\"><span class=\"keyword\">on</span> <span class=\"title\">nested</span></span> Batman objects using keypaths', -&gt;\n  post = Batman\n    <span class=\"type\">text</span>: <span class=\"string\">\"Hello World!\"</span>\n    author: Batman\n  <span class=\"property\">name</span>: <span class=\"string\">\"Harry\"</span>\n  <span class=\"keyword\">equal</span> post.<span class=\"keyword\">get</span>('author.<span class=\"property\">name</span>'), <span class=\"string\">\"Harry\"</span>\n\ntest <span class=\"string\">\"get retrieves properties on Batman objects when . property access doesn't\"</span>, -&gt;\n  song = new Batman.Model({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"keyword\">equal</span> typeof song.<span class=\"property\">length</span>, <span class=\"string\">\"undefined\"</span>\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">340</span></code></pre>\n"
  - title: "set(keypath, newValue) : newValue"
    tokens: []
    id: "3_1_set(keypath%2C_newValue)_%3A_newValue"
    html: "<p>Stores the <code>value</code> at a <code>key</code> on an object. Accepts keypaths. Returns the new value of the property.</p>\n<p><em>Note</em>: Once more, <code>set</code> must be used for property mutation on all objects in the <code>Batman</code> world. This is again so that Batman can implement useful functionality like cache busting, eager recalculation of computed properties, and smarter storage.</p>\n<p><em>Note</em>: Custom setters can mutate the value during setting, so the value which was passed to <code>set</code> and <code>set</code>&#39;s return value are not guaranteed to be identical.</p>\n<pre><code>test '<span class=\"keyword\">set</span> stores properties <span class=\"function_start\"><span class=\"keyword\">on</span> <span class=\"title\">batman</span></span> objects.', -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})</code></pre>\n<p>  equal song.get(&#39;length&#39;), 340\n  equal song.set(&#39;length&#39;, 1000), 1000\n      equal song.get(&#39;length&#39;), 1000</p>\n<pre><code>test '<span class=\"keyword\">set</span> stores properties <span class=\"function_start\"><span class=\"keyword\">on</span> <span class=\"title\">nested</span></span> Batman objects using keypaths', -&gt;\n  author = Batman\n    <span class=\"property\">name</span>: <span class=\"string\">\"Harry\"</span>\n  post = Batman\n    <span class=\"type\">text</span>: <span class=\"string\">\"Hello World!\"</span>\n    author: author\n  <span class=\"keyword\">equal</span> post.<span class=\"keyword\">set</span>('author.<span class=\"property\">name</span>', <span class=\"string\">\"Nick\"</span>), <span class=\"string\">\"Nick\"</span>\n  <span class=\"keyword\">equal</span> author.<span class=\"keyword\">get</span>('<span class=\"property\">name</span>'), <span class=\"string\">\"Nick\"</span>, <span class=\"string\">\"The value was set on the nested object.\"</span>\n\ntest <span class=\"string\">\"set is incompatible with '.' property mutation\"</span>, -&gt;\n  song = new Batman.Model({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})</code></pre>\n<p>  equal song.get(&#39;length&#39;), 340\n  equal song.length = 1000, 1000\n      equal song.get(&#39;length&#39;), 340, &quot;The song length reported by Batman is unchanged because set wasn&#39;t used to change the value.&quot;</p>\n"
  - title: "unset(keypath) : value"
    tokens: []
    id: "3_2_unset(keypath)_%3A_value"
    html: "<p>Removes the value at the given <code>keypath</code>, leaving it <code>undefined</code>. Accepts keypaths. Returns the value the property had before unsetting.</p>\n<p><code>unset</code> is roughly equivalent to <code>set(keypath, undefined)</code>, however, custom properties can define a nonstandard <code>unset</code> function, so it is best to use <code>unset</code> instead of <code>set(keypath, undefined)</code> wherever possible.</p>\n<pre><code>test <span class=\"string\">\"unset removes the property on Batman objects\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">340</span>\n  <span class=\"keyword\">equal</span> song.unset('<span class=\"property\">length</span>'), <span class=\"number\">340</span>\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), undefined, <span class=\"string\">\"The value is unset.\"</span>\n\ntest <span class=\"string\">\"unset removes the property at a keypath\"</span>, -&gt;\n  author = Batman\n    <span class=\"property\">name</span>: <span class=\"string\">\"Harry\"</span>\n  post = Batman\n    <span class=\"type\">text</span>: <span class=\"string\">\"Hello World!\"</span>\n    author: author\n  <span class=\"keyword\">equal</span> post.unset('author.<span class=\"property\">name</span>'), <span class=\"string\">\"Harry\"</span>\n  <span class=\"keyword\">equal</span> author.<span class=\"keyword\">get</span>('<span class=\"property\">name</span>'), undefined, <span class=\"string\">\"The value was unset on the nested object.\"</span></code></pre>\n"
  - title: "observe(key, observerCallback) : this"
    tokens: []
    id: "3_3_observe(key%2C_observerCallback)_%3A_this"
    html: "<p>Adds a handler to call when the value of the property at the <code>key</code> changes upon <code>set</code>ting. Accepts keypaths.</p>\n<p><code>observe</code> is the very core of Batman&#39;s usefulness. As long as <code>set</code> is used everywhere to do property mutation, any object can be observed for changes to its properties. This is critical to the concept of bindings, which Batman uses for its views.</p>\n<p>The <code>observerCallback</code> gets called whenever the <code>key</code> changes with the arguments <code>newValue, oldValue</code>.</p>\n<p>Returns the object <code>observe</code> was called upon.</p>\n<pre><code>test <span class=\"string\">\"observe attaches handlers which get called upon change\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  song.observe '<span class=\"property\">length</span>', (newValue, oldValue) -&gt; <span class=\"command\">log</span> [newValue, oldValue]\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual logged.<span class=\"keyword\">last</span>, [<span class=\"number\">200</span>, <span class=\"number\">340</span>]\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual logged.<span class=\"keyword\">last</span>, [<span class=\"number\">300</span>, <span class=\"number\">200</span>]</code></pre>\n<p><em>Note</em>: <code>observe</code> works excellently on keypaths. If you attach a handler to a &quot;deep&quot; keypath, it will fire any time the value of that keypath changes, which is another way of saying the handler will fire when any segment of the keypath changes, passing in the new value at the end of the keypath.</p>\n<pre><code>test <span class=\"string\">\"observe attaches handlers which get called upon change\"</span>, -&gt;\n  author = Batman\n    <span class=\"property\">name</span>: <span class=\"string\">\"Harry\"</span>\n  post = Batman\n    <span class=\"type\">text</span>: <span class=\"string\">\"Hello World!\"</span>\n    author: author\n  post.observe('author.<span class=\"property\">name</span>', (newName, oldName) -&gt; <span class=\"command\">log</span> [newName, oldName])\n  post.<span class=\"keyword\">set</span> 'author', newAuthor = Batman({<span class=\"property\">name</span>: <span class=\"string\">\"James\"</span>})\n  deepEqual logged.<span class=\"keyword\">last</span>, [<span class=\"string\">\"James\"</span>, <span class=\"string\">\"Harry\"</span>], <span class=\"string\">\"The observer fired when the 'author' segment of the keypath changed.\"</span></code></pre>\n"
  - title: "observeAndFire(key, observerCallback) : this"
    tokens: []
    id: "3_4_observeAndFire(key%2C_observerCallback)_%3A_this"
    html: "<p>Adds the <code>observerCallback</code> as an observer to <code>key</code>, and fires it immediately. Accepts the exact same arguments and follows the same semantics as <code>Observable::observe</code>, but the observer is fired with the current value of the keypath it observes synchronously during the call to <code>observeAndFire</code>.</p>\n<p>During the initial synchronous firing of the <code>callback</code>, the <code>newValue</code> and <code>oldValue</code> arguments will be the same value: the current value of the property. This is because the old value of the property is not cached and therefore unavailable. If your observer needs the old value of the property, you must attach it before the <code>set</code> on the property happens.</p>\n<pre><code>test <span class=\"string\">\"observeAndFire calls the observer upon attaching it with the currentValue of the property\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  song.observeAndFire '<span class=\"property\">length</span>', (newValue, oldValue) -&gt; <span class=\"command\">log</span> [newValue, oldValue]\n  deepEqual logged.<span class=\"keyword\">last</span>, [<span class=\"number\">340</span>, <span class=\"number\">340</span>]\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual logged.<span class=\"keyword\">last</span>, [<span class=\"number\">300</span>, <span class=\"number\">340</span>]</code></pre>\n"
  - title: "forget([key [, observerCallback]]) : this"
    tokens: []
    id: "3_5_forget(%5Bkey_%5B%2C_observerCallback%5D%5D)_%3A_this"
    html: "<p>If <code>observerCallback</code> and <code>key</code> are given, that observer is removed from the observers on <code>key</code>. If only a <code>key</code> is given, all observers on that key are removed. If no <code>key</code> is given, all observers on all keys are removed. Accepts keypaths.</p>\n<p>Returns the object on which <code>forget</code> was called.</p>\n<pre><code>test <span class=\"string\">\"forget removes an observer from a key if the key and the observer are given\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  observer = (newValue, oldValue) -&gt; <span class=\"command\">log</span> [newValue, oldValue]\n  song.observe '<span class=\"property\">length</span>', observer\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual logged.<span class=\"keyword\">last</span>, [<span class=\"number\">200</span>, <span class=\"number\">340</span>]\n  song.forget '<span class=\"property\">length</span>', observer\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual logged.<span class=\"keyword\">last</span>, [<span class=\"number\">200</span>, <span class=\"number\">340</span>], <span class=\"string\">\"The logged values haven't changed because the observer hasn't fired again.\"</span>\n\ntest <span class=\"string\">\"forget removes all observers from a key if only the key is given\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  observerA = ((newValue, oldValue) -&gt; <span class=\"command\">log</span> [newValue, oldValue])\n  observerB = ((newValue, oldValue) -&gt; <span class=\"command\">log</span> [newValue, oldValue])\n  song.observe '<span class=\"property\">length</span>', observerA\n  song.observe '<span class=\"property\">length</span>', observerB\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  <span class=\"keyword\">equal</span> logged.<span class=\"property\">length</span>, <span class=\"number\">2</span>, <span class=\"string\">\"Both length observers fired.\"</span>\n  song.forget('<span class=\"property\">length</span>')\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  <span class=\"keyword\">equal</span> logged.<span class=\"property\">length</span>, <span class=\"number\">2</span>, <span class=\"string\">\"Nothing more has been logged because neither observer fired.\"</span>\n\ntest <span class=\"string\">\"forget removes all observers from all keys if no key is given\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  observerA = ((newValue, oldValue) -&gt; <span class=\"command\">log</span> [newValue, oldValue])\n  observerB = ((newValue, oldValue) -&gt; <span class=\"command\">log</span> [newValue, oldValue])\n  song.observe '<span class=\"property\">length</span>', observerA\n  song.observe 'bpm', observerB\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  <span class=\"keyword\">equal</span> logged.<span class=\"property\">length</span>, <span class=\"number\">1</span>, <span class=\"string\">\"The length observer fired.\"</span>\n  song.forget()\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('<span class=\"property\">length</span>', <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">set</span>('bpm', <span class=\"number\">130</span>), <span class=\"number\">130</span>\n  <span class=\"keyword\">equal</span> logged.<span class=\"property\">length</span>, <span class=\"number\">1</span>, <span class=\"string\">\"Nothing more has been logged because neither observer fired.\"</span></code></pre>\n"
  - title: "getOrSet(keypath, valueFunction) : value"
    tokens: []
    id: "3_6_getOrSet(keypath%2C_valueFunction)_%3A_value"
    html: "<p>Assigns the <code>keypath</code> to the result of calling the <code>valueFunction</code> if the current value at the <code>keypath</code> is falsey. Returns the value of the property after the operation, be it changed or not. Equivalent to CoffeeScript&#39;s <code>||=</code> operator.</p>\n<pre><code>test <span class=\"string\">\"getOrSet doesn't set the property if it exists\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"keyword\">equal</span> song.getOrSet('<span class=\"property\">length</span>', -&gt; <span class=\"number\">500</span>), <span class=\"number\">340</span>\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('<span class=\"property\">length</span>'), <span class=\"number\">340</span>\n\ntest <span class=\"string\">\"getOrSet sets the property if it is falsey\"</span>, -&gt;\n  song = Batman({<span class=\"property\">length</span>: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"keyword\">equal</span> song.getOrSet('artist', -&gt; <span class=\"string\">\"Elvis\"</span>), <span class=\"string\">\"Elvis\"</span>\n  <span class=\"keyword\">equal</span> song.<span class=\"keyword\">get</span>('artist'), <span class=\"string\">\"Elvis\"</span></code></pre>\n"
tokens: []
id: 3_Batman.Observable
html: "<p><code>Batman.Observable</code> is a mixin which gives objects the ability to notify subscribers to changes on its properties. <code>Observable</code> also adds functionality for observing <em>keypaths</em>: arbitrarily deeply nested properties on objects.</p>\n"

---

{{ page.html }}
{% for s in page.sub %}
  <h3 id="{{ s.id }}">{{ s.title }}</h3>
  {{ s.html }}
{% endfor %}
