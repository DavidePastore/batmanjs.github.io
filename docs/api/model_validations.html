---
layout: api_docs
title: Model Validations
meta: 
  grouping: App Components
  parent: Batman.Model
sub: 
  - title: "Built-In Validations"
    tokens: []
    id: "built-in_validations"
    html: "<p>Built in validators are attached by calling <code>@validate</code> with options designating how to calculate the validity of the key:</p>\n<pre><code>test <span class=\"string\">'@validate accepts options to check for validity'</span>, -&gt;\n  QUnit.expect(<span class=\"number\">0</span>)\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Model</span></span>\n    <span class=\"property\">@resourceName</span>: <span class=\"string\">'post'</span>\n\n    <span class=\"property\">@validate</span> <span class=\"string\">'title'</span>, <span class=\"string\">'body'</span>, {presence: <span class=\"literal\">true</span>} <span class=\"comment\"># title and body must be present (not undefined nor '')</span>\n    <span class=\"property\">@validate</span> <span class=\"string\">'body'</span>, {minLength: <span class=\"number\">10</span>}           <span class=\"comment\"># body must be 10 characters long at least</span>\n    <span class=\"property\">@validate</span> <span class=\"string\">'title'</span>, {pattern: <span class=\"regexp\">/^[A-Z]/</span>}      <span class=\"comment\"># Title must start with an uppercase letter</span>\n    <span class=\"property\">@validate</span> <span class=\"string\">'author'</span>, {email: <span class=\"literal\">true</span>}           <span class=\"comment\"># the author field must contain a valid email address</span></code></pre>\n<p>Option | Asserts that ...\n=== | ===\n<code>presence : Boolean</code> | String value is existent (not undefined or null) and has length greater than 0</p>\n<ul>\n<li><code>presence : boolean</code>: Assert that the .</li>\n<li><code>numeric : true</code>: Assert that the value is or can be coerced into a number using <code>parseFloat</code>.</li>\n<li><code>greaterThan : number</code>: Assert that the value is greater than the given number.</li>\n<li><code>greaterThanOrEqualTo : number</code>: Assert that the value is greater than or equal to the given number.</li>\n<li><code>equalTo : number</code>: Assert that the value is equal to the given number.</li>\n<li><code>lessThan : number</code>: Assert that the value is less than the given number.</li>\n<li><code>lessThanOrEqualTo : number</code>: Assert that the value is less than or equal to the given number.</li>\n<li><code>minLength : number</code>: Assert that the value&#39;s <code>length</code> property is greater than the given number.</li>\n<li><code>maxLength : number</code>: Assert that the value&#39;s <code>length</code> property is less than the given number.</li>\n<li><code>length : number</code>: Assert that the value&#39;s <code>length</code> property is exactly the given number.</li>\n<li><code>lengthWithin : [number, number]</code> or <code>lengthIn : [number, number]</code>: Assert that the value&#39;s <code>length</code> property is within the ranger specified by the given array of two numbers, where the first number is the lower bound and the second number is the upper bound.</li>\n<li><code>inclusion : in : [list, of, acceptable, values]</code>: Assert that the value is equal to one of the values in an array.</li>\n<li><code>exclusion : in : [list, of, unacceptable, values]</code>: Assert that the value is not equal to any of the values in an array.</li>\n<li><code>regexp : /regexp/</code> : Assert that the value is matching the provided regular expression.</li>\n<li><code>email : true</code> : Assert that the value is an email address, per the <a href=\"http://www.w3.org/TR/html5/forms.html#valid-e-mail-address\">W3C HTML5 definition</a>.</li>\n<li><code>associated : true</code> : Assert that associated record is also valid. If invalid the message will be &quot;#{associationName} is not valid&quot;.</li>\n<li><code>associatedFields : true</code> : Like <code>associated</code>, but adds error messages with the names of the fields on associated records, eg &quot;Username must be at least 10 characters&quot; or &quot;Favorite flavor is not included in the list&quot;.</li>\n</ul>\n"
  - title: Custom Validation
    tokens: []
    id: custom_validation
    html: "<p>You can easily define a custom validation by passing a function to <code>@validate</code>:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span>.<span class=\"title\">Product</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Model</span></span>\n  <span class=\"property\">@validate</span> <span class=\"string\">'name'</span>, (errors, record, key, callback) -&gt;\n    <span class=\"comment\"># custom validation ...</span>\n    callback()</code></pre>\n<p>The function takes <code>(errors, record, key, callback)</code>:</p>\n<ul>\n<li><code>errors</code>: the <code>Batman.ErrorsSet</code> for this record</li>\n<li><code>record</code>: the record being validated</li>\n<li><code>key</code>: the key to which the validation has been attached</li>\n<li><code>callback</code>: a function to call once validation has been completed. Calling this function is <strong>mandatory</strong>: it enables validations to be asynchronous.</li>\n</ul>\n<p>To show that the record is invalid, a validation function should call <code>errors.add(key, message)</code>.</p>\n"
  - title: Conditional Validation
    tokens: []
    id: conditional_validation
    html: "<p>Validations can be skipped by including a conditional check. Pass <code>if</code> or <code>unless</code> as options to <code>@validate</code>:</p>\n<pre><code>test <span class=\"string\">'@validate accepts an if or unless option to determine whether the validation should be performed or not'</span>, -&gt;\n  QUnit.expect(<span class=\"number\">0</span>)\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Invoice</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Model</span></span>\n    <span class=\"property\">@resourceName</span>: <span class=\"string\">'invoice'</span>\n    <span class=\"property\">@validate</span> <span class=\"string\">'tax_1_rate'</span>, {presence: <span class=\"literal\">true</span>, <span class=\"keyword\">if</span>: (errors, record, key) -&gt; record.get(<span class=\"string\">'tax_1_enabled'</span>)} <span class=\"comment\"># tax 1 rate must be present if tax 1 is enabled</span>\n    <span class=\"property\">@validate</span> <span class=\"string\">'tax_2_rate'</span>, {presence: <span class=\"literal\">true</span>, <span class=\"keyword\">if</span>: <span class=\"string\">'tax_2_rate'</span>} <span class=\"comment\"># passing a string will look for an attribute or accessor with that name on the record</span>\n    <span class=\"property\">@validate</span> <span class=\"string\">'discount_rate'</span>, {presence: <span class=\"literal\">true</span>, <span class=\"keyword\">unless</span>: <span class=\"string\">'discount_disabled'</span>} <span class=\"comment\"># discount rate must be present unless discount is disabled</span></code></pre>\n<p>If you pass a string as <code>if</code> or <code>unless</code>, it will do a <code>@get(string)</code> on the record being validated. If you pass a function, it should have the signature <code>(errors, record, key)</code>:</p>\n<ul>\n<li><code>errors</code>: the ErrorsSet instance</li>\n<li><code>record</code>: the record being validated</li>\n<li><code>key</code>: the key to which the validation has been attached</li>\n</ul>\n"
tokens: []
id: model_validations
html: "<p>Validations allow a model to be marked as <code>valid</code> or <code>invalid</code> based on a set of programmatic rules. By validating a model&#39;s data before it gets to the server, we can provide immediate feedback to the user about what they have entered and forgo waiting on a round trip to the server. <code>validate</code> allows the attachment of validations to the model on particular keys, where the validation is either a built-in one (invoked by use of options to pass to them) or a custom one (invoked by use of a custom function as the second argument).</p>\n<p><em>Note</em>: Validation in batman.js is always asynchronous, despite the fact that none of the validations may use an asynchronous operation to check for validity. This is so that the API is consistent regardless of the validations used.</p>\n"

---

{{ page.html }}
<ul class="api-list">
{% for s in page.sub %}
  <li class="api-list-item">
    <h3 class="api-title">
      <a id="{{ s.id }}" class="anchor-target"></a>
      <a href="#{{ s.id }}" class="anchor-link">
      <span class="{% if s.meta %}monospace-heading{% endif %}">{% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}{% if s.meta.type == 'property' %}<span class="params">{{ s.meta.params }}</span>{% else %}<span class="params">({{ s.meta.params }})</span>  {% endif %}{% endif %}{% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}</span>
      </a>
    </h3>
    {{ s.html }}
  </li>
{% endfor %}
</ul>
