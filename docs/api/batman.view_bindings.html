---
layout: api_docs
title: Batman.View Bindings
meta: 
  grouping: App Components
  parent: Batman.View
sub: 
  - title: Custom Bindings
    tokens: []
    id: custom_bindings
    html: "<p>To add a custom binding,</p>\n<ul>\n<li>Extend an existing batman.js binding class</li>\n<li>Create a binding hook as a property of  <code>Batman.DOM.readers</code> or <code>Batman.DOM.attrReaders</code> (for bindings like <code>data-binding-#{attr}</code>).</li>\n</ul>\n<p>For example, a <code>data-permission</code> binding:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"comment\"># Usage:</span>\n<span class=\"comment\"># &lt;div data-permission='administrator'&gt;</span>\n<span class=\"comment\">#   &lt;!-- equal to `data-showif='isAdministrator'` --&gt;</span>\n<span class=\"comment\"># &lt;/div&gt;</span>\n\n<span class=\"comment\"># Binding class</span>\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Batman</span>.<span class=\"title\">DOM</span>.<span class=\"title\">PermissionBinding</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">DOM</span>.<span class=\"title\">ShowHideBinding</span></span>\n  constructor: (definition) -&gt;\n    permissionName = definition.keyPath\n    permissionKeyPath = <span class=\"string\">\"is<span class=\"subst\">#{Batman.helpers.titleize(permissionName)}</span>\"</span>\n    definition.keyPath = permissionKeyPath\n    <span class=\"keyword\">super</span>(definition)\n\n<span class=\"comment\"># Binding hook:</span>\nBatman.DOM.readers.<span class=\"function\"><span class=\"title\">permission</span></span> = (definition) -&gt;\n  <span class=\"keyword\">new</span> Batman.DOM.PermissionBinding(definition)</code></pre>\n"
  - title: "data-bind"
    tokens: []
    id: "data-bind"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> creates a two way binding between a property on a <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a> and an HTML element. Bindings created via <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> will update the HTML element with the value of the JS land property as soon as they are created and each time the property changes after, and if the HTML element can be observed for changes, it will update the JS land property with the value from the HTML.</p>\n<p><a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> will change its behaviour depending on what kind of tag it is attached to:</p>\n<ul>\n<li><code>&lt;input type=&quot;checkbox&quot;&gt;</code>: the binding will edit the <code>checked</code> property of the checkbox and populate the keypath with a boolean.</li>\n<li><code>&lt;input type=&quot;text&quot;&gt;</code> and similar, <code>&lt;textarea</code>&gt;: the binding will edit the <code>value</code> property of the input and populate the keypath with the string found at <code>value</code>.</li>\n<li><code>&lt;input type=&quot;file&quot;&gt;</code>: the binding will <em>not</em> edit the <code>value</code> property of the input, but it will update the keypath with a host <code>File</code> object or objects if the node has the <code>multiple</code> attribute.</li>\n<li><code>&lt;select&gt;</code>: the binding will edit the <code>selected</code> property of each <code>&lt;option&gt;</code> tag within the <code>&lt;select&gt;</code> matching the property at the keypath. If the <code>&lt;select&gt;</code> has the multiple attribute, the value at the keypath can be an array of selected <code>&lt;option&gt;</code> values. You can also use <code>data-bind-selected</code> bindings on the individual options to toggle option selectedness.</li>\n<li>All other tags: the binding will edit the <code>innerHTML</code> property of the tag and will not populate the keypath.</li>\n</ul>\n<p><a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> can also be used to bind an attribute of a node to a JavaScript property. Since attributes can&#39;t be observed for changes, this is a one way binding which will never update the JavaScript land property. Specify which attribute to bind using the &quot;double dash&quot; syntax like so: <code>data-bind-attribute=&quot;some.keypath&quot;</code>. For example, to bind the <code>placeholder</code> attribute of an input, use <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind-placeholder</code></a>.</p>\n<pre><code class=\"lang-html\">&lt;input type=<span class=\"string\">\"text\"</span> data-bind-placeholder=<span class=\"string\">\"'Specify a subtitle for product ' | append product.name\"</span>&gt;</code></pre>\n<p><em>Note</em>: <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> will not update a JavaScript property if filters are used in the keypath.</p>\n"
  - title: "data-source"
    tokens: []
    id: "data-source"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-source\"><code>data-source</code></a> creates a one way binding which propagates only changes from JavaScript land to the DOM, and never vice versa. <a href=\"/docs/api/batman.view_bindings.html#data-source\"><code>data-source</code></a> has the same semantics with regards to how it operates on different tags as <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a>, but it will only ever update the DOM and never the JavaScript land property.</p>\n<p>For example, the HTML below will never update the <code>title</code> property on the product, even if the user changes it. Each time the <code>title</code> attribute changes from a <code>set</code> in JavaScript land, the value of the input will be updated to the new value of <code>title</code>, erasing any potential changes that have been made to the value of the input by the user.</p>\n<pre><code class=\"lang-html\">&lt;input type=<span class=\"string\">\"text\"</span> data-source=<span class=\"string\">\"product.title\"</span>&gt;</code></pre>\n<p><em>Note</em>: <a href=\"/docs/api/batman.view_bindings.html#data-source\"><code>data-source-attribute</code></a> is equivalent to <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind-attribute</code></a>, since the former is defined as never making JS land changes, and the latter is unable to.</p>\n"
  - title: "data-target"
    tokens: []
    id: "data-target"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-target\"><code>data-target</code></a> creates a one way binding which propagates only changes from the DOM to JavaScript land, and never vice versa. <a href=\"/docs/api/batman.view_bindings.html#data-target\"><code>data-target</code></a> has the same semantics with regards to how it operates on different tags as <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a>, but it will never update the DOM even if the JavaScript land value changes.</p>\n<p><em>Note</em>: <a href=\"/docs/api/batman.view_bindings.html#data-target\"><code>data-target-attribute</code></a> is unavailable, because DOM changes to node attributes can&#39;t be monitored.</p>\n"
  - title: "data-showif / data-hideif"
    tokens: []
    id: "data-showif_%2F_data-hideif"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-showif</code></a> and <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-hideif</code></a> bind to keypaths and show or hide the node they appear on based on the truthiness of the result. <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-showif</code></a> will show a node if the given keypath evaluates to something truthy, and <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-hideif</code></a> will leave a node visible until its given keypath becomes truthy, at which point the node will be hidden. <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-showif</code></a> and <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-hideif</code></a> show and hide nodes by adding <code>display: none !important;</code> to the node&#39;s <code>style</code> attribute.</p>\n<p>For example, if the HTML below is rendered where the keypath <code>product.published</code> evaluated to true, the <code>&lt;button&gt;</code> will be visible.</p>\n<pre><code class=\"lang-html\">&lt;button data-showif=<span class=\"string\">\"product.published\"</span>&gt;Unpublish Product&lt;/button&gt;</code></pre>\n<p>This is the Batman equivalent of a templating language&#39;s <code>if</code> construct, where else branches are implemented using the opposite binding.</p>\n<pre><code class=\"lang-html\">&lt;button data-showif=<span class=\"string\">\"product.published\"</span>&gt;Unpublish Product&lt;/button&gt;\n&lt;button data-hideif=<span class=\"string\">\"product.published\"</span>&gt;Publish Product&lt;/button&gt;</code></pre>\n"
  - title: "data-addclass / data-removeclass"
    tokens: []
    id: "data-addclass_%2F_data-removeclass"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-addclass</code></a> and <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-removeclass</code></a> bindings can be used to conditionally add or remove a class from a node based on a boolean keypath. Specify the class to add using the &quot;double dash&quot; syntax; for example,<code>data-addclass-big=&quot;some.keypath&quot;</code> on a node will add the &quot;big&quot; class to that node&#39;s classes if <code>some.keypath</code> is truthy. <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-removeclass</code></a> will remove a class (usually one which is present in the HTML) if the keypath passed to it is truthy.</p>\n<p>The outer span in the HTML below will have an &quot;error&quot; class when the <code>product.errors.length</code> keypath evaluates to anything other than 0, since 0 is falsy and other numbers are truthy.</p>\n<pre><code class=\"lang-html\">&lt;p data-addclass-error=<span class=\"string\">\"product.errors.length\"</span>&gt;\n  This product has &lt;span data-bind=<span class=\"string\">\"product.errors.length\"</span>&gt;&lt;/span&gt; errors.\n&lt;/p&gt;</code></pre>\n"
  - title: "data-foreach"
    tokens: []
    id: "data-foreach"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a> is used to loop over an iterable object in Batman views. <a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a> duplicates the node it occurs on for each item in the collection found at the keypath given to it, and renders each duplicated node with that node&#39;s object from the collection by putting it in the context under a name passed to it using the &quot;double dash&quot; syntax.</p>\n<p>The <code>&lt;option&gt;</code> node below will be duplicated for each item in the <code>Set</code> at the <code>products</code> keypath.</p>\n<pre><code class=\"lang-html\">&lt;select&gt;\n  &lt;option data-foreach-product=<span class=\"string\">\"products\"</span> data-bind=<span class=\"string\">\"product.name\"</span>&gt;&lt;/option&gt;\n&lt;/select&gt;</code></pre>\n<p>Batman will execute the <a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a> binding before the <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> on the <code>&lt;option&gt;</code> node, which means that the <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> will be processed for each duplicated node with each separate Product in the <code>products</code> Set in scope for each separate node. If there were say 3 Products in the <code>products</code> set, the HTML would look similar to this once rendered:</p>\n<pre><code class=\"lang-html\">&lt;select&gt;\n  &lt;option data-bind=<span class=\"string\">\"product.name\"</span>&gt;Product A&lt;/option&gt;\n  &lt;option data-bind=<span class=\"string\">\"product.name\"</span>&gt;Product B&lt;/option&gt;\n  &lt;option data-bind=<span class=\"string\">\"product.name\"</span>&gt;Product C&lt;/option&gt;\n  &lt;!-- end products --&gt;\n&lt;/select&gt;</code></pre>\n<p><a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a> can be used to iterate over <a href=\"/docs/api/batman.set.html\"><code>Batman.Set</code></a>s, and most often should be, because it observes any Sets and will update the DOM with new nodes if items are added to the set, or remove nodes from the DOM if their corresponding nodes are removed from the set. <a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a>, like every other binding, is keypath aware, such that if the <code>Set</code> instance at the keypath changes, or any previous segment of the keypath changes, <a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a> will remove all the nodes currently in the DOM, and add new nodes for each new item in the incoming <code>Set</code>.</p>\n<p>Sometimes you&#39;ll need to add some custom logic to the iteration nodes. For example, a custom <code>viewDidAppear</code> handler so you can know whenever a new iteration node appears in the DOM. You can do this by specifying a custom subclass of <a href=\"/docs/api/batman.iterationview.html\"><code>Batman.IterationView</code></a>.</p>\n<pre><code class=\"lang-html\">&lt;ul&gt;\n  &lt;li data-foreach-product=<span class=\"string\">\"products\"</span> data-view=<span class=\"string\">\"ProductIterationView\"</span>&gt;\n    &lt;span data-bind=<span class=\"string\">\"product.name\"</span>&gt;&lt;/span&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span>.<span class=\"title\">ProductIterationView</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">IterationView</span></span>\n  viewDidAppear: -&gt;\n    $(<span class=\"property\">@get</span>(<span class=\"string\">'node'</span>)).draggable()</code></pre>\n<p><em>Note</em>: <a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a> expects to find an iterable object at the keypath given to it, and will emit a warning if it finds <code>undefined</code>.</p>\n<p><em>Note</em>: <a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach</code></a> expects the passed enumerable to be unique. It creates a map of nodes to items, so every node needs to be able to reference exactly one object. If you simply have a set of values that you&#39;re iterating over, you should wrap your values in objects, e.g. <code>[{value: true}, {value: true}]</code>.</p>\n"
  - title: "data-formfor"
    tokens: []
    id: "data-formfor"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-formfor\"><code>data-formfor</code></a> creates a special addition to the context stack to represent an object under edit within a form. Usually this object is a model. Using the double dash syntax, the name for the model to reside under can be specified.</p>\n<p><strong>Automatic Validation Display</strong></p>\n<p><a href=\"/docs/api/batman.view_bindings.html#data-formfor\"><code>data-formfor</code></a> also has some handy functionality for displaying the result of validating the object under edit in the form. This will only be enabled if the object has an <code>errors</code> Set, like <code>Batman.Models</code> do.</p>\n<p>If a tag matching the relative selector <code>.errors</code> is found, it will populate this element with a list of the errors found during validation on the object. The selector for the errors container can be changed by adding a <code>data-errors-list</code> attribute with the value of the selector to the form with the <a href=\"/docs/api/batman.view_bindings.html#data-formfor\"><code>data-formfor</code></a> binding on it, or editing <code>Batman.DOM.FormBinding::defaultErrorsListSelector</code>.</p>\n<p>If value bindings are made using <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> to attributes on the model within the form, automatic <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-addclass-error</code></a> bindings will be added to the elements on which the <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> occurs to add the &quot;error&quot; class when the model has errors on the attribute which <a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a> binds to.</p>\n<p>In the HTML below, an automatic <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-addclass-error</code></a> will be added to the <code>&lt;input&gt;</code> which activates when the <code>product</code> model has validation errors on the <code>name</code> attribute.</p>\n<pre><code class=\"lang-html\">&lt;form data-formfor-product=<span class=\"string\">\"currentProduct\"</span>&gt;\n  &lt;input type=<span class=\"string\">\"text\"</span> data-bind=<span class=\"string\">\"product.name\"</span>&gt;&lt;/input&gt;\n&lt;/form&gt;</code></pre>\n<p>The class which gets automatically added to inputs binding to invalid attributes can be customized by editing <code>Batman.DOM.FormBinding::errorClass</code>.</p>\n"
  - title: "data-context"
    tokens: []
    id: "data-context"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-context\"><code>data-context</code></a> bindings add the object found at the key to the context stack, optionally under a key using the double dash syntax.</p>\n<p>For example, if a <code>product</code> object exists in the current context, the <a href=\"/docs/api/batman.view_bindings.html#data-context\"><code>data-context</code></a> binding below will expose its attributes at the root level of the context:</p>\n<pre><code class=\"lang-html\">&lt;div data-context=<span class=\"string\">\"product\"</span>&gt;\n  &lt;span data-bind=<span class=\"string\">\"name\"</span>&gt;&lt;/span&gt;\n  &lt;span data-bind=<span class=\"string\">\"cost\"</span>&gt;&lt;/span&gt;\n&lt;/div&gt;</code></pre>\n<p>Contexts added to the stack can also be scoped under a key using <code>data-context-</code>:</p>\n<pre><code class=\"lang-html\">&lt;div data-context-currentProduct=<span class=\"string\">\"product\"</span>&gt;\n  &lt;span data-bind=<span class=\"string\">\"currentProduct\"</span>&gt;&lt;/span&gt;\n  &lt;span data-bind=<span class=\"string\">\"currentProduct\"</span>&gt;&lt;/span&gt;\n&lt;/div&gt;</code></pre>\n<p>This is a useful mechanism for passing local variables to partial views.</p>\n"
  - title: "data-event"
    tokens: []
    id: "data-event"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-event\"><code>data-event</code></a> bindings add DOM event listeners to the nodes they exist on which call the function found at the passed keypath. <a href=\"/docs/api/batman.view_bindings.html#data-event\"><code>data-event</code></a> bindings use the double dash syntax to specify the name of the event to listen for.</p>\n<p>In the HTML below, if the keypath <code>myFunction</code> resolves to a function, that function will be executed each time the <code>&lt;button&gt;</code> element is clicked.</p>\n<pre><code class=\"lang-html\">&lt;button data-event-click=<span class=\"string\">\"myFunction\"</span>&gt;Execute myFunction!&lt;/button&gt;</code></pre>\n<p>You can use <a href=\"/docs/api/batman.view_bindings.html#data-event\"><code>data-event</code></a> to execute controller actions without routing:</p>\n<pre><code class=\"lang-html\">&lt;!-- <span class=\"reserved\">with</span> beforeAction &amp; afterAction filters: --&gt;\n&lt;a data-event-click=<span class=\"string\">'controllers.items.executeAction | withArguments \"new\"'</span>&gt;Create a <span class=\"keyword\">new</span> item&lt;/a&gt;\n&lt;!-- <span class=\"keyword\">or</span>, skipping beforeAction &amp; afterAction filters: --&gt;\n&lt;a data-event-click=<span class=\"string\">\"controllers.items.new\"</span>&gt;Create a <span class=\"keyword\">new</span> item&lt;/a&gt;</code></pre>\n<p>Functions which <a href=\"/docs/api/batman.view_bindings.html#data-event\"><code>data-event</code></a> calls will be passed the node and the <code>DOMEvent</code> object: <code>(node, event) -&gt;</code>.</p>\n<p><a href=\"/docs/api/batman.view_bindings.html#data-event\"><code>data-event</code></a> supports the following types of events formally and should &quot;do the right thing&quot; when attached to elements which fire these events:</p>\n<ul>\n<li>click</li>\n<li>doubleclick</li>\n<li>change</li>\n<li>submit</li>\n</ul>\n<p>If the event name used doesn&#39;t match the above events, the event name used will just fall through and be passed to <code>window.addEventListener</code>.</p>\n"
  - title: "data-route"
    tokens: []
    id: "data-route"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a> bindings are used to dispatch a new controller action upon the clicking of the node they bind to. <a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a> expects to find either a string or a <code>NamedRouteQuery</code> at the keypath passed to it. With this route, it will add an event handler to the <code>click</code> action of the element which dispatches the route and prevents the default action of the DOMEvent. <a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a> will also populate the <code>href</code> attribute if it occurs on an <code>&lt;a&gt;</code> tag so that other functions like &quot;Copy Link Address&quot; and Alt+Click continue to work on the link.</p>\n<p>The first way to use <a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a> is by passing it a string, which can be built using filters or an accessor, but the preferred way is to use the <code>NamedRouteQuery</code>. These objects are generated for you by starting keypaths at the <code>App.routes</code> property. All <a href=\"/docs/api/batman.app.html\"><code>Batman.App</code></a>s have a <code>routes</code> property which holds a nested list of all the routes, which you descend into by passing various key segments and objects. Since the <code>App</code> object is present in the default context stack, <a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a> keypaths can just start with <code>routes</code>.</p>\n<p>For example, assume the following routes definition in the current <a href=\"/docs/api/batman.app.html\"><code>Batman.App</code></a>:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Alfred</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">App</span></span>\n  <span class=\"property\">@resources</span> <span class=\"string\">'todos'</span></code></pre>\n<p>This means that routes like <code>/todos</code> and <code>/todos/:id</code> exist. To route to the collection action, use the plural name of the resource:</p>\n<pre><code class=\"lang-html\">&lt;a data-route=<span class=\"string\">\"routes.todos\"</span>&gt;&lt;/a&gt;</code></pre>\n<p>To route to an individual todo things get a bit more complicated. If we have a Todo model with ID# <code>42</code> in the context as <code>todo</code>, use the <code>get</code> filter shorthand on the <code>NamedRouteQuery</code> returned by <code>routes.todos</code> to generate a member route:</p>\n<pre><code class=\"lang-html\">&lt;a data-route=<span class=\"string\">\"routes.todos[todo]\"</span>&gt;&lt;/a&gt;</code></pre>\n<p>Underneath, this is calling <code>Alfred.get(&#39;routes.todos&#39;).get(todo)</code>; the todo object is being passed as a key to the <code>NamedRouteQuery</code>, which knows how to generate a member route when given a record. The above HTML when rendered will look like this:</p>\n<pre><code class=\"lang-html\">&lt;a data-route=<span class=\"string\">\"routes.todos[todo]\"</span> href=<span class=\"string\">\"/todos/42\"</span>&gt;&lt;/a&gt;</code></pre>\n<p>This syntax can be extended to nested routes. If we have nested routes, we can use chained gets to generated nested routes</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tracker</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">App</span></span>\n  <span class=\"property\">@resources</span> <span class=\"string\">'villains'</span>, -&gt;\n    <span class=\"property\">@resources</span> <span class=\"string\">'crimes'</span></code></pre>\n<p>Routes for collection and member crimes should look like <code>/villains/:villain_id/crimes</code> and <code>/villains/:villain_id/crimes/:id</code> respectively. Assuming the presence of a <code>villain</code> and a <code>crime</code> in the context, chained <code>get</code>s on <code>NamedRouteQuery</code>s achieve this:</p>\n<pre><code class=\"lang-html\">&lt;!-- Collection <span class=\"keyword\">of</span> crimes <span class=\"keyword\">for</span> a particular villain --&gt;\n&lt;a data-route=<span class=\"string\">\"routes.villains[villain].crimes\"</span>&gt;&lt;/a&gt;\n&lt;!-- One crime <span class=\"keyword\">of</span> a particular villain --&gt;\n&lt;a data-route=<span class=\"string\">\"routes.villains[villain].crimes[crime]\"</span>&gt;&lt;/a&gt;</code></pre>\n<p><em>Note</em>: <a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a> bindings route only to internal dispatch, and not external links. Use a regular <code>&lt;a&gt;</code> tag to link away from the application.</p>\n"
  - title: "data-route-params"
    tokens: []
    id: "data-route-params"
    html: "<p>Adds the provided keypath or literal value to the route provided to <a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a>. For example:</p>\n<pre><code class=\"lang-html\">&lt;a data-route=<span class=\"string\">'routes.villians.new'</span> data-route-params=<span class=\"string\">'\"mastermind=true\"'</span>&gt;Mastermind&lt;/a&gt;</code></pre>\n<p>will route to <code>/villians/new?mastermind=true</code> and</p>\n<pre><code>&lt;a data-route=<span class=\"string\">'routes.villians.new'</span> data-route-params=<span class=\"string\">'otherRouteParams'</span>&gt;Other&lt;/a&gt;</code></pre>\n<p>will look up <code>otherRouteParams</code> and append it to <code>/villains/new</code>, adding a <code>?</code> if necessary.</p>\n"
  - title: "data-view"
    tokens: []
    id: "data-view"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a> bindings attach custom <a href=\"/docs/api/batman.view.html\"><code>Batman.View</code></a> instances or instantiate custom <code>View</code> subclasses to / on a node. <a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a> expects either a <a href=\"/docs/api/batman.view.html\"><code>Batman.View</code></a> instance or subclass at the keypath passed to it. If an instance is passed, it will <code>set</code> the <code>node</code> property of the view to the node the <a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a> occurs on. If a class is passed, that class will be instantiated with the context the <a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a> binding executed in and with the node it occurred upon. See <a href=\"/docs/api/batman.view.html\"><code>Batman.View</code></a> for more information on custom Views and their uses.</p>\n<p><em>Note</em>: <a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a> bindings will bind to the passed keypath until it exists, that is to say until the value of it is not <code>undefined</code>. After the <code>View</code> has been set up, the <a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a> binding will remove itself and stop observing the keypath.</p>\n"
  - title: "data-partial"
    tokens: []
    id: "data-partial"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-partial\"><code>data-partial</code></a> pulls in a partial template and renders it in the current context of the node the <a href=\"/docs/api/batman.view_bindings.html#data-partial\"><code>data-partial</code></a> occurs in. <a href=\"/docs/api/batman.view_bindings.html#data-partial\"><code>data-partial</code></a> expects the name of the view to render in the value of the HTML attribute. <strong>Warning</strong>: This value is not a keypath. The HTML attribute&#39;s value is interpreted as a string, and the template which resides at that view path will be rendered.</p>\n<p>If we have this HTML at <code>views/villains/_stub.html</code> in our app:</p>\n<pre><code class=\"lang-html\">&lt;span data-bind=<span class=\"string\">\"villain.name\"</span>&gt;&lt;/span&gt;</code></pre>\n<p>and in <code>views/villains/show.html</code> we have this HTML:</p>\n<pre><code class=\"lang-html\">&lt;h1&gt;A villain!&lt;/h1&gt;\n&lt;div data-partial=<span class=\"string\">\"villains/_stub\"</span>&gt;&lt;/div&gt;</code></pre>\n<p>the contents of the <code>stub</code> partial will be inserted and rendered in the <code>&lt;div&gt;</code> above.</p>\n"
  - title: "data-defineview"
    tokens: []
    id: "data-defineview"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-defineview\"><code>data-defineview</code></a> specifies that the content of the node defines the template for a particular view.</p>\n<p>The binding value should be a regular view path, i.e. &quot;#{resource_name}/#{controller_action}&quot;. For example:</p>\n<pre><code class=\"lang-html\">&lt;div data-defineview=<span class=\"string\">\"crimes/index\"</span>&gt;\n  &lt;ul class=<span class=\"string\">\"crimes\"</span>&gt;\n    &lt;li class=<span class=\"string\">\"crime\"</span> data-foreach-crime=<span class=\"string\">\"crimes\"</span>&gt;\n      &lt;span data-bind=<span class=\"string\">\"crime.name\"</span> data-addclass-heinous=<span class=\"string\">\"crime.heinous\"</span> /&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;</code></pre>\n<p>will be used by the <code>CrimesController</code>&#39;s  <code>index</code> action.</p>\n"
  - title: "data-renderif / data-deferif"
    tokens: []
    id: "data-renderif_%2F_data-deferif"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-renderif</code></a> (and <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-deferif</code></a>) defers parsing of a node&#39;s child bindings until its keypath updates to true (or false, respectively). Note that this does not prevent the node from being inserted into the DOM. These bindings should generally be combined with a <a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-showif</code></a> or <code>data-insertif</code> to prevent it from being visible until it is ready.</p>\n<p>Deferring rendering can help prevent portions of the page updating many times while data is being loaded. It can also allow you to prevent features that are not yet ready from being used.</p>\n"
  - title: "data-yield"
    tokens: []
    id: "data-yield"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-yield\"><code>data-yield</code></a> specifies that this node should be a render target for any view renderings that specify they should be rendered into a yield with this name. For example, <code>data-yield=&quot;myYieldNode&quot;</code> can be rendered into by using <code>new Batman.View(contentFor: &#39;myYieldNode&#39;)</code>. The special case of <code>data-yield=&quot;main&quot;</code> will be the render target for any view rendered by a controller action. This can mean the implicit render that happens by default at the end of a controller action or by explicitly calling <code>@render</code> inside a controller.</p>\n<p>You can also specify a render target inside your HTML using <a href=\"/docs/api/batman.view_bindings.html#data-contentfor\"><code>data-contentfor</code></a>.</p>\n<pre><code class=\"lang-html\">&lt;div data-yield=<span class=\"string\">\"main\"</span>&gt;&lt;/div&gt;</code></pre>\n"
  - title: "data-contentfor"
    tokens: []
    id: "data-contentfor"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-contentfor\"><code>data-contentfor</code></a> specifies that the content of this node should be rendered into a <code>yield</code> with the corresponding name.</p>\n<pre><code class=\"lang-html\">&lt;div data-contentfor=<span class=\"string\">\"header\"</span>&gt;&lt;h1 data-bind=<span class=\"string\">\"title\"</span>&gt;&lt;<span class=\"regexp\">/h1&gt;&lt;/</span>div&gt;\n&lt;div data-yield=<span class=\"string\">\"header\"</span>&gt;&lt;/div&gt;</code></pre>\n"
  - title: "data-track"
    tokens: []
    id: "data-track"
    html: "<p><a href=\"/docs/api/batman.view_bindings.html#data-track\"><code>data-track-#{viewOrClick}</code></a> fires events on an internal instance of a user-defined <code>MyApp.EventTracker</code> class. An <code>EventTracker</code> must respond to <code>track(viewOrClick, keypathValue, node)</code>, where:</p>\n<ul>\n<li><code>viewOrClick</code> is the binding attribute argument</li>\n<li><code>keypathValue</code> is the value of the keypath passed to the binding</li>\n<li><code>node</code> is the bound node.</li>\n</ul>\n<p>The node is considered <em>viewed</em> when the binding is initialized.</p>\n<p>Under the hood, batman.js will instantiate <code>MyApp.EventTracker</code> once, storing it at <code>Batman.Tracking.tracker</code>.</p>\n"
  - title: "data-debug"
    tokens: []
    id: "data-debug"
    html: "<p>Calls <code>debugger</code> when instantiating the binding. <code>DebuggerBinding</code> is removed from production builds of batman.js.</p>\n"
tokens: []
id: batman.view_bindings
html: "<p>See the <a href=\"/docs/bindings.html\">guide</a> for an overview of view bindings. All bindings take a keypath as an attribute value unless otherwise specified.</p>\n<table>\n<thead>\n<tr>\n<th>Binding</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind</code></a></td>\n<td>Binds <code>innerHTML</code> or input value. Great for all kinds of inputs.</td>\n<td><code>&lt;input type=&quot;checkbox&quot; data-bind=&quot;user.isAuthorized&quot; /&gt;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-bind\"><code>data-bind-#{attr}</code></a></td>\n<td>Binds node&#39;s <code>attr</code> to the keypath</td>\n<td><code>data-bind-id=&#39;post.id&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-source\"><code>data-source</code></a></td>\n<td><code>innerHTML</code> or value will get value from the keypath, but not set it</td>\n<td><code>&lt;p data-source=&quot;post.content&quot;&gt;&lt;/p&gt;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-source\"><code>data-source-#{attr}</code></a></td>\n<td>Node&#39;s <code>attr</code> will get its value from the keypath</td>\n<td><code>&lt;h1 data-source-id=&#39;post.id&#39;&gt;&lt;/h1&gt;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-target\"><code>data-target</code></a></td>\n<td>Changes to the node will set the keypath, but not get from the keypath</td>\n<td><code>&lt;input data-target=&#39;user.name&#39; /&gt;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-context\"><code>data-context-#{name}</code></a></td>\n<td>Makes keypath value accessible as <code>name</code> inside node</td>\n<td><code>data-context-lastcomment=&#39;mostRecentPost.comments.last&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-context\"><code>data-context</code></a></td>\n<td>Makes attributes of keypath directly accessible inside node</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-showif</code></a></td>\n<td>Shows node if keypath returns truthy</td>\n<td><code>data-showif=&#39;user.isAuthorized&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-hideif</code></a></td>\n<td>Hides node if keypath returns truthy</td>\n<td><code>data-hideif=&#39;post.alreadyPublished&#39;</code></td>\n</tr>\n<tr>\n<td><code>data-insertif</code></td>\n<td>The node will be present in the DOM if the keypath returns truthy</td>\n<td><code>data-insertif=&#39;post.isPublished&#39;</code></td>\n</tr>\n<tr>\n<td><code>data-removeif</code></td>\n<td>The node will be removed from the DOM if the keypath returns truthy</td>\n<td><code>data-removeif=&#39;comment.isNotAppropriate&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-renderif</code></a></td>\n<td>Node&#39;s contents will only be rendered if the keypath returns truthy</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-deferif</code></a></td>\n<td>Node&#39;s contents will only be rendered if the keypath returns falsey</td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a></td>\n<td>Takes a <code>Batman.NamedRouteQuery</code>. Clicking this node will route to the keypath.</td>\n<td><code>data-route=&#39;routes.posts[post].edit&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route-params</code></a></td>\n<td>Appends the keypath the route generated by a <a href=\"/docs/api/batman.view_bindings.html#data-route\"><code>data-route</code></a> on the node</td>\n<td>`data-route-params=&#39;myParamString&#39;</td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a></td>\n<td>Wraps the node in the view specified</td>\n<td><code>data-view=&#39;NavigatorView&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view-#{optionName}</code></a></td>\n<td>Passes keypath value to <a href=\"/docs/api/batman.view_bindings.html#data-view\"><code>data-view</code></a> as <code>optionName</code> (see <code>View.option</code>)</td>\n<td><code>data-view-user=&#39;currentUser&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-partial\"><code>data-partial</code></a></td>\n<td>Takes a <strong>string</strong>, renders the template with that path</td>\n<td><code>data-partial=&#39;posts/_form&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-defineview\"><code>data-defineview</code></a></td>\n<td>Wraps HTML which should be stored by <a href=\"/docs/api/batman.view.html\"><code>Batman.View</code></a></td>\n<td><code>data-defineview=&#39;posts/index&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-yield\"><code>data-yield</code></a></td>\n<td>Creates a named yield for the application</td>\n<td><code>data-yield=&#39;modal&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-contentfor\"><code>data-contentfor</code></a></td>\n<td>Wraps content for a non-default yield</td>\n<td><code>data-contentfor=&#39;modal&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-debug\"><code>data-debug</code></a></td>\n<td>Calls <code>debugger</code> when instantiating the binding</td>\n<td><code>data-debug=&quot;true&quot;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-event\"><code>data-event-#{eventName}</code></a></td>\n<td>Binds keypath value to <code>eventName</code> on this node</td>\n<td><code>data-event-click=&#39;notifyAllUsers&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-addclass-#{className}</code></a></td>\n<td>Adds class <code>className</code> if keypath returns truthy</td>\n<td><code>data-addclass-selected=&#39;item.selected&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#true\"><code>data-removeclass-#{className}</code></a></td>\n<td>Removes class <code>className</code> if keypath returns truthy</td>\n<td><code>data-removeclass-highlight=&#39;item.isPast&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-foreach\"><code>data-foreach-#{itemName}</code></a></td>\n<td>Make a copy of this node for each member in keypath; children accessible as <code>itemName</code></td>\n<td><code>data-foreach-item=&#39;myCollection&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-formfor\"><code>data-formfor-#{name}</code></a></td>\n<td>Inputs for keypath value will observe errors; keypath value aliased as <code>name</code></td>\n<td><code>data-formfor-comment=&#39;newComment&#39;</code></td>\n</tr>\n<tr>\n<td><code>data-style-#{styleAttrName}</code></td>\n<td>Bind the node&#39;s style attribute <code>styleAttrName</code> to the keypath value</td>\n<td><code>data-style-float=&#39;leftOrRight&#39;</code></td>\n</tr>\n<tr>\n<td><a href=\"/docs/api/batman.view_bindings.html#data-track\"><code>data-track-#{clickOrView}</code></a></td>\n<td>Track clicks or views on this node.</td>\n<td><code>data-track-view=&#39;logView&#39;</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"keypath-filters\">Keypath Filters</h4>\n<p>Binding keypaths may be passed through view filters. See the <a href=\"/docs/api/batman.view_filters.html\"><code>Batman.View Filters</code> documentation</a> for more information.</p>\n"

---

{{ page.html }}
<ul class="api-list">
{% for s in page.sub %}
  <li class="api-list-item">
    <h3 class="api-title">
      <a id="{{ s.id }}" class="anchor-target"></a>
      <a href="#{{ s.id }}" class="anchor-link">
      <span class="{% if s.meta %}monospace-heading{% endif %}">{% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}{% if s.meta.type == 'property' %}<span class="params">{{ s.meta.params }}</span>{% else %}<span class="params">({{ s.meta.params }})</span>  {% endif %}{% endif %}{% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}</span>
      </a>
    </h3>
    {{ s.html }}
  </li>
{% endfor %}
</ul>
