---
layout: api_docs
title: Batman
sub: 
  - title: container
    tokens: []
    id: container
    html: "<p><code>Batman.container</code> points to either the <code>window</code> object if running in the browser, or the <code>global</code> object if running in node. This is useful if you want to add something to the global scope in all environments.</p>\n"
  - title: typeOf
    tokens: []
    meta: 
      type: function
      level: class
      params: object
      returnType: string
    id: class_function_typeof
    html: "<p><code>typeOf</code> determines a more specific type of an <code>object</code> than the native <code>typeof</code> operator in JavaScript. This is useful for a number of situations like dealing with <code>Object</code> promoted strings and numbers, or arrays which look like <code>object</code>s to <code>typeof</code>. Use <code>typeOf</code> when you need more than <code>&quot;object&quot;</code> from <code>typeof</code>.</p>\n<p><em>Note</em>: <code>typeOf</code> is substantially slower than <code>typeof</code>. <code>typeOf</code> works in a somewhat hackish manner by getting the <code>Object::toString</code> representation of the object and slicing it to retrieve the name of the constructor.</p>\n<pre><code><span class=\"title\">test</span><span class=\"string\"> 'typeOf returns \"String\" for both strings and Object strings'</span>, -&gt;\n  primitive = <span class=\"string\">\"test\"</span>\n  objectified = new <span class=\"type\">String</span>(<span class=\"string\">\"test\"</span>)\n  equal <span class=\"typedef\">typeof primitive, \"string\"</span>\n  equal <span class=\"typedef\">typeof objectified, \"object\"</span>\n  equal <span class=\"type\">Batman</span>.<span class=\"typedef\">typeOf<span class=\"container\">(<span class=\"title\">primitive</span>)</span>, \"<span class=\"type\">String</span>\"</span>\n  equal <span class=\"type\">Batman</span>.<span class=\"typedef\">typeOf<span class=\"container\">(<span class=\"title\">objectified</span>)</span>, \"<span class=\"type\">String</span>\"</span>\n\n<span class=\"title\">test</span><span class=\"string\"> 'typeOf returns Array for arrays'</span>, -&gt;\n  array = [];\n  equal <span class=\"typedef\">typeof array, \"object\"</span>\n  equal <span class=\"type\">Batman</span>.<span class=\"typedef\">typeOf<span class=\"container\">(<span class=\"title\">array</span>)</span>, \"<span class=\"type\">Array</span>\"</span></code></pre>\n"
  - title: mixin
    tokens: []
    meta: 
      type: function
      level: class
      params: "subject, objects..."
      returnType: subject
    id: class_function_mixin
    html: "<p><code>mixin</code>, occasionally known elsewhere as <code>extend</code> or <code>merge</code>, flattens a series of objects onto the subject. Key/value pairs on objects passed as later arguments (arguments with a higher index) take precedence over earlier arguments. Returns the <code>subject</code> passed in with the new values.</p>\n<p><code>mixin</code> also has special properties that make it different than the canonical <code>extend</code> functions:</p>\n<ol>\n<li>If the <code>subject</code> has a <code>set</code> function, <code>subject.set(key, value)</code> will be used to apply keys instead of <code>subject[key] = value</code>. This means that if the subject is a <code>Batman.Object</code>, observers and thus bindings on the object will be notified when other (Batmanified or not) objects are mixed into it.</li>\n<li>If a mixed-in <code>object</code> has an <code>initialize</code> function defined, that function will be called and passed the <code>subject</code>. This is useful for custom extension logic, similar to <code>self.included</code> in Ruby. For this reason, the keys <code>initialize</code> and <code>uninitialize</code> are skipped by <code>mixin</code>.</li>\n<li><code>mixin</code> only iterates over keys for which the <code>hasOwnProperty</code> test passes.</li>\n</ol>\n<p><em>Note</em>: <code>mixin</code> is destructive to (only) the first argument. If you need a non-destructive version of <code>mixin</code>, just pass an empty object as the first object, and all keys from the successive arguments will be applied to the empty object.</p>\n<pre><code>test <span class=\"string\">'mixin merges argument objects'</span>, -&gt;\n  subject = {}\n  deepEqual <span class=\"class\">Batman</span>.mixin(subject, {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>}, {<span class=\"method\">fly:</span> <span class=\"keyword\">true</span>}, {<span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}), {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>, <span class=\"method\">fly:</span> <span class=\"keyword\">true</span>, <span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}, <span class=\"comment\">\"mixin returns the subject\"</span>\n  deepEqual subject, {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>, <span class=\"method\">fly:</span> <span class=\"keyword\">true</span>, <span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}, <span class=\"comment\">\"the subject is modified destructively\"</span>\n\ntest <span class=\"string\">'mixin merges argument objects'</span>, -&gt;\n  unmodified = {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>}\n  deepEqual <span class=\"class\">Batman</span>.mixin({}, unmodified, {<span class=\"method\">fly:</span> <span class=\"keyword\">true</span>}, {<span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}), {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>, <span class=\"method\">fly:</span> <span class=\"keyword\">true</span>, <span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}, <span class=\"comment\">\"mixin returns the subject\"</span>\n  deepEqual unmodified, {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>}, <span class=\"comment\">\"argument objects are untouched allowing non-destructive merge\"</span>\n\ntest <span class=\"string\">'mixed in objects passed as higher indexed arguments take precedence'</span>, -&gt;\n  subject = {}\n  deepEqual <span class=\"class\">Batman</span>.mixin(subject, {<span class=\"method\">x:</span> <span class=\"number\">1</span>, <span class=\"method\">y:</span> <span class=\"number\">1</span>}, {<span class=\"method\">x:</span> <span class=\"number\">2</span>}), {<span class=\"method\">x:</span> <span class=\"number\">2</span>, <span class=\"method\">y:</span> <span class=\"number\">1</span>}</code></pre>\n"
  - title: unmixin
    tokens: []
    meta: 
      type: function
      level: class
      params: "subject, objects..."
      returnType: subject
    id: class_function_unmixin
    html: "<p><code>unmixin</code> &quot;unmerges&quot; the passed objects from the <code>subject</code>. If a key exists on any of the <code>objects</code> it will be <code>delete</code>d from the <code>subject</code>. Returns the <code>subject</code>.</p>\n<p><code>unmixin</code>, similar to <code>mixin</code>, supports calling an <code>uninitialize</code> function for each of the <code>objects</code> being unmixed in. If an <code>uninitialize</code> function exists on each</p>\n<pre><code>test <span class=\"string\">'unmixin removes keys found on the unmixined objects on the subject'</span>, -&gt;\n  subject = {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>, <span class=\"method\">fly:</span> <span class=\"keyword\">true</span>, <span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}\n  deepEqual <span class=\"class\">Batman</span>.unmixin(subject, {<span class=\"method\">fit:</span> <span class=\"keyword\">true</span>}, {<span class=\"method\">fly:</span> <span class=\"keyword\">true</span>}), {<span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}, <span class=\"comment\">\"unmixin returns the subject\"</span>\n  deepEqual subject, {<span class=\"method\">funky:</span> <span class=\"keyword\">true</span>}, <span class=\"comment\">\"the subject is destructively modified.\"</span></code></pre>\n"
  - title: functionName
    tokens: []
    meta: 
      type: function
      level: class
      params: function
      returnType: string
    id: class_function_functionname
    html: "<p><code>functionName</code> returns the name of a given function, if any. Works with Internet Explorer 7/8/9, FireFox, Chrome, and Safari.</p>\n<pre><code>test 'functionName returns <span class=\"keyword\">the</span> <span class=\"property\">name</span> <span class=\"keyword\">of</span> a <span class=\"keyword\">given</span> function', -&gt;\n  <span class=\"keyword\">equal</span> Batman.functionName(<span class=\"string\">\"\"</span>.toString), 'toString'</code></pre>\n"
  - title: isChildOf
    tokens: []
    meta: 
      type: function
      level: class
      params: "parent : HTMLElement, child : HTMLElement"
      returnType: boolean
    id: class_function_ischildof
    html: "<p><code>isChildOf</code> is a simple DOM helper which returns a boolean describing if the passed <code>child</code> node can be found in the descendants of the passed <code>parent</code> node.</p>\n"
  - title: setImmediate
    tokens: []
    meta: 
      type: function
      level: class
      params: "callback : Function"
      returnType: object
    id: class_function_setimmediate
    html: "<p><code>setImmediate</code> (and its sister <code>clearImmediate</code>) are a more efficient version of <code>setTimeout(callback, 0)</code>. Due to timer resolution issues, setTimeout passed a timeout of 0 doesn&#39;t actually execute the function as soon as the JS execution stack has been emptied, but at minimum 4ms and maxmium 25ms after. For this reason Batman provides a cross browser implementation of <code>setImmediate</code> which does its best to call the callback immediately after the stack empties. Batman&#39;s <code>setImmediate</code> polyfill uses the native version if available, <code>window.postmessage</code> trickery if supported, and falls back on <code>setTimeout(-&gt;, 0)</code>.</p>\n<p><code>setImmediate</code> returns a handle which can be passed to <code>clearImmediate</code> to cancel the future calling of the callback.</p>\n"
  - title: clearImmediate
    tokens: []
    meta: 
      type: function
      level: class
      params: handle
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: class_function_clearimmediate
    html: "<p><code>clearImmediate</code> stops the calling of a callback in the future when passed its <code>handle</code> (which is returned from the <code>setImmediate</code> call used to enqueue it).</p>\n"
  - title: forEach
    tokens: []
    meta: 
      type: function
      level: class
      params: "iterable : object, iterator : Function[, context : Object]"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: class_function_foreach
    html: "<p>The <code>forEach</code> Batman helper is a universal iteration helper. When passed an <code>iterable</code> object, the helper will call the <code>iterator</code> (optionally in the <code>context</code>) for each item in the <code>iterable</code>. The <code>iterable</code> can be:</p>\n<ol>\n<li>something which has its own <code>forEach</code>, in which case the <code>iterator</code> will just be passed to <code>iterable.forEach</code>.</li>\n<li>an array like object, in which case a JavaScript <code>for(;;)</code> loop will be used to iterate over each entry</li>\n<li>or an object, in which case a JavaScript <code>for-in</code> loop will be used to iterate over each entry.</li>\n</ol>\n<p>The <code>forEach</code> helper is useful for iterating over objects when the type of those objects isn&#39;t guaranteed.</p>\n<pre><code>test <span class=\"comment\">'forEach iterates over objects with forEach defined', -&gt;</span>\n  results = []\n  <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Batman.SimpleSet(<span class=\"comment\">'a')</span>\n  Batman.forEach(<span class=\"keyword\">set</span>, (x) -&gt; results.push(x))\n  deepEqual results, [<span class=\"comment\">'a']</span>\n\ntest <span class=\"comment\">'forEach iterates over array like objects', -&gt;</span>\n  results = []\n  ArrayLike = -&gt;\n  ArrayLike:: = []\n  imitation = <span class=\"keyword\">new</span> ArrayLike\n  <span class=\"built_in\">Array</span>::push.<span class=\"keyword\">call</span>(imitation, <span class=\"string\">\"a\"</span>)\n  <span class=\"built_in\">Array</span>::push.<span class=\"keyword\">call</span>(imitation, <span class=\"string\">\"b\"</span>)\n  Batman.forEach(imitation, (x) -&gt; results.push(x))\n  deepEqual results, [<span class=\"comment\">'a', 'b']</span>\n\ntest <span class=\"comment\">'forEach iterates over objects', -&gt;</span>\n  result = {}\n  object = {x: <span class=\"literal\">true</span>}\n  Batman.forEach(object, (key, val) -&gt; result[key] = val)\n  deepEqual result, object</code></pre>\n"
  - title: objectHasKey
    tokens: []
    meta: 
      type: function
      level: class
      params: "object, key"
      returnType: boolean
    id: class_function_objecthaskey
    html: "<p><code>objectHasKey</code> returns a boolean describing the presence of the <code>key</code> in the passed <code>object</code>. <code>objectHasKey</code> delegates to the <code>object</code>&#39;s <code>hasKey</code> function if present, and otherwise just does a check using the JavaScript <code>in</code> operator.</p>\n<pre><code>test 'objectHasKey verifies <span class=\"keyword\">if</span> a key <span class=\"keyword\">is</span> present <span class=\"keyword\">in</span> an object', -&gt;\n  subject = {fit: <span class=\"constant\">true</span>}\n  ok Batman.objectHasKey(subject, 'fit')\n  <span class=\"keyword\">equal</span> Batman.objectHasKey(subject, 'flirty'), <span class=\"constant\">false</span>\n\ntest 'objectHasKey verifies <span class=\"keyword\">if</span> a key <span class=\"keyword\">is</span> present <span class=\"keyword\">in</span> an object <span class=\"keyword\">with</span> `hasKey` defined', -&gt;\n  subject = new Batman.SimpleHash {fit: <span class=\"constant\">true</span>}\n  ok Batman.objectHasKey(subject, 'fit')\n  <span class=\"keyword\">equal</span> Batman.objectHasKey(subject, 'flirty'), <span class=\"constant\">false</span></code></pre>\n"
  - title: contains
    tokens: []
    meta: 
      type: function
      level: class
      params: "object, item"
      returnType: boolean
    id: class_function_contains
    html: "<p><code>contains</code> returns a boolean describing if the given <code>object</code> has member <code>item</code>. Membership in this context is defined as:</p>\n<ul>\n<li>the result of <code>object.has(item)</code> if the <code>object</code> has a <code>has</code> function defined</li>\n<li>the result of <code>item in object</code> if the <code>object</code> is arraylike</li>\n<li>the result of the Batman.objectHasKey otherwise</li>\n</ul>\n<p><em>Note</em>: When passed an object without a <code>has</code> function, <code>contains</code> will return <code>true</code> if the <code>object</code> has <code>item</code> as a <em><code>key</code></em>, not as a value at any key.</p>\n<p><code>contains</code> is useful for checking item membership when the type of the object can&#39;t be relied on.</p>\n"
  - title: get
    tokens: []
    meta: 
      type: function
      level: class
      params: "object, key"
      returnType: value
    id: class_function_get
    html: "<p><code>get</code> is a general purpose function for retrieving the value from a <code>key</code> on an <code>object</code> of an indeterminate type. This is useful if code needs to work with both <code>Batman.Object</code>s and Plain Old JavaScript Objects. <code>get</code> has the following semantics:</p>\n<ul>\n<li>if the <code>object</code> has a <code>get</code> function defined, return the result of <code>object.get(key)</code></li>\n<li><p>if the object does not have a <code>get</code> function defined, use an ephemeral <code>Batman.Property</code> to retrieve the key. This is equivalent to <code>object[key]</code> for single segment <code>key</code>s, but if the <code>key</code> is multi-segment (example: &#39;product.customer.name&#39;), <code>get</code> will do nested gets until the either <code>undefined</code> or the end of the keypath is reached.</p>\n<p> test &#39;get returns the value at a key on a POJO&#39;, -&gt;\n   subject = {fit: true}\n   equal Batman.get(subject, &#39;fit&#39;), true\n   equal Batman.get(subject, &#39;flirty&#39;), undefined</p>\n<p> test &#39;get returns the value at a key on a Batman.Object&#39;, -&gt;\n   subject = Batman {fit: true}\n   equal Batman.get(subject, &#39;fit&#39;), true\n   equal Batman.get(subject, &#39;flirty&#39;), undefined</p>\n<p> test &#39;get returns the value at a deep key on a POJO&#39;, -&gt;\n   subject = {customer: {name: &quot;Joe&quot;}}\n   equal Batman.get(subject, &#39;customer.name&#39;), &quot;Joe&quot;\n   equal Batman.get(subject, &#39;customer.age&#39;), undefined</p>\n<p> test &#39;get returns the value at a deep key on a Batman.Object&#39;, -&gt;\n   subject = Batman {customer: {name: &quot;Joe&quot;}}\n   equal Batman.get(subject, &#39;customer.name&#39;), &quot;Joe&quot;\n   equal Batman.get(subject, &#39;customer.age&#39;), undefined</p>\n</li>\n</ul>\n"
  - title: getPath
    tokens: []
    meta: 
      type: function
      level: class
      params: "base, segments"
      returnType: string
    id: class_function_getpath
    html: "<p><code>getPath</code> returns the hash value denoted by the specified path, which consists of an array of nested hash keys. See examples below for more detail.</p>\n<pre><code>test <span class=\"string\">\"takes a base and an array of keys and returns the corresponding nested value\"</span>, -&gt;\n  @complexObject = <span class=\"keyword\">new</span> Batman.Object\n    hash: <span class=\"keyword\">new</span> Batman.Hash\n      foo: <span class=\"keyword\">new</span> Batman.Object(bar: <span class=\"attribute\">'nested</span> value'),\n      <span class=\"string\">\"foo.bar\"</span>: <span class=\"attribute\">'flat</span> value'\n  equal Batman.getPath(@complexObject, [<span class=\"attribute\">'hash</span>', <span class=\"attribute\">'foo</span>', <span class=\"attribute\">'bar</span>']), <span class=\"attribute\">'nested</span> value'\n  equal Batman.getPath(@complexObject, [<span class=\"attribute\">'hash</span>', <span class=\"attribute\">'foo</span>.bar']), <span class=\"attribute\">'flat</span> value'\n  strictEqual Batman.getPath(@complexObject, [<span class=\"attribute\">'hash</span>', <span class=\"attribute\">'not</span>-foo', <span class=\"attribute\">'bar</span>']), undefined\n\ntest <span class=\"string\">\"returns just the base if the key array is empty\"</span>, -&gt;\n  @complexObject = <span class=\"keyword\">new</span> Batman.Object\n    hash: <span class=\"keyword\">new</span> Batman.Hash\n      foo: <span class=\"keyword\">new</span> Batman.Object(bar: <span class=\"attribute\">'nested</span> value'),\n      <span class=\"string\">\"foo.bar\"</span>: <span class=\"attribute\">'flat</span> value'\n  strictEqual Batman.getPath(@complexObject, []), @complexObject\n  strictEqual Batman.getPath(<span class=\"keyword\">null</span>, []), <span class=\"keyword\">null</span>\n\ntest <span class=\"string\">\"returns undefined if the base is null-ish\"</span>, -&gt;\n  @complexObject = <span class=\"keyword\">new</span> Batman.Object\n    hash: <span class=\"keyword\">new</span> Batman.Hash\n      foo: <span class=\"keyword\">new</span> Batman.Object(bar: <span class=\"attribute\">'nested</span> value'),\n      <span class=\"string\">\"foo.bar\"</span>: <span class=\"attribute\">'flat</span> value'\n  strictEqual Batman.getPath(<span class=\"keyword\">null</span>, [<span class=\"attribute\">'foo</span>']), undefined\n  strictEqual Batman.getPath(undefined, [<span class=\"attribute\">'foo</span>']), undefined\n\ntest <span class=\"string\">\"returns falsy values\"</span>, -&gt;\n  @complexObject = <span class=\"keyword\">new</span> Batman.Object\n    hash: <span class=\"keyword\">new</span> Batman.Hash\n      foo: <span class=\"keyword\">new</span> Batman.Object(bar: <span class=\"attribute\">'nested</span> value'),\n      <span class=\"string\">\"foo.bar\"</span>: <span class=\"attribute\">'flat</span> value'\n  strictEqual Batman.getPath(num: <span class=\"number\">0</span>, [<span class=\"attribute\">'num</span>']), <span class=\"number\">0</span>\n  strictEqual Batman.getPath(thing: <span class=\"keyword\">null</span>, [<span class=\"attribute\">'thing</span>']), <span class=\"keyword\">null</span></code></pre>\n"
  - title: escapeHTML
    tokens: []
    meta: 
      type: function
      level: class
      params: input
      returnType: string
    id: class_function_escapehtml
    html: "<p><code>escapeHTML</code> takes a string of unknown origin and makes it safe for display on a web page by encoding control characters in HTML into their HTML entities.</p>\n<p><em>Warning</em>: Do not rely on <code>escapeHTML</code> to purge unsafe data from user submitted content. While <code>escapeHTML</code> is applied to every binding&#39;s contents by default, it should not be your only line of defence against script injection attacks.</p>\n<pre><code>test 'escapeHTML encodes special <span class=\"property\">characters</span> <span class=\"keyword\">into</span> HTML entities', -&gt;\n  <span class=\"keyword\">equal</span> Batman.escapeHTML(<span class=\"string\">\"&amp; &lt; &gt; \\\" '\"</span>), <span class=\"string\">\"&amp;amp; &amp;lt; &amp;gt; &amp;#34; &amp;#39;\"</span></code></pre>\n"
tokens: []
id: batman
html: "<p>Batman includes a number of useful, general purpose helper functions and references. They can all be found attached to the <code>Batman</code> object and can optionally be exported into the global namespace with a <code>$</code> prefix.</p>\n"

---

{{ page.html }}
{% for s in page.sub %}
  <h3>
    <a id="{{ s.id }}" class="anchor-target"></a>
    <a href="#{{ s.id }}" class="anchor-link">
    <span class="{% if s.meta %}monospace-heading{% endif %}">
      {% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}<span class="params">({{ s.meta.params }})</span>{% endif %}
      {% if s.meta.returnType %}<span class="return-type">: {{ s.meta.returnType }}</span>{% endif %}
    </span>
    </a>
  </h3>
  {{ s.html }}
{% endfor %}
