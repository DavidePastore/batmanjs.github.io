---
layout: api_docs
title: Batman.Set
sub: 
  - title: constructor(items...)
    tokens: []
    id: constructor(items...)
    html: "<p>When creating a <code>Set</code>, items forming the initial set can be passed as separate arguments to the constructor</p>\n<pre><code>test <span class=\"string\">'new Set constructor can be called without arguments'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set\n  deepEqual set.toArray(), []\n\ntest <span class=\"string\">'new Set constructor can be passed items to add to the set.'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  deepEqual set.toArray().sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</code></pre>\n"
  - title: "length : number"
    tokens: []
    id: "length_%3A_number"
    html: "<p>A count of the items in a <code>Set</code> can be found at its <code>length</code> property.</p>\n"
  - title: "isEmpty : boolean"
    tokens: []
    id: "isempty_%3A_boolean"
    html: "<p>Observable property for <code>isEmpty()</code></p>\n"
  - title: "toArray : Array"
    tokens: []
    id: "toarray_%3A_array"
    html: "<p>Observable property for <code>toArray()</code>. Whenever items are added or removed on the set, the <code>toArray</code> property will change. This is the mechanism by which Batman&#39;s view bindings get notified of collection updates.</p>\n<pre><code>test <span class=\"string\">'observers on the toArray property fire when the set changes'</span>, -&gt;\n  results = <span class=\"literal\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  set.observe(<span class=\"string\">'toArray'</span>, (newArray) -&gt; results = newArray.sort())\n  deepEqual set.add(<span class=\"string\">'d'</span>), [<span class=\"string\">'d'</span>]\n  deepEqual results, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]\n  deepEqual set.remove(<span class=\"string\">'b'</span>), [<span class=\"string\">'b'</span>]\n  deepEqual results, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]</code></pre>\n"
  - title: "has(item) : Boolean"
    tokens: []
    id: "has(item)_%3A_boolean"
    html: "<p><code>has</code> returns a boolean describing if the given <code>item</code> is a member of the set.</p>\n<p><em>Note</em>: Using <code>has(item)</code> in an accessor body will register the set <code>has</code> is called upon as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated, because the set may now have or not have the item in question.</p>\n<pre><code>test <span class=\"string\">'Set::has indicates if an item is a member of the set or not.'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  ok set.has(<span class=\"string\">'a'</span>)\n  equal set.has(<span class=\"string\">'d'</span>), <span class=\"literal\">false</span>\n\ntest <span class=\"string\">'Set::has registers the set as a source of an accessor'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Team</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    constructor: -&gt;\n      <span class=\"property\">@awards</span> = <span class=\"keyword\">new</span> Batman.Set()\n\n    <span class=\"property\">@accessor</span> <span class=\"string\">'bestEver?'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'awards'</span>).has(<span class=\"string\">'Stanley Cup'</span>)\n\n  result = <span class=\"literal\">null</span>\n  team = <span class=\"keyword\">new</span> Team\n  team.observeAndFire <span class=\"string\">'bestEver?'</span>, (status) -&gt; result = status\n  team.get(<span class=\"string\">'awards'</span>).add <span class=\"string\">'Eastern Conference Champs'</span>\n  equal result, <span class=\"literal\">false</span>\n  team.get(<span class=\"string\">'awards'</span>).add <span class=\"string\">'Stanley Cup'</span>\n  equal result, <span class=\"literal\">true</span></code></pre>\n"
  - title: add(items...)
    tokens: []
    id: add(items...)
    html: "<p><code>add</code> adds 0 or more new items to the set. <code>add</code> returns an array of the items which have been newly added to the set, which is to say the intersection of the argument items and the set&#39;s complement before addition.</p>\n<p><code>add</code> fires the <code>itemsWereAdded</code> event with the list of items newly added to the set if that list has length greater than 0. This is to say the event will not be fired if the items passed to add were all already members of the set.</p>\n<pre><code>test <span class=\"string\">'Set::add adds an item to the set'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set()\n  equal set.has(<span class=\"string\">'a'</span>), <span class=\"literal\">false</span>\n  deepEqual set.add(<span class=\"string\">'a'</span>), [<span class=\"string\">'a'</span>]\n  equal set.has(<span class=\"string\">'a'</span>), <span class=\"literal\">true</span>\n\ntest <span class=\"string\">'Set::add returns only the new items that weren\\'t previously in the set'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  deepEqual set.add(<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>).sort(), [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]\n  deepEqual set.toArray().sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]\n\ntest <span class=\"string\">'Set::add fires the itemsWereAdded event with the items newly added to the set'</span>, -&gt;\n  results = <span class=\"literal\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  set.<span class=\"literal\">on</span>(<span class=\"string\">'itemsWereAdded'</span>, (item) -&gt; results = item)\n  set.add(<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>)\n  deepEqual results.sort(), [<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>]\n\ntest <span class=\"string\">'Set::add does not fire the itemsWereAdded event if the added items were already in the set.'</span>, -&gt;\n  results = <span class=\"literal\">undefined</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  set.<span class=\"literal\">on</span>(<span class=\"string\">'itemsWereAdded'</span>, (items) -&gt; results = items)\n  set.add(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  equal <span class=\"keyword\">typeof</span> results, <span class=\"string\">'undefined'</span></code></pre>\n"
  - title: remove(items...)
    tokens: []
    id: remove(items...)
    html: "<p><code>remove</code> removes 0 or more items from the set. <code>remove</code> returns an array of the items which were successfully removed from the set, which is to say the intersection of the argument items and the set itself before removal.</p>\n<p><code>remove</code> fires the <code>itemsWereRemoved</code> event with the list of removed items if that list has length greater than 0. This is to say the event will not be fired if none of the passed items were members of the set.</p>\n<pre><code>test <span class=\"string\">'Set::remove removes an item from the set'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>)\n  equal set.has(<span class=\"string\">'a'</span>), <span class=\"literal\">true</span>\n  deepEqual set.remove(<span class=\"string\">'a'</span>), [<span class=\"string\">'a'</span>]\n  equal set.has(<span class=\"string\">'a'</span>), <span class=\"literal\">false</span>\n\ntest <span class=\"string\">'Set::remove returns only the new items that were previously in the set'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  deepEqual set.remove(<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>,<span class=\"string\">'d'</span>).sort(), [<span class=\"string\">'b'</span>]\n  deepEqual set.toArray(), [<span class=\"string\">'a'</span>]\n\ntest <span class=\"string\">'Set::remove fires the itemsWereRemoved event with the items removed to the set'</span>, -&gt;\n  results = <span class=\"literal\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  set.<span class=\"literal\">on</span>(<span class=\"string\">'itemsWereRemoved'</span>, (items) -&gt; results = items)\n  set.remove(<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>)\n  deepEqual results.sort(), [<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>]\n\ntest <span class=\"string\">'Set::remove does not fire the itemsWereRemoved event if the removed items were not already members of the set.'</span>, -&gt;\n  results = <span class=\"literal\">undefined</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)\n  set.<span class=\"literal\">on</span>(<span class=\"string\">'itemsWereRemoved'</span>, (items) -&gt; results = items)\n  set.remove(<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>)\n  equal <span class=\"keyword\">typeof</span> results, <span class=\"string\">'undefined'</span></code></pre>\n"
  - title: "find(testFunction : function) : [Object]"
    tokens: []
    id: "find(testfunction_%3A_function)_%3A_%5Bobject%5D"
    html: "<p><code>find</code> returns the first item within the set for which the <code>testFunction</code> called with the item returns <code>true</code>, or <code>undefined</code> if no item passes the test.</p>\n<p><em>Note</em>: <code>find</code> returns the first item the test passes for, but since set iteration has no specified order, no guarantee can be made about which item will be returned if more than one item in the set passes the test. However, set iteration order is stable, so <code>find</code> called on the same set twice should return the same item.</p>\n<pre><code>test <span class=\"string\">'Set::find returns the first item for which the test function passes'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  equal set.find((x) -&gt; x % <span class=\"number\">2</span> == <span class=\"number\">0</span>), <span class=\"number\">2</span>\n\ntest <span class=\"string\">'Set::find returns undefined if no items pass the test function'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)\n  equal <span class=\"keyword\">typeof</span> set.find((x) -&gt; x &gt; <span class=\"number\">5</span>), <span class=\"string\">'undefined'</span></code></pre>\n"
  - title: "forEach(iteratorFunction : function[, context: Object])"
    tokens: []
    id: "foreach(iteratorfunction_%3A_function%5B%2C_context%3A_object%5D)"
    html: "<p><code>forEach</code> calls the <code>iteratorFunction</code> with each item in the set, optionally executing the <code>iteratorFunction</code> in the passed context. Returns <code>undefined</code>.</p>\n<p><em>Note</em>: Set iteration order is not defined, thus Set client code cannot rely on one item being iterated over before another, regardless of when the Set&#39;s items were added. If you need an ordered set, Batman provides <code>SetSort</code> for exactly this, while including the added benefit of observability. If you need a one time ordering of a set, you can get the array representation with <code>toArray</code> and then use vanilla JavaScript <code>sort</code> on that array.</p>\n<p><em>Note</em>: Using <code>forEach()</code> in an accessor body will register the set iterated over as a source of the property being calculated. This so that whenever the set changes, the property will be recalculated. This can become an issue if you iterate over a set and modify the set&#39;s items, as when the property recalculates that modification will potentially happen on items it&#39;s happened on previously.</p>\n<pre><code>test <span class=\"string\">'Set::forEach iterates over each item in the set'</span>, -&gt;\n  sum = <span class=\"number\">0</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)\n  set.forEach (x) -&gt; sum += x\n  equal sum, <span class=\"number\">6</span>\n\ntest <span class=\"string\">'Set::forEach iterates over each item in the set optionally in the provided context'</span>, -&gt;\n  context = {sum: <span class=\"number\">0</span>}\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)\n  set.forEach((x) -&gt;\n    <span class=\"property\">@sum</span> += x\n  , context)\n  equal context.sum, <span class=\"number\">6</span>\n\ntest <span class=\"string\">'Set::forEach registers the set as a source if called in an accessor body'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Team</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    constructor: -&gt;\n      <span class=\"property\">@players</span> = <span class=\"keyword\">new</span> Batman.Set()\n    <span class=\"property\">@accessor</span> <span class=\"string\">'willWinTheCup?'</span>, -&gt;\n      sedinCount = <span class=\"number\">0</span>\n      <span class=\"property\">@players</span>.forEach (player) -&gt;\n        sedinCount++ <span class=\"keyword\">if</span> player.split(<span class=\"string\">' '</span>)[<span class=\"number\">1</span>] == <span class=\"string\">'Sedin'</span>\n      sedinCount &gt;= <span class=\"number\">2</span>\n\n  result = <span class=\"literal\">null</span>\n  team = <span class=\"keyword\">new</span> Team()\n  team.observeAndFire <span class=\"string\">'willWinTheCup?'</span>, (status) -&gt; result = status\n  equal team.get(<span class=\"string\">'willWinTheCup?'</span>), <span class=\"literal\">false</span>\n  team.get(<span class=\"string\">'players'</span>).add <span class=\"string\">'Henrik Sedin'</span>\n  equal result, <span class=\"literal\">false</span>\n  team.get(<span class=\"string\">'players'</span>).add <span class=\"string\">'Daniel Sedin'</span>\n  equal result, <span class=\"literal\">true</span></code></pre>\n"
  - title: "isEmpty() : boolean"
    tokens: []
    id: "isempty()_%3A_boolean"
    html: "<p><code>isEmpty</code> returns a boolean: <code>true</code> if the set has no items, and <code>false</code> if it has any items.</p>\n<p><em>Note</em>: Using <code>isEmpty()</code> in an accessor body will register the set <code>isEmpty</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.</p>\n<pre><code>test <span class=\"string\">'Set::isEmpty returns true if the set has no items'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set()\n  ok set.isEmpty()\n  set.add(<span class=\"string\">'a'</span>)\n  equal set.isEmpty(), <span class=\"literal\">false</span>\n\ntest <span class=\"string\">'Set::isEmpty registers the set as a source of an accessor'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Team</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    constructor: -&gt;\n      <span class=\"property\">@games</span> = <span class=\"keyword\">new</span> Batman.Set()\n    <span class=\"property\">@accessor</span> <span class=\"string\">'seasonStarted?'</span>, -&gt; !<span class=\"property\">@games</span>.isEmpty()\n\n  team = <span class=\"keyword\">new</span> Team\n  equal team.get(<span class=\"string\">'seasonStarted?'</span>), <span class=\"literal\">false</span>\n  team.get(<span class=\"string\">'games'</span>).add({win: <span class=\"literal\">true</span>})\n  equal team.get(<span class=\"string\">'seasonStarted?'</span>), <span class=\"literal\">true</span></code></pre>\n"
  - title: "clear() : Array"
    tokens: []
    id: "clear()_%3A_array"
    html: "<p><code>clear</code> removes all items from a set. Returns an array of all the items in the set.</p>\n<p><code>clear</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set.</p>\n<p><em>Note</em>: Set iteration order is not defined, so the order of the array of items returned by <code>clear</code> is undefined.</p>\n<pre><code>test <span class=\"string\">'Set::clear empties the set'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  equal set.isEmpty(), <span class=\"literal\">false</span>\n  deepEqual set.clear().sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]\n  ok set.isEmpty()\n\ntest <span class=\"string\">'Set::clear fires the itemsWereRemoved event with all the items in the set'</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  set.<span class=\"literal\">on</span>(<span class=\"string\">'itemsWereRemoved'</span>, (items) -&gt; result = items)\n  set.clear()\n  deepEqual result.sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</code></pre>\n"
  - title: "replace(collection : Enumerable) : Array"
    tokens: []
    id: "replace(collection_%3A_enumerable)_%3A_array"
    html: "<p><code>replace</code> removes all the items in a set and then adds all the items found in another <code>collection</code>. The other collection must have a <code>toArray</code> function which returns an array representation of the collection. Returns the array of items added.</p>\n<p><code>replace</code> will fire the <code>itemsWereRemoved</code> event once with all the items in the set, and then the <code>itemsWereAdded</code> event once with the items from the incoming collection.</p>\n<pre><code>test <span class=\"string\">'Set::replace empties the set and then adds items from a different collection'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  secondSet = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>)\n  set.replace(secondSet)\n  deepEqual set.toArray().sort(), [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>]\n\ntest <span class=\"string\">'Set::replace fires the itemsWereRemoved event with all the items in the set'</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  set.<span class=\"literal\">on</span>(<span class=\"string\">'itemsWereRemoved'</span>, (items) -&gt; result = items)\n  set.replace(<span class=\"keyword\">new</span> Batman.SimpleSet())\n  deepEqual result.sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]\n\ntest <span class=\"string\">'Set::replace fires the itemsWereAdded event with all the items in the incoming set'</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  set = <span class=\"keyword\">new</span> Batman.Set()\n  set.<span class=\"literal\">on</span>(<span class=\"string\">'itemsWereAdded'</span>, (items) -&gt; result = items)\n  set.replace(<span class=\"keyword\">new</span> Batman.SimpleSet(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>))\n  deepEqual result.sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</code></pre>\n"
  - title: "toArray() : Array"
    tokens: []
    id: "toarray()_%3A_array"
    html: "<p><code>toArray</code> returns an array representation of the set.</p>\n<p><em>Note</em>: Set iteration order is not defined, so the order in which the set&#39;s items appear in the array is not defined. It is however stable, so the order of the items in two successive <code>toArray</code> calls where the set was not modified in between should be the same.</p>\n<p><em>Note</em>: <code>toArray</code> is also an observable property.</p>\n<p><em>Note</em>: Using <code>toArray()</code> in an accessor body will register the set <code>toArray</code> is called on as a source of the property being calculated, so that whenever the set changes the property will be recalculated.</p>\n<pre><code>test <span class=\"string\">'Set::toArray returns an array representation of the set'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set()\n  deepEqual set.toArray(), []\n  set.add(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  deepEqual set.toArray().sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</code></pre>\n"
  - title: "merge(collections... : Enumerable) : Set"
    tokens: []
    id: "merge(collections..._%3A_enumerable)_%3A_set"
    html: "<p><code>merge</code> adds all the items in a set and all the items in the passed <code>collections</code> to a new set and returns it. A <code>collection</code> is an object which has a <code>forEach</code> function. <code>merge</code> is a non-destructive collection union, so the set <code>merge</code> is called on and each <code>collection</code> passed to <code>merge</code> are unaffected by the call.</p>\n<p><em>Note</em>: Be careful about using <code>merge</code> within accessors. Calling <code>merge</code> in an accessor function body will register the set <code>merge</code> is called upon as a source of the property being calculated, which means when the set changes, that accessor will be recalculated. This means the O(n * m) merge will occur again each time, and return an entirely new <code>Set</code> instance. If the previously returned <code>Set</code> instance is retained after recalculation, this is a big memory leak. Instead of merging in accessors, try to use a <code>SetUnion</code> or a <code>SetIntersection</code>.</p>\n<pre><code>test <span class=\"string\">'Set::merge returns a new set with the items of the original set and the passed set'</span>, -&gt;\n  abc = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)\n  def = <span class=\"keyword\">new</span> Batman.Set(<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>)\n  equal Batman.typeOf(set = abc.merge(def)), <span class=\"string\">'Object'</span>\n  deepEqual set.toArray().sort(), [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>]</code></pre>\n"
  - title: "indexedBy(key : String) : SetIndex"
    tokens: []
    id: "indexedby(key_%3A_string)_%3A_setindex"
    html: "<p><code>indexedBy</code> returns a hash of sets which buckets all the items in the callee set by the value of a particular <code>key</code>. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to a set of the items with that value at the <code>key</code> is built. This hash of sets is a smart object called a <code>SetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the set index remains up to date. <code>SetIndex</code> also has a friend named <code>UniqueSetIndex</code> which will give you a hash of items instead of a hash of sets with items for easy access if you know each item&#39;s value at the <code>key</code> is unique.</p>\n<pre><code>test <span class=\"string\">'Set::indexedBy returns a new SetIndex with the items bucketed by the value of the key'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(colour: <span class=\"string\">'blue'</span>), Batman(colour: <span class=\"string\">'green'</span>), Batman(colour: <span class=\"string\">'blue'</span>))\n  index = set.indexedBy(<span class=\"string\">'colour'</span>)\n  ok index.get(<span class=\"string\">'blue'</span>) <span class=\"keyword\">instanceof</span> Batman.Set\n  equal index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">2</span>\n  equal index.get(<span class=\"string\">'green'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">1</span>\n\ntest <span class=\"string\">'Set::indexedBy returns a new SetIndex which observes the set for new additions and stays up to date'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(colour: <span class=\"string\">'blue'</span>), Batman(colour: <span class=\"string\">'green'</span>))\n  index = set.indexedBy(<span class=\"string\">'colour'</span>)\n  equal index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">1</span>\n  newItem = Batman(colour: <span class=\"string\">'blue'</span>)\n  set.add(newItem)\n  equal index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">2</span>\n  ok index.get(<span class=\"string\">'blue'</span>).has(newItem)\n  set.remove(newItem)\n  equal index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">1</span>\n\ntest <span class=\"string\">'Set::indexedBy returns a new SetIndex which observes the items in the set for changes to the observed key'</span>, -&gt;\n  itemA = Batman(colour: <span class=\"string\">'blue'</span>)\n  itemB = Batman(colour: <span class=\"string\">'green'</span>)\n  set = <span class=\"keyword\">new</span> Batman.Set(itemA, itemB)\n  index = set.indexedBy(<span class=\"string\">'colour'</span>)\n  equal index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">1</span>\n  equal index.get(<span class=\"string\">'green'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">1</span>\n  itemA.set(<span class=\"string\">'colour'</span>, <span class=\"string\">'green'</span>)\n  equal index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">0</span>\n  equal index.get(<span class=\"string\">'green'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">2</span></code></pre>\n<p><code>SetIndex</code>es can be created by calling the <code>indexedBy</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedBy</code> property.</p>\n<pre><code>test <span class=\"string\">\"Set::get('indexedBy.someKey') returns a new SetIndex for 'someKey'\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(colour: <span class=\"string\">'blue'</span>), Batman(colour: <span class=\"string\">'green'</span>))\n  index = set.get(<span class=\"string\">'indexedBy.colour'</span>)\n  equal index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'length'</span>), <span class=\"number\">1</span></code></pre>\n"
  - title: "indexedByUnique(key : String) : UniqueSetIndex"
    tokens: []
    id: "indexedbyunique(key_%3A_string)_%3A_uniquesetindex"
    html: "<p><code>indexedByUnique</code> returns a hash of items keyed by the value of the given <code>key</code> on each item from the callee set. The value of the passed <code>key</code> is <code>get</code>ted from each object in the set, and then a hash of each value to an item with that value at the <code>key</code> is built. This hash of items is a smart object called a <code>UniqueSetIndex</code> which will continue to observe the set and the value of the <code>key</code> on each item in the set to ensure the index remains up to date. Note that the semantics for which item ends up in the hash if two items have the same value for the <code>key</code> are undefined, so it is wise to only use <code>UniqueSetIndex</code>es on keys who&#39;s values are going to be unique in the set. If the values are not going to be unique, you may be interested in <code>SetIndex</code> and <code>Set::indexedBy</code>.</p>\n<pre><code>test <span class=\"string\">'Set::indexedByUnique returns a new UniqueSetIndex with the items hashed by the value of the key'</span>, -&gt;\n  greenItem = Batman(colour: <span class=\"string\">'green'</span>)\n  blueItem = Batman(colour: <span class=\"string\">'blue'</span>)\n  set = <span class=\"keyword\">new</span> Batman.Set(greenItem, blueItem)\n  index = set.indexedByUnique(<span class=\"string\">'colour'</span>)\n  ok blueItem == index.get(<span class=\"string\">'blue'</span>)\n  ok greenItem == index.get(<span class=\"string\">'green'</span>)\n  equal <span class=\"literal\">undefined</span>, index.get(<span class=\"string\">'red'</span>)\n\ntest <span class=\"string\">'Set::indexedByUnique returns a new UniqueSetIndex which observes the set for new additions and stays up to date'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(colour: <span class=\"string\">'blue'</span>), Batman(colour: <span class=\"string\">'green'</span>))\n  index = set.indexedByUnique(<span class=\"string\">'colour'</span>)\n  newItem = Batman(colour: <span class=\"string\">'red'</span>)\n  set.add(newItem)\n  ok newItem == index.get(<span class=\"string\">'red'</span>)\n  set.remove(newItem)\n  equal <span class=\"literal\">undefined</span>, index.get(<span class=\"string\">'red'</span>)\n\ntest <span class=\"string\">'Set::indexedByUnique returns a new UniqueSetIndex which observes the items in the set for changes to the observed key'</span>, -&gt;\n  itemA = Batman(colour: <span class=\"string\">'blue'</span>)\n  itemB = Batman(colour: <span class=\"string\">'green'</span>)\n  set = <span class=\"keyword\">new</span> Batman.Set(itemA, itemB)\n  index = set.indexedByUnique(<span class=\"string\">'colour'</span>)\n  equal index.get(<span class=\"string\">'blue'</span>)?, <span class=\"literal\">true</span>\n  equal index.get(<span class=\"string\">'green'</span>)?, <span class=\"literal\">true</span>\n  equal index.get(<span class=\"string\">'red'</span>)?, <span class=\"literal\">false</span>\n  itemA.set(<span class=\"string\">'colour'</span>, <span class=\"string\">'red'</span>)\n  equal index.get(<span class=\"string\">'blue'</span>)?, <span class=\"literal\">false</span>\n  equal index.get(<span class=\"string\">'green'</span>)?, <span class=\"literal\">true</span>\n  equal index.get(<span class=\"string\">'red'</span>)?, <span class=\"literal\">true</span></code></pre>\n<p><code>UniqueSetIndex</code>es can be created by calling the <code>indexedByUnique</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>indexedByUnique</code> property.</p>\n<pre><code>test <span class=\"string\">\"Set::get('indexedByUnique.someKey') returns a new UniqueSetIndex for 'someKey'\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(colour: <span class=\"string\">'blue'</span>), Batman(colour: <span class=\"string\">'green'</span>))\n  index = set.get(<span class=\"string\">'indexedByUnique.colour'</span>)\n  equal <span class=\"string\">'blue'</span>, index.get(<span class=\"string\">'blue'</span>).get(<span class=\"string\">'colour'</span>)</code></pre>\n"
  - title: "sortedBy(key: String [, order: String]) : SetSort"
    tokens: []
    id: "sortedby(key%3A_string_%5B%2C_order%3A_string%5D)_%3A_setsort"
    html: "<p><code>sortedBy</code> returns a <code>Set</code> like object containing all the items of the callee set but with a defined iteration order (unlike <code>Set</code>). The iteration order is defined as the alpha numeric sorting of the values of the passed <code>key</code> gotten from each item. The direction of the sort can be controlled with the <code>order</code> argument, which defaults to <code>asc</code> (short for ascending) or can be passed as <code>desc</code> (short for descending). This <code>Set</code> like object is a <code>SetSort</code> which encapsulates the logic to get the values from each item at the passed <code>key</code> and traverse the <code>Set</code> in the values sorted order.</p>\n<p><code>SetSort</code>s are useful for getting a transform of a <code>Set</code> which sorted, but also because the sort stays up to date as items are added or removed to the sorted set, or the value at the <code>key</code> changes on any of the items in the set.</p>\n<pre><code>test <span class=\"string\">'Set::sortedBy returns a new SetSort who can be iterated in the sorted order of the value of the key on each item'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(place: <span class=\"number\">3</span>, name: <span class=\"string\">'Harry'</span>), Batman(place: <span class=\"number\">1</span>, name: <span class=\"string\">'Tom'</span>), Batman(place: <span class=\"number\">2</span>, name: <span class=\"string\">'Camilo'</span>))\n  sort = set.sortedBy(<span class=\"string\">'place'</span>)\n  deepEqual sort.toArray().map((item) -&gt; item.get(<span class=\"string\">'name'</span>)), [<span class=\"string\">'Tom'</span>, <span class=\"string\">'Camilo'</span>, <span class=\"string\">'Harry'</span>]\n\ntest <span class=\"string\">'Set::sortedBy returns a new SetSort which observes the callee set for additions or removals and puts new items in the sorted order'</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(place: <span class=\"number\">3</span>, name: <span class=\"string\">'Harry'</span>), Batman(place: <span class=\"number\">1</span>, name: <span class=\"string\">'Tom'</span>), Batman(place: <span class=\"number\">2</span>, name: <span class=\"string\">'Camilo'</span>))\n  sort = set.sortedBy(<span class=\"string\">'place'</span>)\n  deepEqual sort.toArray().map((item) -&gt; item.get(<span class=\"string\">'name'</span>)), [<span class=\"string\">'Tom'</span>, <span class=\"string\">'Camilo'</span>, <span class=\"string\">'Harry'</span>]\n  burke = Batman(place: <span class=\"number\">1.5</span>, name: <span class=\"string\">'Burke'</span>)\n  set.add(burke)\n  deepEqual sort.toArray().map((item) -&gt; item.get(<span class=\"string\">'name'</span>)), [<span class=\"string\">'Tom'</span>, <span class=\"string\">'Burke'</span>, <span class=\"string\">'Camilo'</span>, <span class=\"string\">'Harry'</span>]\n\ntest <span class=\"string\">'Set::sortedBy returns a new SetSort which observes each item in the callee set for changes to the sort key'</span>, -&gt;\n  harry = Batman(place: <span class=\"number\">2</span>, name: <span class=\"string\">'Harry'</span>)\n  tom = Batman(place: <span class=\"number\">1</span>, name: <span class=\"string\">'Tom'</span>)\n  set = <span class=\"keyword\">new</span> Batman.Set(harry, tom)\n  sort = set.sortedBy(<span class=\"string\">'place'</span>)\n  deepEqual sort.toArray().map((item) -&gt; item.get(<span class=\"string\">'name'</span>)), [<span class=\"string\">'Tom'</span>, <span class=\"string\">'Harry'</span>]\n  tom.set(<span class=\"string\">'place'</span>, <span class=\"number\">3</span>)\n  deepEqual sort.toArray().map((item) -&gt; item.get(<span class=\"string\">'name'</span>)), [<span class=\"string\">'Harry'</span>, <span class=\"string\">'Tom'</span>]</code></pre>\n<p><code>SetSort</code>s can be created by calling the <code>sortedBy</code> function on the <code>Set</code>, as well as by <code>get</code>ting a <code>key</code> on the <code>sortedBy</code> property. Note that with this instantiation form you can&#39;t pass an order to the <code>SetSort</code>.</p>\n<pre><code>test <span class=\"string\">\"Set::get('sortedBy.someKey') returns a new SetSort onn 'someKey'\"</span>, -&gt;\n  set = <span class=\"keyword\">new</span> Batman.Set(Batman(place: <span class=\"number\">3</span>, name: <span class=\"string\">'Harry'</span>), Batman(place: <span class=\"number\">1</span>, name: <span class=\"string\">'Tom'</span>), Batman(place: <span class=\"number\">2</span>, name: <span class=\"string\">'Camilo'</span>))\n  sort = set.get(<span class=\"string\">'sortedBy.place'</span>)\n  equal <span class=\"string\">'Harry'</span>, sort.get(<span class=\"string\">'toArray'</span>)[<span class=\"number\">2</span>].get(<span class=\"string\">'name'</span>)</code></pre>\n"
tokens: []
id: batman.set
html: "<p><code>Set</code> is an observable, <code>Batman.Object</code> wrapper around <code>SimpleSet</code>.</p>\n<h3>SimpleSet vs Set</h3>\n<p><code>SimpleSet</code> and <code>Set</code> are two distinct classes in Batman. <code>SimpleSet</code> implements the basic set semantics, but it is <em>not</em> a <code>Batman.Object</code>, so properties on it (like its <code>length</code> or <code>toArray</code>) cannot be bound. <code>Set</code> is a <code>Batman.Object</code>, so it can be observed, and thus plays nicely with the accessor system. Use a <code>SimpleSet</code> only when you know nothing will need to be observed on the set you are creating, which usually isn&#39;t a valid assumption. If it is in fact valid, consider using a native array as well, as iteration and membership checks will be faster.</p>\n"

---

{{ page.html }}
<ul class="api-list">
{% for s in page.sub %}
  <li class="api-list-item">
    <h3 class="api-title">
      <a id="{{ s.id }}" class="anchor-target"></a>
      <a href="#{{ s.id }}" class="anchor-link">
      <span class="{% if s.meta %}monospace-heading{% endif %}">{% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}{% if s.meta.type == 'property' %}<span class="params">{{ s.meta.params }}</span>{% else %}<span class="params">({{ s.meta.params }})</span>  {% endif %}{% endif %}{% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}</span>
      </a>
    </h3>
    {{ s.html }}
  </li>
{% endfor %}
</ul>
