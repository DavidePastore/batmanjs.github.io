---
layout: api_docs
title: Batman.Object Accessors
meta: 
  grouping: Data Structures
  parent: Batman.Object
sub: 
  - title: Accessors as Computed Properties
    tokens: []
    id: accessors_as_computed_properties
    html: "<p>You can define transforms on properties which automatically update when their sources change. For example, you might want to truncate a potentially long piece of text before putting it in the view or the current URL:</p>\n<pre><code>test <span class=\"string\">'@accessor can be called on a class to define how a property is calculated'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'summary'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'body'</span>).slice(<span class=\"number\">0</span>, <span class=\"number\">10</span>) + <span class=\"string\">\"...\"</span>\n\n  post = <span class=\"keyword\">new</span> Post(body: <span class=\"string\">\"Why Batman is Useful: A lengthy post on an important subject\"</span>)\n  equal post.get(<span class=\"string\">'summary'</span>), <span class=\"string\">\"Why Batman...\"</span></code></pre>\n<p>You can also use accessors to combine properties:</p>\n<pre><code>test <span class=\"string\">'@accessor can define a transform on several properties'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'fullName'</span>, -&gt; <span class=\"string\">\"<span class=\"subst\">#{@get('firstName')}</span> <span class=\"subst\">#{@get('lastName')}</span>\"</span>\n\n  tim = <span class=\"keyword\">new</span> User(firstName: <span class=\"string\">\"Tim\"</span>, lastName: <span class=\"string\">\"Thomas\"</span>)\n  equal tim.get(<span class=\"string\">'fullName'</span>), <span class=\"string\">\"Tim Thomas\"</span>\n  tim.set(<span class=\"string\">'firstName'</span>, <span class=\"string\">\"Timmy\"</span>)\n  equal tim.get(<span class=\"string\">'fullName'</span>), <span class=\"string\">\"Timmy Thomas\"</span></code></pre>\n<p>Accessors can define custom <code>get</code>, <code>set</code>, and <code>unset</code> functions to support each operation on the property:</p>\n<pre><code>test <span class=\"string\">'@accessor can define the get, set, and unset methods for the property'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbsoluteNumber</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'value'</span>,\n      get: -&gt; <span class=\"property\">@_value</span>\n      set: (_, value) -&gt; <span class=\"property\">@_value</span> = Math.abs(value)\n      unset: -&gt; <span class=\"keyword\">delete</span> <span class=\"property\">@_value</span>\n\n  number = <span class=\"keyword\">new</span> AbsoluteNumber(value: -<span class=\"number\">10</span>)\n  equal number.get(<span class=\"string\">'value'</span>), <span class=\"number\">10</span></code></pre>\n<p>It is also safe to use branching, loops, or whatever logic you want in accessor bodies:</p>\n<pre><code>test <span class=\"string\">'@accessor can use arbitrary logic to define the value'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'score'</span>, -&gt;\n      <span class=\"keyword\">if</span> <span class=\"property\">@get</span>(<span class=\"string\">'played'</span>)\n        (<span class=\"property\">@get</span>(<span class=\"string\">'goals'</span>) * <span class=\"number\">2</span>) + (<span class=\"property\">@get</span>(<span class=\"string\">'assists'</span>) * <span class=\"number\">1</span>)\n      <span class=\"keyword\">else</span>\n        <span class=\"number\">0</span>\n\n  rick = <span class=\"keyword\">new</span> Player(played: <span class=\"literal\">false</span>, goals: <span class=\"number\">0</span>, assists: <span class=\"number\">0</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">0</span>\n  rick.set(<span class=\"string\">'played'</span>, <span class=\"literal\">true</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">0</span>\n  rick.set(<span class=\"string\">'goals'</span>, <span class=\"number\">3</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">6</span>\n  rick.set(<span class=\"string\">'assists'</span>, <span class=\"number\">1</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">7</span></code></pre>\n"
  - title: Promise Accessors
    tokens: []
    id: promise_accessors
    html: "<p>If an accessor object has a <code>promise</code> key, it is a promise accessor. The <code>promise</code> function will be called with a <code>deliver</code> function as its only argument, which it must call with <code>(err, value)</code> when its operation is complete. For example:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">City</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n  <span class=\"property\">@accessor</span> <span class=\"string\">'population'</span>,\n    promise: (deliver) -&gt;\n      <span class=\"keyword\">new</span> Batman.Request\n        url: <span class=\"string\">\"/<span class=\"subst\">#{@get('name')}</span>/headcount\"</span>\n        success: (data) -&gt;\n          deliver(<span class=\"literal\">null</span>, data.population)\n        error: (err) -&gt;\n          deliver(err, <span class=\"literal\">null</span>)\n      <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>\n\ngotham = <span class=\"keyword\">new</span> City(name: <span class=\"string\">\"Gotham\"</span>)\n<span class=\"comment\"># we'll observe the property:</span>\ngotham.observe <span class=\"string\">'population'</span>, (newValue, oldValue) -&gt;\n  console.log(<span class=\"string\">\"Population of <span class=\"subst\">#{@get('name')}</span> is <span class=\"subst\">#{newValue}</span>\"</span>)\ngotham.get(<span class=\"string\">'population'</span>) <span class=\"comment\"># returns undefined, fires a XHR request to /Gotham/headcount</span>\n<span class=\"comment\"># when the request succeeds with {population: 10,000,001}...</span>\n<span class=\"comment\"># log: \"Population of Gotham is 10,000,001\"</span></code></pre>\n<p><strong>Note:</strong> If the <code>promise</code> function returns anything truthy, its return value will be treated as an early, synchronous return.</p>\n"
  - title: "Default accessor as \"doesNotUnderstand\" or \"method_missing\""
    tokens: []
    id: "default_accessor_as_%22doesnotunderstand%22_or_%22method_missing%22"
    html: "<p>The default accessor may be used as batman.js&#39;s analogue to the <a href=\"http://c2.com/cgi/wiki?DoesNotUnderstand\"><code>doesNotUnderstand</code></a>-<a href=\"http://www.ruby-doc.org/core-2.1.0/BasicObject.html#method-i-method_missing\"><code>method_missing</code></a>-<a href=\"http://docs.python.org/2/reference/datamodel.html#object.__getattr__\"><code>__getattr__</code></a> pattern. Whenever <code>get</code> or <code>set</code> is called on a <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a> for a <code>key</code> which doesn&#39;t have a defined accessor, the arguments are passed to the contructor&#39;s <code>defaultAccessor</code>:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">City</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n\ngotham = <span class=\"keyword\">new</span> City\ngotham.set(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Gotham\"</span>) <span class=\"comment\"># handled by City.defaultAccessor</span></code></pre>\n<p>The <a href=\"/docs/api/batman.property.html#class_property_defaultaccessor\">default implementation</a> of <code>defaultAccessor</code> simply stores the value. Calling <code>@accessor</code> without any <code>keys</code> redefines the <code>defaultAccessor</code> for that class:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">City</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n  <span class=\"property\">@accessor</span>\n    get: (key) -&gt; console.log(<span class=\"string\">\"Someone asked for <span class=\"subst\">#{key}</span>\"</span>)\n    set: (key, value) -&gt; console.log(<span class=\"string\">\"Someone tried to set <span class=\"subst\">#{key}</span> = <span class=\"subst\">#{value}</span>\"</span>)\n\ngotham = <span class=\"keyword\">new</span> City\ngotham.set(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"Gotham\"</span>)  <span class=\"comment\"># \"Someone tried to set name = Gotham\"</span>\ngotham.get(<span class=\"string\">\"name\"</span>)            <span class=\"comment\"># \"Someone asked for name\"</span></code></pre>\n<p>See the <a href=\"https://github.com/batmanjs/batman/blob/master/src/set/set_index.coffee#L24\">batman.js source for <code>SetIndex.accessor</code></a> for an example or redefining the default accessor.</p>\n"
  - title: Optimizing Accessors
    tokens: []
    id: optimizing_accessors
    html: "<h3 id=\"accessors-should-be-cachable-or-marked-cache-false-\">Accessors should be cachable or marked <code>cache: false</code>.</h3>\n<p>Batman.js memoizes the value of accessors and will not re-execute the body until one of the accessor&#39;s sources changes. If you need the accessor to recalculate every time the property is gotten, pass <code>cache: false</code>:</p>\n<pre><code>test <span class=\"string\">\"@accessor usually caches results\"</span>, -&gt;\n  counter = <span class=\"number\">0</span>\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'cachedCounter'</span>, -&gt; ++counter\n    <span class=\"property\">@accessor</span> <span class=\"string\">'notCachedCounter'</span>,\n      get: -&gt; ++counter\n      cache: <span class=\"literal\">false</span>\n\n  example = <span class=\"keyword\">new</span> Example()\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span>\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span>\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span>, <span class=\"string\">\"The second and third calls do not execute the function\"</span>\n  equal example.get(<span class=\"string\">'notCachedCounter'</span>), <span class=\"number\">2</span>\n  equal example.get(<span class=\"string\">'notCachedCounter'</span>), <span class=\"number\">3</span>, <span class=\"string\">\"Passing cache: false does re-execute the function\"</span>\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span></code></pre>\n<h3 id=\"accessors-_must_-use-get-to-access-their-sources\">Accessors <em>must</em> use <code>get</code> to access their sources</h3>\n<p>Batman.js tracks an accessor&#39;s sources by adding a global hook to all <code>get</code>s done, so if you don&#39;t use <code>get</code> to access properties on objects, your sources won&#39;t be registered.</p>\n<h3 id=\"accessors-should-rarely-return-new-objects\">Accessors should rarely return new objects</h3>\n<p>If you return a brand new object (ie, <code>new ...</code>), you run the risk of creating performance problems. This is because accessors are recomputed every time one of their sources changes and for every call to <code>set</code>. Instead of recomputing expensive things every time the accessor is called, use objects which do smart re-computation using observers.</p>\n<p>Practically, this translates to using things like:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"property\">@accessor</span> <span class=\"string\">'mergeSets'</span> -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'setA'</span>).merge(<span class=\"property\">@get</span>(<span class=\"string\">'setB'</span>)          <span class=\"comment\"># bad! (returns a new Batman.Set)</span>\n<span class=\"property\">@accessor</span> <span class=\"string\">'mergeSets'</span> -&gt; <span class=\"property\">@_union</span> ||= <span class=\"keyword\">new</span> SetUnion(<span class=\"property\">@get</span>(<span class=\"string\">'setA'</span>), <span class=\"property\">@get</span>(<span class=\"string\">'setB'</span>)) <span class=\"comment\"># good!</span></code></pre>\n"
tokens: []
id: batman.object_accessors
html: "<p>When defining a class that extends <a href=\"/docs/api/batman.object.html\"><code>Batman.Object</code></a>, <code>@accessor</code> defines properties of instances of that class:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Superhero</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n  <span class=\"property\">@accessor</span> <span class=\"string\">'name'</span>, <span class=\"string\">'hasCape'</span>                         <span class=\"comment\"># uses default accessor</span>\n  <span class=\"property\">@accessor</span> <span class=\"string\">'isBatman'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'name'</span>) <span class=\"keyword\">is</span> <span class=\"string\">'Batman'</span>   <span class=\"comment\"># defines a custom `get` function</span>\n\n  <span class=\"property\">@accessor</span> <span class=\"string\">'butler'</span>,                                 <span class=\"comment\"># defines `get` and `set` functions</span>\n    get: -&gt; <span class=\"property\">@_butler</span> ||= <span class=\"keyword\">if</span> <span class=\"property\">@get</span>(<span class=\"string\">'isBatman'</span>)\n          <span class=\"keyword\">new</span> Butler(name: <span class=\"string\">\"Alfred\"</span>)\n        <span class=\"keyword\">else</span>\n          <span class=\"keyword\">new</span> Butler(name: <span class=\"string\">\"Jeeves\"</span>)\n    set: (key, value) -&gt; <span class=\"property\">@_butler</span> = value\n\n  @::observe <span class=\"string\">'isBatman'</span> (newValue, oldValue) -&gt;       <span class=\"comment\"># prototype observes its own accessor</span>\n    <span class=\"keyword\">if</span> newValue <span class=\"keyword\">is</span> <span class=\"literal\">true</span>\n      console.log <span class=\"string\">\"Batman has arrived!\"</span></code></pre>\n<p><em>(<code>@classAccessor</code> provides the same functionality on the constructor.)</em></p>\n<p><code>@accessor</code> is a Batman- and old-browser-friendly version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">ES5 <code>Object.defineProperty</code></a>.</p>\n<p>Accessors <strong>track their sources</strong>. If an accessor&#39;s <code>get</code> function has other <code>get</code> calls inside it, the other property will be <a href=\"/docs/api/batman.property.html#source_tracking_by_batman.property\">registered as a source</a>. The accessor will be eagerly reevaluated when any of its sources change. In the example above, <code>isBatman</code> will be reevaluated when <code>name</code> changes. <code>butler</code> will be reevalutated too, but because the value is being cached manually, it won&#39;t actually change.</p>\n<p>Accessors can be <strong>observed</strong>. <a href=\"/docs/api/batman.property.html\"><code>Batman.Property</code></a> extends <a href=\"/docs/api/batman.event.html\"><code>Batman.Event</code></a>, which makes properties observable.</p>\n<p>Accessors are <strong>inherited</strong>, so accessors defined anywhere in an object&#39;s prototype chain will be used.</p>\n"

---

{{ page.html }}
<ul class="api-list">
{% for s in page.sub %}
  <li class="api-list-item">
    <h3 class="api-title">
      <a id="{{ s.id }}" class="anchor-target"></a>
      <a href="#{{ s.id }}" class="anchor-link">
      <span class="{% if s.meta %}monospace-heading{% endif %}">{% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}{% if s.meta.type == 'property' %}<span class="params">{{ s.meta.params }}</span>{% else %}<span class="params">({{ s.meta.params }})</span>  {% endif %}{% endif %}{% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}</span>
      </a>
    </h3>
    {{ s.html }}
  </li>
{% endfor %}
</ul>
