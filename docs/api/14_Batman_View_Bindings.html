---
layout: api_docs
title: Batman View Bindings
sub: 
  - title: How to use bindings
    tokens: []
    id: 14_0_How_to_use_bindings
    html: "<p>Bindings are declared as attributes on nodes under the <code>data</code> namespace. In practice, it looks like this:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></code></pre>\n<p>This instantiates a binding on the <code>div</code> node which will update the node&#39;s <code>innerHTML</code> with the value found at the <code>name</code> keypath in the <a href=\"#batman-view-bindings-binding-contexts\">current context</a>. Whenever the <code>name</code> key changes, the div&#39;s <code>innerHTML</code> will update to the new value.</p>\n<p>Nodes can have multiple bindings:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"body\"</span> <span class=\"attribute\">data-showif</span>=<span class=\"value\">\"isPublished\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>or attribute bindings:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-bind-id</span>=<span class=\"value\">\"currentID\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>and bindings can be on inputs which the user can change:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">input</span>&gt;</span></code></pre>\n<p>When the <code>title</code> property changes on the JavaScript object this <code>input</code> is bound to, the <code>input</code>&#39;s value will be updated. When the user types into the <code>input</code> (and <code>change</code> or <code>keyup</code> events are triggered), the <code>title</code> property in JavaScript land will be updated.</p>\n"
  - title: Binding Keypaths
    tokens: []
    id: 14_1_Binding_Keypaths
    html: "<p>A <code>keypath</code> is the value of the HTML attribute a binding references. Importantly, keypaths can have multiple segments:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"order.customer.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>The keypath in the above HTML is <code>order.customer.name</code>. When you create a binding to a keypath like this (with dots separating segments), the binding will update the HTML value when <em>any</em> of those segments change. In the above example, this means the <code>p</code> tag&#39;s <code>innerHTML</code> will be updated when:</p>\n<ol>\n<li>the order changes,</li>\n<li>the order&#39;s customer changes,</li>\n<li>or the order&#39;s customer&#39;s name changes.</li>\n</ol>\n<p>This is important because it means you can rely on a binding to &quot;just work&quot; when anything it depends on changes. If say you had a <code>&lt;select&gt;</code> on the page which changed the <code>order</code>&#39;s <code>customer</code> property, bindings which bind to <code>order.customer.name</code> will update each time you change that select to reflect the new customer&#39;s name.</p>\n"
  - title: Binding Contexts
    tokens: []
    id: 14_2_Binding_Contexts
    html: "<p>All bindings render in a context. Binding contexts, known internally to Batman as <code>RenderContext</code>s, are objects which emulate the notion of variable scope in JavaScript code. When a controller action renders, it passes a context to the view consisting of itself, the <code>App</code>, and an object with a <code>window</code> key pointing to the host <code>window</code> object.</p>\n"
  - title: Keypath Filters
    tokens: []
    id: 14_3_Keypath_Filters
    html: "<p>Bindings can bind to filtered keypaths:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"post.body | truncate 100\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n<p>The above <code>&lt;p&gt;</code> will have 100 characters worth of the post&#39;s body. Whenever the post&#39;s body changes, it will be retruncated and the <code>&lt;p&gt;</code>&#39;s <code>innerHTML</code> will be updated.</p>\n<p>Filter chains can be arbitrarily long:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"knight.title | prepend 'Sir' | append ', the honourable'.\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span></code></pre>\n<p>and filter chains can use other keypaths as arguments to the filters:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"person.name | prepend ' ' | prepend person.title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span></code></pre>\n<p>The above <code>&lt;span&gt;</code>&#39;s <code>innerHTML</code> will be updated whenever the person&#39;s name or title changes.</p>\n<h4>Two Way Bindings and Filters</h4>\n<p>Note that filtered keypaths cannot propagate DOM land changes because values can&#39;t always be &quot;unfiltered&quot;. For example, if we bind an input to the truncated version of a string:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"post.body | truncate 100\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">input</span>&gt;</span></code></pre>\n<p>The <code>&lt;input&gt;</code>&#39;s value can be updated when the <code>post.body</code> property changes but if a user types into this input field, they will edit the truncated body. If Batman updated the <code>post.body</code> property with the contents of the input, all characters which had been truncated will be lost to the nether. To avoid this loss of information and inconsistency, bindings to filtered keypaths will <em>only update from JavaScript land to HTML</em>, and never vice versa.</p>\n"
  - title: Keypath Literals
    tokens: []
    id: 14_4_Keypath_Literals
    html: "<p>Keypaths also support a select few literals within them. Numbers, strings, and booleans can be passed as arguments to filters or used as the actual value of the keypath.</p>\n<p>The following are all valid, albeit contrived, bindings:</p>\n<pre><code class=\"lang-html\"><span class=\"comment\">&lt;!-- String literal used as an argument --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"body | append ' ... '\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- Boolean literal used as an argument --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-showif</span>=<span class=\"value\">\"shouldShow | default true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- Number literal used as an argument --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"body | truncate 100\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- String literal used as the value --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"'Hardcoded'\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span>\n\n<span class=\"comment\">&lt;!-- Boolean literal used as the value --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">p</span> <span class=\"attribute\">data-showif</span>=<span class=\"value\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">p</span>&gt;</span></code></pre>\n"
  - title: "data-bind"
    tokens: []
    id: "14_5_data-bind"
    html: "<p><code>data-bind</code> creates a two way binding between a property on a <code>Batman.Object</code> and an HTML element. Bindings created via <code>data-bind</code> will update the HTML element with the value of the JS land property as soon as they are created and each time the property changes after, and if the HTML element can be observed for changes, it will update the JS land property with the value from the HTML.</p>\n<p><code>data-bind</code> will change its behaviour depending on what kind of tag it is attached to:</p>\n<ul>\n<li><code>&lt;input type=&quot;checkbox&quot;&gt;</code>: the binding will edit the <code>checked</code> property of the checkbox and populate the keypath with a boolean.</li>\n<li><code>&lt;input type=&quot;text&quot;&gt;</code> and similar, <code>&lt;textarea</code>&gt;: the binding will edit the <code>value</code> property of the input and populate the keypath with the string found at <code>value</code>.</li>\n<li><code>&lt;input type=&quot;file&quot;&gt;</code>: the binding will <em>not</em> edit the <code>value</code> property of the input, but it will update the keypath with a host <code>File</code> object or objects if the node has the <code>multiple</code> attribute.</li>\n<li><code>&lt;select&gt;</code>: the binding will edit the <code>selected</code> property of each <code>&lt;option&gt;</code> tag within the <code>&lt;select&gt;</code> matching the property at the keypath. If the <code>&lt;select&gt;</code> has the multiple attribute, the value at the keypath can be an array of selected <code>&lt;option&gt;</code> values. You can also use <code>data-bind-selected</code> bindings on the individual options to toggle option selectedness.</li>\n<li>All other tags: the binding will edit the <code>innerHTML</code> property of the tag and will not populate the keypath.</li>\n</ul>\n<p><code>data-bind</code> can also be used to bind an attribute of a node to a JavaScript property. Since attributes can&#39;t be observed for changes, this is a one way binding which will never update the JavaScript land property. Specify which attribute to bind using the &quot;double dash&quot; syntax like so: <code>data-bind-attribute=&quot;some.keypath&quot;</code>. For example, to bind the <code>placeholder</code> attribute of an input, use <code>data-bind-placeholder</code>.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">data-bind-placeholder</span>=<span class=\"value\">\"'Specify a subtitle for product ' | append product.name\"</span>&gt;</span></code></pre>\n<p><em>Note</em>: <code>data-bind</code> will not update a JavaScript property if filters are used in the keypath.</p>\n"
  - title: "data-source"
    tokens: []
    id: "14_6_data-source"
    html: "<p><code>data-source</code> creates a one way binding which propagates only changes from JavaScript land to the DOM, and never vice versa. <code>data-source</code> has the same semantics with regards to how it operates on different tags as <code>data-bind</code>, but it will only ever update the DOM and never the JavaScript land property.</p>\n<p>For example, the HTML below will never update the <code>title</code> property on the product, even if the user changes it. Each time the <code>title</code> attribute changes from a <code>set</code> in JavaScript land, the value of the input will be updated to the new value of <code>title</code>, erasing any potential changes that have been made to the value of the input by the user.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">data-source</span>=<span class=\"value\">\"product.title\"</span>&gt;</span></code></pre>\n<p><em>Note</em>: <code>data-source-attribute</code> is equivalent to <code>data-bind-attribute</code>, since the former is defined as never making JS land changes, and the latter is unable to.</p>\n"
  - title: "data-target"
    tokens: []
    id: "14_7_data-target"
    html: "<p><code>data-target</code> creates a one way binding which propagates only changes from the DOM to JavaScript land, and never vice versa. <code>data-target</code> has the same semantics with regards to how it operates on different tags as <code>data-bind</code>, but it will never update the DOM even if the JavaScript land value changes.</p>\n<p><em>Note</em>: <code>data-target-attribute</code> is unavailable, because DOM changes to node attributes can&#39;t be monitored.</p>\n"
  - title: "data-showif / data-hideif"
    tokens: []
    id: "14_8_data-showif_%2F_data-hideif"
    html: "<p><code>data-showif</code> and <code>data-hideif</code> bind to keypaths and show or hide the node they appear on based on the truthiness of the result. <code>data-showif</code> will show a node if the given keypath evaluates to something truthy, and <code>data-hideif</code> will leave a node visible until its given keypath becomes truthy, at which point the node will be hidden. <code>data-showif</code> and <code>data-hideif</code> show and hide nodes by adding <code>display: none !important;</code> to the node&#39;s <code>style</code> attribute.</p>\n<p>For example, if the HTML below is rendered where the keypath <code>product.published</code> evaluated to true, the <code>&lt;button&gt;</code> will be visible.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">button</span> <span class=\"attribute\">data-showif</span>=<span class=\"value\">\"product.published\"</span>&gt;</span>Unpublish Product<span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span></code></pre>\n<p>This is the Batman equivalent of a templating language&#39;s <code>if</code> construct, where else branches are implemented using the opposite binding.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">button</span> <span class=\"attribute\">data-showif</span>=<span class=\"value\">\"product.published\"</span>&gt;</span>Unpublish Product<span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">button</span> <span class=\"attribute\">data-hideif</span>=<span class=\"value\">\"product.published\"</span>&gt;</span>Publish Product<span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span></code></pre>\n"
  - title: "data-addclass / data-removeclass"
    tokens: []
    id: "14_9_data-addclass_%2F_data-removeclass"
    html: "<p><code>data-addclass</code> and <code>data-removeclass</code> bindings can be used to conditionally add or remove a class from a node based on a boolean keypath. Specify the class to add using the &quot;double dash&quot; syntax; for example,<code>data-addclass-big=&quot;some.keypath&quot;</code> on a node will add the &quot;big&quot; class to that node&#39;s classes if <code>some.keypath</code> is truthy. <code>data-removeclass</code> will remove a class (usually one which is present in the HTML) if the keypath passed to it is truthy.</p>\n<p>The outer span in the HTML below will have an &quot;error&quot; class when the <code>product.errors.length</code> keypath evaluates to anything other than 0, since 0 is falsy and other numbers are truthy.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-addclass-error</span>=<span class=\"value\">\"product.errors.length\"</span>&gt;</span>This product has <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"product.errors.length\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span> errors.<span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span></code></pre>\n"
  - title: "data-foreach"
    tokens: []
    id: "14_10_data-foreach"
    html: "<p><code>data-foreach</code> is used to loop over an iterable object in Batman views. <code>data-foreach</code> duplicates the node it occurs on for each item in the collection found at the keypath given to it, and renders each duplicated node with that node&#39;s object from the collection by putting it in the context under a name passed to it using the &quot;double dash&quot; syntax.</p>\n<p>The <code>&lt;option&gt;</code> node below will be duplicated for each item in the <code>Set</code> at the <code>products</code> keypath.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">select</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">data-foreach-product</span>=<span class=\"value\">\"products\"</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"product.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">select</span>&gt;</span></code></pre>\n<p>Batman will execute the <code>data-foreach</code> binding before the <code>data-bind</code> on the <code>&lt;option&gt;</code> node, which means that the <code>data-bind</code> will be processed for each duplicated node with each separate Product in the <code>products</code> Set in scope for each separate node. If there were say 3 Products in the <code>products</code> set, the HTML would look similar to this once rendered:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">select</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"product.name\"</span>&gt;</span>Product A<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"product.name\"</span>&gt;</span>Product B<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">option</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"product.name\"</span>&gt;</span>Product C<span class=\"tag\">&lt;/<span class=\"title\">option</span>&gt;</span>\n  <span class=\"comment\">&lt;!-- end products --&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">select</span>&gt;</span></code></pre>\n<p><code>data-foreach</code> can be used to iterate over <code>Batman.Set</code>s, and most often should be, because it observes any Sets and will update the DOM with new nodes if items are added to the set, or remove nodes from the DOM if their corresponding nodes are removed from the set. <code>data-foreach</code>, like every other binding, is keypath aware, such that if the <code>Set</code> instance at the keypath changes, or any previous segment of the keypath changes, <code>data-foreach</code> will remove all the nodes currently in the DOM, and add new nodes for each new item in the incoming <code>Set</code>.</p>\n<p>Sometimes you&#39;ll need to add some custom logic to the iteration nodes. For example, a custom <code>viewDidAppear</code> handler so you can know whenever a new iteration node appears in the DOM. You can do this by specifying a custom subclass of <code>Batman.IterationView</code>.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">ul</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">li</span> <span class=\"attribute\">data-foreach-product</span>=<span class=\"value\">\"products\"</span> <span class=\"attribute\">data-view</span>=<span class=\"value\">\"ProductIterationView\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"product.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"title\">li</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span>.<span class=\"title\">ProductIterationView</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">IterationView</span></span>\n  viewDidAppear: -&gt;\n    $(<span class=\"annotation\">@get</span>(<span class=\"string\">'node'</span>)).draggable()</code></pre>\n<p><em>Note</em>: <code>data-foreach</code> expects to find an iterable object at the keypath given to it, and will emit a warning if it finds <code>undefined</code>.</p>\n<p><em>Note</em>: <code>data-foreach</code> expects the passed enumerable to be unique. It creates a map of nodes to items, so every node needs to be able to reference exactly one object. If you simply have a set of values that you&#39;re iterating over, you should wrap your values in objects, e.g. <code>[{value: true}, {value: true}]</code>.</p>\n"
  - title: "data-formfor"
    tokens: []
    id: "14_11_data-formfor"
    html: "<p><code>data-formfor</code> creates a special addition to the context stack to represent an object under edit within a form. Usually this object is a model. Using the double dash syntax, the name for the model to reside under can be specified.</p>\n<p>==== Automatic Validation Display</p>\n<p><code>data-formfor</code> also has some handy functionality for displaying the result of validating the object under edit in the form. This will only be enabled if the object has an <code>errors</code> Set, like <code>Batman.Models</code> do.</p>\n<p>If a tag matching the relative selector <code>.errors</code> is found, it will populate this element with a list of the errors found during validation on the object. The selector for the errors container can be changed by adding a <code>data-errors-list</code> attribute with the value of the selector to the form with the <code>data-formfor</code> binding on it, or editing <code>Batman.DOM.FormBinding::defaultErrorsListSelector</code>.</p>\n<p>If value bindings are made using <code>data-bind</code> to attributes on the model within the form, automatic <code>data-addclass-error</code> bindings will be added to the elements on which the <code>data-bind</code> occurs to add the &quot;error&quot; class when the model has errors on the attribute which <code>data-bind</code> binds to.</p>\n<p>In the HTML below, an automatic <code>data-addclass-error</code> will be added to the <code>&lt;input&gt;</code> which activates when the <code>product</code> model has validation errors on the <code>name</code> attribute.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">form</span> <span class=\"attribute\">data-formfor-product</span>=<span class=\"value\">\"currentProduct\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">input</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"text\"</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"product.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">input</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">form</span>&gt;</span></code></pre>\n<p>The class which gets automatically added to inputs binding to invalid attributes can be customized by editing <code>Batman.DOM.FormBinding::errorClass</code>.</p>\n"
  - title: "data-context"
    tokens: []
    id: "14_12_data-context"
    html: "<p><code>data-context</code> bindings add the object found at the key to the context stack, optionally under a key using the double dash syntax.</p>\n<p>For example, if a <code>product</code> object exists in the current context, the <code>data-context</code> binding below will expose its attributes at the root level of the context:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">data-context</span>=<span class=\"value\">\"product\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"cost\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></code></pre>\n<p>Contexts added to the stack can also be scoped under a key using <code>data-context-</code>:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">data-context-currentProduct</span>=<span class=\"value\">\"product\"</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"currentProduct\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"currentProduct\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></code></pre>\n<p>This is a useful mechanism for passing local variables to partial views.</p>\n"
  - title: "data-event"
    tokens: []
    id: "14_13_data-event"
    html: "<p><code>data-event</code> bindings add DOM event listeners to the nodes they exist on which call the function found at the passed keypath. <code>data-event</code> bindings use the double dash syntax to specify the name of the event to listen for.</p>\n<p>In the HTML below, if the keypath <code>controller.nextAction</code> resolves to a function, that function will be executed each time the <code>&lt;button&gt;</code> element is clicked.</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">button</span> <span class=\"attribute\">data-event-click</span>=<span class=\"value\">\"controller.nextAction\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">button</span>&gt;</span></code></pre>\n<p>Functions which <code>data-event</code> calls will be passed the node and the <code>DOMEvent</code> object: <code>(node, event) -&gt;</code>.</p>\n<p><code>data-event</code> supports the following types of events formally and should &quot;do the right thing&quot; when attached to elements which fire these events:</p>\n<ul>\n<li>click</li>\n<li>doubleclick</li>\n<li>change</li>\n<li>submit</li>\n</ul>\n<p>If the event name used doesn&#39;t match the above events, the event name used will just fall through and be passed to <code>window.addEventListener</code>.</p>\n"
  - title: "data-route"
    tokens: []
    id: "14_14_data-route"
    html: "<p><code>data-route</code> bindings are used to dispatch a new controller action upon the clicking of the node they bind to. <code>data-route</code> expects to find either a string or a <code>NamedRouteQuery</code> at the keypath passed to it. With this route, it will add an event handler to the <code>click</code> action of the element which dispatches the route and prevents the default action of the DOMEvent. <code>data-route</code> will also populate the <code>href</code> attribute if it occurs on an <code>&lt;a&gt;</code> tag so that other functons like &quot;Copy Link Address&quot; and Alt+Click continue to work on the link.</p>\n<p>The first way to use <code>data-route</code> is by passing it a string, which can be built using filters or an accessor, but the preferred way is to use the <code>NamedRouteQuery</code>. These objects are generated for you by starting keypaths at the <code>App.routes</code> property. All <code>Batman.App</code>s have a <code>routes</code> property which holds a nested list of all the routes, which you descend into by passing various key segments and objects. Since the <code>App</code> object is present in the default context stack, <code>data-route</code> keypaths can just start with <code>routes</code>.</p>\n<p>For example, assume the following routes definition in the current <code>Batman.App</code>:</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Alfred</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">App</span>\n  @<span class=\"title\">resources</span> '<span class=\"title\">todos</span>'</code></pre>\n<p>This means that routes like <code>/todos</code> and <code>/todos/:id</code> exist. To route to the collection action, use the plural name of the resource:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">a</span> <span class=\"attribute\">data-route</span>=<span class=\"value\">\"routes.todos\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">a</span>&gt;</span></code></pre>\n<p>To route to an individual todo things get a bit more complicated. If we have a Todo model with ID# <code>42</code> in the context as <code>todo</code>, use the <code>get</code> filter shorthand on the <code>NamedRouteQuery</code> returned by <code>routes.todos</code> to generate a member route:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">a</span> <span class=\"attribute\">data-route</span>=<span class=\"value\">\"routes.todos[todo]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">a</span>&gt;</span></code></pre>\n<p>Underneath, this is calling <code>Alfred.get(&#39;routes.todos&#39;).get(todo)</code>; the todo object is being passed as a key to the <code>NamedRouteQuery</code>, which knows how to generate a member route when given a record. The above HTML when rendered will look like this:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">a</span> <span class=\"attribute\">data-route</span>=<span class=\"value\">\"routes.todos[todo]\"</span> <span class=\"attribute\">href</span>=<span class=\"value\">\"/todos/42\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">a</span>&gt;</span></code></pre>\n<p>This syntax can be extended to nested routes. If we have nested routes, we can use chained gets to generated nested routes</p>\n<pre><code class=\"lang-coffeescript\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tracker</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">App</span>\n  @<span class=\"title\">resources</span> '<span class=\"title\">villains</span>', -&gt;\n    @<span class=\"title\">resources</span> '<span class=\"title\">crimes</span>'</code></pre>\n<p>Routes for collection and member crimes should look like <code>/villains/:villain_id/crimes</code> and <code>/villains/:villain_id/crimes/:id</code> respectively. Assuming the presence of a <code>villain</code> and a <code>crime</code> in the context, chained <code>get</code>s on <code>NamedRouteQuery</code>s achieve this:</p>\n<pre><code class=\"lang-html\"><span class=\"comment\">&lt;!-- Collection of crimes for a particular villain --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">a</span> <span class=\"attribute\">data-route</span>=<span class=\"value\">\"routes.villains[villain].crimes\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">a</span>&gt;</span>\n<span class=\"comment\">&lt;!-- One crime of a particular villain --&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">a</span> <span class=\"attribute\">data-route</span>=<span class=\"value\">\"routes.villains[villain].crimes[crime]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">a</span>&gt;</span></code></pre>\n<p><em>Note</em>: <code>data-route</code> bindings route only to internal dispatch, and not external links. Use a regular <code>&lt;a&gt;</code> tag to link away from the application.</p>\n"
  - title: "data-view"
    tokens: []
    id: "14_15_data-view"
    html: "<p><code>data-view</code> bindings attach custom <code>Batman.View</code> instances or instantiate custom <code>View</code> subclasses to / on a node. <code>data-view</code> expects either a <code>Batman.View</code> instance or subclass at the keypath passed to it. If an instance is passed, it will <code>set</code> the <code>node</code> property of the view to the node the <code>data-view</code> occurs on. If a class is passed, that class will be instantiated with the context the <code>data-view</code> binding executed in and with the node it occurred upon. See <code>Batman.View</code> for more information on custom Views and their uses.</p>\n<p><em>Note</em>: <code>data-view</code> bindings will bind to the passed keypath until it exists, that is to say until the value of it is not <code>undefined</code>. After the <code>View</code> has been set up, the <code>data-view</code> binding will remove itself and stop observing the keypath.</p>\n"
  - title: "data-partial"
    tokens: []
    id: "14_16_data-partial"
    html: "<p><code>data-partial</code> pulls in a partial template and renders it in the current context of the node the <code>data-partial</code> occurs in. <code>data-partial</code> expects the name of the view to render in the value of the HTML attribute. <strong>Warning</strong>: This value is not a keypath. The HTML attribute&#39;s value is interpreted as a string, and the template which resides at that view path will be rendered.</p>\n<p>If we have this HTML at <code>views/villains/_stub.html</code> in our app:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">span</span> <span class=\"attribute\">data-bind</span>=<span class=\"value\">\"villain.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">span</span>&gt;</span></code></pre>\n<p>and in <code>views/villains/show.html</code> we have this HTML:</p>\n<pre><code class=\"lang-html\"><span class=\"tag\">&lt;<span class=\"title\">h1</span>&gt;</span>A villain!<span class=\"tag\">&lt;/<span class=\"title\">h1</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"title\">div</span> <span class=\"attribute\">data-partial</span>=<span class=\"value\">\"villains/_stub\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">div</span>&gt;</span></code></pre>\n<p>the contents of the <code>stub</code> partial will be inserted and rendered in the <code>&lt;div&gt;</code> above.</p>\n"
  - title: "data-mixin"
    tokens: []
    id: "14_17_data-mixin"
    html: ""
  - title: "data-defineview"
    tokens: []
    id: "14_18_data-defineview"
    html: ""
  - title: "data-renderif"
    tokens: []
    id: "14_19_data-renderif"
    html: ""
  - title: "data-yield"
    tokens: []
    id: "14_20_data-yield"
    html: ""
  - title: "data-contentfor"
    tokens: []
    id: "14_21_data-contentfor"
    html: ""
  - title: "data-replace"
    tokens: []
    id: "14_22_data-replace"
    html: ""
tokens: []
id: 14_Batman_View_Bindings
html: "<p>Batman&#39;s view bindings are how data gets shown and collected from the user. They center on the notion of &quot;bindings&quot;: that the view representation and the JavaScript land value are always guaranteed to be in sync, such that when one changes, the other will reflect it.</p>\n"

---

{{ page.html }}
{% for s in page.sub %}
  <h3 id="{{ s.id }}">{{ s.title }}</h3>
  {{ s.html }}
{% endfor %}
