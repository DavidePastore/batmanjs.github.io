---
layout: api_docs
title: Batman.Object
sub: 
  - title: accessor
    tokens: []
    meta: 
      type: function
      level: class
      params: "[keys...], objectOrFunction"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: class_function_accessor
    html: "<p>Accessors are used to create properties on a class, prototype, or instance which can be fetched, set, and unset. These properties can be static, computed as functions of the other properties on the object the accessor belongs to, or properties of any Batman object in the system. <code>accessor</code> is a Batman and old browser friendly version of ES5 <code>Object.defineProperty</code>.</p>\n<p>The value of custom accessors can be observed just like any property. Accessors also track which other properties they rely on for computation, and recalculate eagerly when those other properties change. This way, when a source value is changed, any dependent accessors will automatically update any bindings to them with a new value. Accessors accomplish this feat by tracking <code>get</code> calls, so be sure to use <code>get</code> to retrieve properties on Batman Objects inside accessors so those properties can be tracked as dependencies. The property dependencies of an accessor are called &quot;sources&quot; in the Batman world.</p>\n<p>Importantly, accessors are also inherited, so accessors defined anywhere in an object&#39;s prototype chain will be used. Following this, <code>@accessor</code> is meant to be used during the class definition of a class extending <code>Batman.Object</code>.</p>\n<h4>Arguments</h4>\n<p><code>@accessor</code> can be called with zero, one, or many keys for the accessor to define. This has the following effects:</p>\n<ul>\n<li>zero: create a <code>defaultAccessor</code>, which will be called when no other properties or accessors on an object match a keypath. This is similar to <code>method_missing</code> in Ruby or <code>#doesNotUnderstand</code> in Smalltalk.</li>\n<li>one: create a <code>keyAccessor</code> at the given key, which will only be called when that key is gotten, set, or unset.</li>\n<li>many: create <code>keyAccessors</code> for each given key, which will then be called whenever each one of the listed keys is gotten, set, or unset.</li>\n</ul>\n<p><code>@accessor</code> accepts as the last argument either an object with any combination of the <code>get</code>, <code>set</code>, and <code>unset</code> keys defined, or a function. Functions which implement the behaviour for those particular actions on the property should reside at these keys. <code>@accessor</code> also accepts a function as the last argument, which is a shorthand for specifying the <code>get</code> implementation for the accessor.</p>\n<h4>Uses</h4>\n<p>Accessors are a really useful addition to the world of JavaScript. You can now define transforms on simple properties which will automatically update when the properties they transform change: for example, you might want to truncate a potentially long piece of text to display a summary elsewhere, or you might want to capitalize or <code>encodeURIComponent</code> a value before putting it in the view or the current URL.</p>\n<pre><code>test <span class=\"string\">'@accessor can be called on a class to define how a property is calculated'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'summary'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'body'</span>).slice(<span class=\"number\">0</span>, <span class=\"number\">10</span>) + <span class=\"string\">\"...\"</span>\n\n  post = <span class=\"keyword\">new</span> Post(body: <span class=\"string\">\"Why Batman is Useful: A lengthy post on an important subject\"</span>)\n  equal post.get(<span class=\"string\">'summary'</span>), <span class=\"string\">\"Why Batman...\"</span></code></pre>\n<p>You can also use accessors to combine properties; the colloquial <code>fullName</code> example comes to mind, but all sorts of other complex logic can be abstracted away using the accessor pattern.</p>\n<pre><code>test <span class=\"string\">'@accessor can define a transform on several properties'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'fullName'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'firstName'</span>) + <span class=\"string\">\" \"</span> + <span class=\"property\">@get</span>(<span class=\"string\">'lastName'</span>)\n\n  tim = <span class=\"keyword\">new</span> User(firstName: <span class=\"string\">\"Tim\"</span>, lastName: <span class=\"string\">\"Thomas\"</span>)\n  equal tim.get(<span class=\"string\">'fullName'</span>), <span class=\"string\">\"Tim Thomas\"</span>\n  tim.set(<span class=\"string\">'firstName'</span>, <span class=\"string\">\"Timmy\"</span>)\n  equal tim.get(<span class=\"string\">'fullName'</span>), <span class=\"string\">\"Timmy Thomas\"</span></code></pre>\n<p>Accessors can define custom <code>get</code>, <code>set</code>, and <code>unset</code> functions to support each operation on the property:</p>\n<pre><code>test <span class=\"string\">'@accessor can define the get, set, and unset methods for the property'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbsoluteNumber</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'value'</span>,\n      get: -&gt; <span class=\"property\">@_value</span>\n      set: (_, value) -&gt; <span class=\"property\">@_value</span> = Math.abs(value)\n      unset: -&gt; <span class=\"keyword\">delete</span> <span class=\"property\">@_value</span>\n\n  number = <span class=\"keyword\">new</span> AbsoluteNumber(value: -<span class=\"number\">10</span>)\n  equal number.get(<span class=\"string\">'value'</span>), <span class=\"number\">10</span></code></pre>\n<p>Importantly, it is also safe to use branching, loops, or whatever logic you want in accessor bodies:</p>\n<pre><code>test <span class=\"string\">'@accessor can use arbitrary logic to define the value'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'score'</span>, -&gt;\n      <span class=\"keyword\">if</span> <span class=\"property\">@get</span>(<span class=\"string\">'played'</span>)\n        (<span class=\"property\">@get</span>(<span class=\"string\">'goals'</span>) * <span class=\"number\">2</span>) + (<span class=\"property\">@get</span>(<span class=\"string\">'assists'</span>) * <span class=\"number\">1</span>)\n      <span class=\"keyword\">else</span>\n        <span class=\"number\">0</span>\n\n  rick = <span class=\"keyword\">new</span> Player(played: <span class=\"literal\">false</span>, goals: <span class=\"number\">0</span>, assists: <span class=\"number\">0</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">0</span>\n  rick.set(<span class=\"string\">'played'</span>, <span class=\"literal\">true</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">0</span>\n  rick.set(<span class=\"string\">'goals'</span>, <span class=\"number\">3</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">6</span>\n  rick.set(<span class=\"string\">'assists'</span>, <span class=\"number\">1</span>)\n  equal rick.get(<span class=\"string\">'score'</span>), <span class=\"number\">7</span></code></pre>\n<h4>Caveats</h4>\n<p>Accessors are extremely useful, but keep these items in mind when using them:</p>\n<ol>\n<li>Accessors should be pure functions so they are predictable and can be cached.</li>\n</ol>\n<p>Batman automatically memoizes the return value of accessors, and will not re-execute the body until one of the accessor&#39;s sources changes. If you need the accessor to recalculate every time the property is gotten, pass <code>false</code> for the <code>cache</code> option in the accessor descriptor object (the last argument to the <code>@accessor</code> function).</p>\n<pre><code>test <span class=\"string\">\"@accessor usually caches results\"</span>, -&gt;\n  counter = <span class=\"number\">0</span>\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'cachedCounter'</span>, -&gt; ++counter\n    <span class=\"property\">@accessor</span> <span class=\"string\">'notCachedCounter'</span>,\n      get: -&gt; ++counter\n      cache: <span class=\"literal\">false</span>\n\n  example = <span class=\"keyword\">new</span> Example()\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span>\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span>\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span>, <span class=\"string\">\"The second and third calls do not execute the function\"</span>\n  equal example.get(<span class=\"string\">'notCachedCounter'</span>), <span class=\"number\">2</span>\n  equal example.get(<span class=\"string\">'notCachedCounter'</span>), <span class=\"number\">3</span>, <span class=\"string\">\"Passing cache: false does re-execute the function\"</span>\n  equal example.get(<span class=\"string\">'cachedCounter'</span>), <span class=\"number\">1</span></code></pre>\n<ol>\n<li>Accessors <em>must</em> use <code>get</code> to access properties they use for computation</li>\n</ol>\n<p>Batman tracks an accessor&#39;s sources by adding a global hook to all <code>get</code>s done, so if you don&#39;t use <code>get</code> to access properties on objects, Batman can&#39;t know that that property is a source of the property your accessor defines, so it can&#39;t recompute that property when the source property changes. All properties on <code>Batman.Object</code> should be accessed using <code>get</code> and <code>set</code> whether or not the code occurs in an accessor body, but it is critical to do so in accessors so the sources of the accessor can be tracked.</p>\n<ol>\n<li>Accessors can create memory leaks or performance bottlenecks</li>\n</ol>\n<p>If you return a brand new object, say by merging a number of <code>Batman.Set</code>s or doing any sort of major and complete re-computation, you run the risk of creating performance problems. This is because accessors can be called frequently and unpredictably, as they are recomputed every time one of their sources changes and for every call to <code>set</code>. Instead of recomputing expensive things every time the accessor is called, try to use objects which do smart re-computation using observers. Practically, this translates to using things like <code>new SetUnion(@get(&#39;setA&#39;), @get(&#39;setB&#39;))</code> instead of <code>@get(&#39;setA&#39;).merge(@get(&#39;setB&#39;))</code> in an accessor body, since <code>SetUnion</code> will observe its constituents and update itself when they change, instead of the <code>merge</code> resulting in the accessor recomputing every time <code>setA</code> or <code>setB</code> changed.</p>\n"
  - title: classAccessor
    tokens: []
    meta: 
      type: function
      level: class
      params: "[keys...], objectOrFunction"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: class_function_classaccessor
    html: "<p><code>classAccessor</code> defines an accessor on the class: <code>get</code>s and <code>set</code>s done to the class will use the accessor definition as an implementation. <code>@accessor</code> called on a class will define an accessor for all instances of that class, whereas <code>@classAccessor</code> defines accessors on the class object itself. See <code>@accessor</code> for the details surrounding accessors.</p>\n<pre><code>test <span class=\"string\">'@classAccessor defines an accessor on the class'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonDooDad</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@classAccessor</span> <span class=\"string\">'instance'</span>, -&gt; <span class=\"keyword\">new</span> @()\n\n  instance = SingletonDooDad.get(<span class=\"string\">'instance'</span>)      <span class=\"comment\"># \"classAccessor defines accessors for gets done on the class its self\"</span>\n  ok SingletonDooDad.get(<span class=\"string\">'instance'</span>) == instance  <span class=\"comment\"># \"A second get returns the same instance\"</span></code></pre>\n"
  - title: mixin
    tokens: []
    meta: 
      type: function
      level: class
      params: objects...
      returnType: prototype
    id: class_function_mixin
    html: "<p><code>@mixin</code> is a handy function for mixing in <code>object</code>s to a class&#39; prototype. <code>@mixin</code> is implemented on top of the Batman level <code>mixin</code> helper, which means that keys from incoming <code>objects</code> will be applied using <code>set</code>, and any <code>initialize</code> functions on the <code>objects</code> will be called with the prototype being mixed into. Returns the prototype being mixed into.</p>\n<p><em>Note</em>: <code>@mixin</code>, similar to <code>@accessor</code>, applies to all instances of a class. If you need to mix in to the class itself, look at <code>classMixin</code>. <code>@mixin</code> is intended for use during the class definition of a <code>Batman.Object</code> subclass.</p>\n<pre><code>test <span class=\"string\">'@mixin extends the prototype of a Batman.Object subclass'</span>, -&gt;\n  FishBehaviour = {canBreathUnderwater: <span class=\"literal\">true</span>}\n  MammalBehaviour = {canBreathAboveWater: <span class=\"literal\">true</span>}\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Platypus</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@mixin</span> FishBehaviour, MammalBehaviour\n\n  platypus = <span class=\"keyword\">new</span> Platypus\n  ok platypus.get(<span class=\"string\">'canBreathAboveWater'</span>)\n  ok platypus.get(<span class=\"string\">'canBreathUnderwater'</span>)</code></pre>\n"
  - title: classMixin
    tokens: []
    meta: 
      type: function
      level: class
      params: objects...
      returnType: this
    id: class_function_classmixin
    html: "<p><code>@classMixin</code> allows mixing in objects to a class during that class&#39; definition. See <code>@mixin</code> for information about the arguments passed to mixin, but note that <code>@classMixin</code> applies to the class object itself, and <code>@mixin</code> applies to all instances of the class. Returns the class being mixed into.</p>\n<pre><code>test <span class=\"string\">'@classMixin extends the Batman.Object subclass'</span>, -&gt;\n  Singleton =\n    initialze: (subject) -&gt;\n      subject.accessor <span class=\"string\">'instance'</span>, -&gt; <span class=\"keyword\">new</span> subject\n\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Highlander</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@classMixin</span> Singleton\n\n  instance = Highlander.get(<span class=\"string\">'instance'</span>)\n  ok instance == Highlander.get(<span class=\"string\">'instance'</span>), <span class=\"string\">\"There can only be one.\"</span></code></pre>\n"
  - title: observeAll
    tokens: []
    meta: 
      type: function
      level: class
      params: "key, callback : function"
      returnType: prototype
    id: class_function_observeall
    html: "<p><code>@observeAll</code> extends the <code>Batman.Object</code> implementation of <code>Batman.Observable</code> with the ability to observe all instances of the class (and subclasses). Observers attached with <code>@observeAll</code> function exactly as if they were attached to the object directly. Returns the prototype of the class.</p>\n<p><em>Note</em>: <code>@observeAll</code> is intended to be used during the class definition for a <code>Batman.Object</code> subclass, but it can be called after the class has been defined as a function on the class. It supports being called after instances of the class have been instantiated as well.</p>\n<pre><code>test <span class=\"string\">\"@observeAll attaches handlers which get called upon change\"</span>, -&gt;\n  results = []\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@observeAll</span> <span class=\"string\">'length'</span>, (newValue, oldValue) -&gt; results.push newValue\n\n  song = <span class=\"keyword\">new</span> Song({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.set(<span class=\"string\">'length'</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual results[<span class=\"number\">1</span>], <span class=\"number\">200</span>\n\ntest <span class=\"string\">\"@observeAll can attach handlers after instance instantiation\"</span>, -&gt;\n  results = []\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n\n  song = <span class=\"keyword\">new</span> Song({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.set(<span class=\"string\">'length'</span>, <span class=\"number\">360</span>), <span class=\"number\">360</span>\n  deepEqual results[<span class=\"number\">0</span>], <span class=\"literal\">undefined</span>\n  Song.observeAll <span class=\"string\">'length'</span>, (newValue, oldValue) -&gt; results.push newValue\n  equal song.set(<span class=\"string\">'length'</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual results[<span class=\"number\">0</span>], <span class=\"number\">200</span></code></pre>\n"
  - title: constructor(objects...)
    tokens: []
    id: constructor(objects...)
    html: "<p>To create a new <code>Batman.Object</code>, the <code>Batman.Object</code> constructor can be used, or, the <code>Batman</code> namespace is also a utility function for creating Batman objects. Each object passed in to the constructor will have all its properties applied to the new <code>Batman.Object</code> using <code>get</code> and <code>set</code>, so any custom getters or setters will be respected. Objects passed in last will have precedence over objects passed in first in the event that they share the same keys. The property <code>copy</code> from these objects is shallow.</p>\n<pre><code>test <span class=\"string\">'Batman() function allows for handy creation of Batman.Objects'</span>, -&gt;\n  object = Batman(foo: <span class=\"string\">'bar'</span>)\n  equal <span class=\"keyword\">typeof</span> object.get, <span class=\"string\">'function'</span>\n\ntest <span class=\"string\">'Batman.Object constructor function accepts multiple mixin arguments and later mixins take precedence.'</span>, -&gt;\n  song = Batman({length: <span class=\"number\">100</span>, bpm: <span class=\"number\">120</span>}, {bpm: <span class=\"number\">130</span>})\n  equal song.get(<span class=\"string\">'length'</span>), <span class=\"number\">100</span>\n  equal song.get(<span class=\"string\">'bpm'</span>), <span class=\"number\">130</span>, <span class=\"string\">\"The property from the second object passed to the constructor overwrites that from the first.\"</span></code></pre>\n"
  - title: "toJSON() : object"
    tokens: []
    id: "tojson()_%3A_object"
    html: "<p><code>toJSON</code> returns a vanilla JavaScript object representing this <code>Batman.Object</code>.</p>\n<pre><code>test <span class=\"string\">'toJSON returns a vanilla JS object'</span>, -&gt;\n  object = Batman(foo: <span class=\"string\">'bar'</span>)\n  deepEqual object.toJSON(), {foo: <span class=\"string\">'bar'</span>}</code></pre>\n"
  - title: "hashKey() : string"
    tokens: []
    id: "hashkey()_%3A_string"
    html: "<p><code>hashKey</code> returns a unique string identifying this particular <code>Batman.Object</code>. No two <code>Batman.Object</code>s will have the same <code>hashKey</code>. Feel free to override the implmentation of this function on your objects if you have a better hashing scheme for a domain object of yours.</p>\n"
  - title: "batchAccessorChanges(key, wrappedFunction) : string"
    tokens: []
    id: "batchaccessorchanges(key%2C_wrappedfunction)_%3A_string"
    html: "<p>Prevents accessor from being recalculated while the specified function is called. Only after <code>wrappedFunction</code> is complete will the accessor be recomputed. Returns the result of <code>wrappedFunction</code>.</p>\n<p>This can be useful when making multiple changes, and only want a single change event fired after the modifications are in place.</p>\n"
  - title: "accessor([keys...], objectOrFunction)"
    tokens: []
    id: "accessor(%5Bkeys...%5D%2C_objectorfunction)"
    html: "<p><code>accessor</code> defines an accessor on one instance of an object instead of on all instances like the class level <code>@accessor</code>. See <code>@accessor</code> for the details surrounding accessors.</p>\n<pre><code>test <span class=\"string\">'accessor can be called on an instance of Batman.Object to define an accessor just on that instance'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n    <span class=\"property\">@accessor</span> <span class=\"string\">'summary'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'body'</span>).slice(<span class=\"number\">0</span>, <span class=\"number\">10</span>) + <span class=\"string\">\"...\"</span>\n\n  post = <span class=\"keyword\">new</span> Post(body: <span class=\"string\">\"Why Batman is Useful: A lengthy post on an important subject\"</span>)\n  equal post.get(<span class=\"string\">'summary'</span>), <span class=\"string\">\"Why Batman...\"</span>\n  post.accessor(<span class=\"string\">'longSummary'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'body'</span>).slice(<span class=\"number\">0</span>, <span class=\"number\">20</span>) + <span class=\"string\">\"...\"</span>)  <span class=\"comment\"># \"Instance level accessor defines accessors just for that instance\"</span>\n  equal post.get(<span class=\"string\">'longSummary'</span>), <span class=\"string\">\"Why Batman is Useful...\"</span>\n\ntest <span class=\"string\">'defining an accessor on an instance does not affect the other instances'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Post</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n\n  post = <span class=\"keyword\">new</span> Post(body: <span class=\"string\">\"Why Batman is Useful: A lengthy post on an important subject\"</span>)\n  otherPost = <span class=\"keyword\">new</span> Post(body: <span class=\"string\">\"Why State Machines Are Useful: Another lengthy post\"</span>)\n  post.accessor <span class=\"string\">'longSummary'</span>, -&gt; <span class=\"property\">@get</span>(<span class=\"string\">'body'</span>).slice(<span class=\"number\">0</span>, <span class=\"number\">20</span>) + <span class=\"string\">\"...\"</span>\n  equal post.get(<span class=\"string\">'longSummary'</span>), <span class=\"string\">\"Why Batman is Useful...\"</span>\n  equal otherPost.get(<span class=\"string\">'longSummary'</span>), <span class=\"literal\">undefined</span></code></pre>\n"
  - title: "mixin(objects...) : this"
    tokens: []
    id: "mixin(objects...)_%3A_this"
    html: "<p><code>mixin</code> extends the object it&#39;s called on with the passed <code>objects</code> using the <code>Batman.mixin</code> helper. Returns the object it&#39;s called upon.</p>\n<p><em>Note</em>: Since the <code>Batman.mixin</code> helper is used, mixin functionality like using <code>set</code> to apply properties and calling <code>initialize</code> functions is included in the instance level <code>mixin</code> function.</p>\n<pre><code>test <span class=\"string\">'mixin on an instance applies the keys from the mixed in object to the instance'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snake</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Object</span></span>\n\n  snake = <span class=\"keyword\">new</span> Snake()\n  snake.mixin {canSlither: <span class=\"literal\">true</span>}, {canHiss: <span class=\"literal\">true</span>}\n  ok snake.get(<span class=\"string\">'canSlither'</span>)\n  ok snake.get(<span class=\"string\">'canHiss'</span>)</code></pre>\n"
  - title: Batman.Observable
    tokens: []
    id: batman.observable
    html: "<p><code>Batman.Observable</code> is a mixin which gives objects the ability to notify subscribers to changes on its properties. <code>Observable</code> also adds functionality for observing <em>keypaths</em>: arbitrarily deeply nested properties on objects. All <code>Batman.Object</code>s, their subclasses and instances are observable by default.</p>\n"
  - title: isObservable
    tokens: []
    meta: 
      type: property
      level: prototype
      params: "[= true]"
      returnType: boolean
    id: prototype_property_isobservable
    html: "<p><code>isObservable</code> will return <code>true</code> when the current object is able to be observed, or <code>false</code> if it is not.</p>\n"
  - title: get
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "keypath: string"
      returnType: value
    id: prototype_function_get
    html: "<p>Retrieves the value at a <code>key</code> on an object. Accepts keypaths.</p>\n<p><em>Note</em>: <code>get</code> must be used for property access on any object in <code>Batman</code>&#39;s world. This is so that Batman can implement neat things like automatic dependency calculation for computed properties, property caching where it is safe, and smart storage mechanisms. With Batman, you must use <code>get</code> instead of the regular <code>.</code> for property access.</p>\n<pre><code>test <span class=\"string\">\"get retrieves properties on Batman objects\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n  equal song.get(<span class=\"string\">\"bpm\"</span>), <span class=\"number\">120</span>\n\ntest <span class=\"string\">\"get retrieves properties on nested Batman objects using keypaths\"</span>, -&gt;\n  post = <span class=\"keyword\">new</span> Batman.Object\n    text: <span class=\"string\">\"Hello World!\"</span>\n    author: <span class=\"keyword\">new</span> Batman.Object\n      name: <span class=\"string\">\"Harry\"</span>\n  equal post.get(<span class=\"string\">\"author.name\"</span>), <span class=\"string\">\"Harry\"</span>\n\ntest <span class=\"string\">\"get retrieves properties on Batman objects when . property access doesn't\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Model({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal <span class=\"keyword\">typeof</span> song.length, <span class=\"string\">\"undefined\"</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span></code></pre>\n"
  - title: set
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "keypath: string, newValue"
      returnType: newValue
    id: prototype_function_set
    html: "<p>Stores the <code>value</code> at a <code>key</code> on an object. Accepts keypaths. Returns the new value of the property.</p>\n<p><em>Note</em>: Once more, <code>set</code> must be used for property mutation on all objects in the <code>Batman</code> world. This is again so that Batman can implement useful functionality like cache busting, eager recalculation of computed properties, and smarter storage.</p>\n<p><em>Note</em>: Custom setters can mutate the value during setting, so the value which was passed to <code>set</code> and <code>set</code>&#39;s return value are not guaranteed to be identical.</p>\n<pre><code>test <span class=\"string\">\"set stores properties on batman objects.\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">1000</span>), <span class=\"number\">1000</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">1000</span>\n\ntest <span class=\"string\">\"set stores properties on nested Batman objects using keypaths\"</span>, -&gt;\n  author = <span class=\"keyword\">new</span> Batman.Object\n    name: <span class=\"string\">\"Harry\"</span>\n  post = <span class=\"keyword\">new</span> Batman.Object\n    text: <span class=\"string\">\"Hello World!\"</span>\n    author: author\n  equal post.set(<span class=\"string\">\"author.name\"</span>, <span class=\"string\">\"Nick\"</span>), <span class=\"string\">\"Nick\"</span>\n  equal author.get(<span class=\"string\">\"name\"</span>), <span class=\"string\">\"Nick\"</span>, <span class=\"string\">\"The value was set on the nested object.\"</span>\n\ntest <span class=\"string\">\"set is incompatible with '.' property mutation\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Model({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n  equal song.length = <span class=\"number\">1000</span>, <span class=\"number\">1000</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>, <span class=\"string\">\"The song length reported by Batman is unchanged because set wasn't used to change the value.\"</span></code></pre>\n"
  - title: unset
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "keypath: string"
      returnType: value
    id: prototype_function_unset
    html: "<p>Removes the value at the given <code>keypath</code>, leaving it <code>undefined</code>. Accepts keypaths. Returns the value the property had before unsetting.</p>\n<p><code>unset</code> is roughly equivalent to <code>set(keypath, undefined)</code>, however, custom properties can define a nonstandard <code>unset</code> function, so it is best to use <code>unset</code> instead of <code>set(keypath, undefined)</code> wherever possible.</p>\n<pre><code>test <span class=\"string\">\"unset removes the property on Batman objects\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n  equal song.unset(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"literal\">undefined</span>, <span class=\"string\">\"The value is unset.\"</span>\n\ntest <span class=\"string\">\"unset removes the property at a keypath\"</span>, -&gt;\n  author = <span class=\"keyword\">new</span> Batman.Object\n    name: <span class=\"string\">\"Harry\"</span>\n  post = <span class=\"keyword\">new</span> Batman.Object\n    text: <span class=\"string\">\"Hello World!\"</span>\n    author: author\n  equal post.unset(<span class=\"string\">\"author.name\"</span>), <span class=\"string\">\"Harry\"</span>\n  equal author.get(<span class=\"string\">\"name\"</span>), <span class=\"literal\">undefined</span>, <span class=\"string\">\"The value was unset on the nested object.\"</span></code></pre>\n"
  - title: getOrSet
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "keypath: string, valueFunction: Function"
      returnType: value
    id: prototype_function_getorset
    html: "<p>Assigns the <code>keypath</code> to the result of calling <code>valueFunction</code> if <code>keypath</code> is currently falsey. Returns the value of the property after the operation, whether it has changed or not. Equivalent to CoffeeScript&#39;s <code>||=</code> operator.</p>\n<pre><code>test <span class=\"string\">\"getOrSet doesn't set the property if it exists\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.getOrSet(<span class=\"string\">\"length\"</span>, -&gt; <span class=\"number\">500</span>), <span class=\"number\">340</span>\n  equal song.get(<span class=\"string\">\"length\"</span>), <span class=\"number\">340</span>\n\ntest <span class=\"string\">\"getOrSet sets the property if it is falsey\"</span>, -&gt;\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  equal song.getOrSet(<span class=\"string\">\"artist\"</span>, -&gt; <span class=\"string\">\"Elvis\"</span>), <span class=\"string\">\"Elvis\"</span>\n  equal song.get(<span class=\"string\">\"artist\"</span>), <span class=\"string\">\"Elvis\"</span></code></pre>\n"
  - title: observe
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key: string, observerCallback: Function"
      returnType: this
    id: prototype_function_observe
    html: "<p>Adds a handler to call when the value of the property at the <code>key</code> changes upon <code>set</code>ting. Accepts keypaths.</p>\n<p><code>observe</code> is the very core of Batman&#39;s usefulness. As long as <code>set</code> is used everywhere to do property mutation, any object can be observed for changes to its properties. This is critical to the concept of bindings, which Batman uses for its views.</p>\n<p>The <code>observerCallback</code> gets called with the arguments <code>newValue, oldValue</code>, whenever the <code>key</code> changes.</p>\n<p>Returns the object <code>observe</code> was called upon.</p>\n<pre><code>test <span class=\"string\">\"observe attaches handlers which get called upon change\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  song.observe <span class=\"string\">\"length\"</span>, (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">300</span>, <span class=\"number\">200</span>]</code></pre>\n<p><em>Note</em>: <code>observe</code> works excellently on keypaths. If you attach a handler to a &quot;deep&quot; keypath, it will fire when any segment of the keypath changes, passing in the new value at the end of the keypath.</p>\n<pre><code>test <span class=\"string\">\"observe attaches handlers which get called upon change\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  author = <span class=\"keyword\">new</span> Batman.Object\n    name: <span class=\"string\">\"Harry\"</span>\n  post = <span class=\"keyword\">new</span> Batman.Object\n    text: <span class=\"string\">\"Hello World!\"</span>\n    author: author\n  post.observe <span class=\"string\">\"author.name\"</span>, (newName, oldName) -&gt;\n    result = [newName, oldName]\n  newAuthor = <span class=\"keyword\">new</span> Batman.Object({name: <span class=\"string\">\"James\"</span>})\n  post.set <span class=\"string\">\"author\"</span>, newAuthor\n  deepEqual result, [<span class=\"string\">\"James\"</span>, <span class=\"string\">\"Harry\"</span>], <span class=\"string\">\"The observer fired when the 'author' segment of the keypath changed.\"</span></code></pre>\n"
  - title: observeAndFire
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key: string, observerCallback: Function"
      returnType: this
    id: prototype_function_observeandfire
    html: "<p>Adds the <code>observerCallback</code> as an observer to <code>key</code>, and fires it immediately. Accepts the exact same arguments and follows the same semantics as <code>Observable::observe</code>, but the observer is fired with the current value of the keypath it observes synchronously during the call to <code>observeAndFire</code>.</p>\n<p><em>Note</em>: During the initial synchronous firing of the <code>callback</code>, the <code>newValue</code> and <code>oldValue</code> arguments will be the same value: the current value of the property. This is because the old value of the property is not cached and therefore unavailable. If your observer needs the old value of the property, you must attach it before the <code>set</code> on the property happens.</p>\n<pre><code>test <span class=\"string\">\"observeAndFire calls the observer upon attaching it with the currentValue of the property\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  song.observeAndFire <span class=\"string\">\"length\"</span>, (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  deepEqual result, [<span class=\"number\">340</span>, <span class=\"number\">340</span>]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">300</span>, <span class=\"number\">340</span>]</code></pre>\n"
  - title: observeOnce
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key: string, observerCallback: Function"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_observeonce
    html: "<p>Behaves the same way as <code>Observable::observe</code>, except that once <code>observerCallback</code> has been executed for the first time, it will remove itself as an observer to <code>key</code>.</p>\n<pre><code>test <span class=\"string\">\"observeOnce only calls observerCallback when key is modified for the first time\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  song.observeOnce <span class=\"string\">\"length\"</span>, (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>]\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>], <span class=\"string\">\"The observer was not fired for the second update\"</span></code></pre>\n"
  - title: forget
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "[key: string[, observerCallback: Function]]"
      returnType: this
    id: prototype_function_forget
    html: "<p>If <code>observerCallback</code> and <code>key</code> are given, that observer is removed from the observers on <code>key</code>. If only a <code>key</code> is given, all observers on that key are removed. If no <code>key</code> is given, all observers on all keys are removed. Accepts keypaths.</p>\n<p>Returns the object on which <code>forget</code> was called.</p>\n<pre><code>test <span class=\"string\">\"forget removes an observer from a key if the key and the observer are given\"</span>, -&gt;\n  result = <span class=\"literal\">null</span>\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"function\"><span class=\"title\">observer</span></span> = (newValue, oldValue) -&gt; result = [newValue, oldValue]\n  song.observe <span class=\"string\">\"length\"</span>, observer\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>]\n  song.forget <span class=\"string\">\"length\"</span>, observer\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  deepEqual result, [<span class=\"number\">200</span>, <span class=\"number\">340</span>], <span class=\"string\">\"The logged values haven't changed because the observer hasn't fired again.\"</span>\n\ntest <span class=\"string\">\"forget removes all observers from a key if only the key is given\"</span>, -&gt;\n  results = []\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"function\"><span class=\"title\">observerA</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  <span class=\"function\"><span class=\"title\">observerB</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  song.observe <span class=\"string\">\"length\"</span>, observerA\n  song.observe <span class=\"string\">\"length\"</span>, observerB\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  equal results.length, <span class=\"number\">2</span>, <span class=\"string\">\"Both length observers fired.\"</span>\n  song.forget(<span class=\"string\">\"length\"</span>)\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  equal results.length, <span class=\"number\">2</span>, <span class=\"string\">\"Nothing more has been added because neither observer fired.\"</span>\n\ntest <span class=\"string\">\"forget removes all observers from all keys if no key is given\"</span>, -&gt;\n  results = []\n  song = <span class=\"keyword\">new</span> Batman.Object({length: <span class=\"number\">340</span>, bpm: <span class=\"number\">120</span>})\n  <span class=\"function\"><span class=\"title\">observerA</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  <span class=\"function\"><span class=\"title\">observerB</span></span> = ((newValue, oldValue) -&gt; results.push [newValue, oldValue])\n  song.observe <span class=\"string\">\"length\"</span>, observerA\n  song.observe <span class=\"string\">\"bpm\"</span>, observerB\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">200</span>), <span class=\"number\">200</span>\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"The length observer fired.\"</span>\n  song.forget()\n  equal song.set(<span class=\"string\">\"length\"</span>, <span class=\"number\">300</span>), <span class=\"number\">300</span>\n  equal song.set(<span class=\"string\">\"bpm\"</span>, <span class=\"number\">130</span>), <span class=\"number\">130</span>\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"Nothing more has been logged because neither observer fired.\"</span></code></pre>\n"
  - title: Batman.EventEmitter
    tokens: []
    id: batman.eventemitter
    html: "<p><code>EventEmitter</code> is a mixin which can be applied to any object to give it the ability to fire events and accept listeners for those events. All <code>Batman.Object</code>s, their subclasses and instances are <code>EventEmitter</code>s by default.</p>\n"
  - title: on
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "keys... : [string|Array], handler : Function"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_on
    html: "<p>Attaches a function <code>handler</code> to each event in the provided <code>keys</code> collection. This function will be executed when one of the specified events is fired.</p>\n<pre><code>test <span class=\"string\">'event handlers are added with `on`'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  ok dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">'detonated'</span>\n  dynamite.fire <span class=\"string\">'detonate'</span>\n  equal results[<span class=\"number\">0</span>], <span class=\"string\">'detonated'</span></code></pre>\n"
  - title: off
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "keys... : [string|Array], handler : Function"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_off
    html: "<p>Removes the <code>handler</code> function from the events specified in <code>keys</code>. If <code>handler</code> is not provided, all handlers will be removed from the specified event keys.</p>\n<pre><code>test <span class=\"string\">'event handlers are removed with off'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  <span class=\"function\"><span class=\"title\">handler</span></span> = -&gt; results.push <span class=\"string\">'This should not fire'</span>\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, handler\n  dynamite.<span class=\"literal\">off</span> <span class=\"string\">'detonate'</span>, handler\n  dynamite.fire <span class=\"string\">'detonate'</span>\n\n  deepEqual results, []\n\ntest <span class=\"string\">'If no `handler` is provided, off will remove all handlers from the specified events'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  <span class=\"function\"><span class=\"title\">handler</span></span> = -&gt; results.push <span class=\"string\">'This should not fire'</span>\n  <span class=\"function\"><span class=\"title\">anotherHandler</span></span> = -&gt; results.push <span class=\"string\">'Neither should this'</span>\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, handler\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, anotherHandler\n  dynamite.<span class=\"literal\">off</span> <span class=\"string\">'detonate'</span>\n  dynamite.fire <span class=\"string\">'detonate'</span>\n\n  deepEqual results, []</code></pre>\n"
  - title: fire
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string, arguments... : Array"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_fire
    html: "<p>Calls all previously attached handlers on the event with name <code>key</code>. All handlers will receive the passed <code>arguments</code>.</p>\n<p><em>Note</em>: Calling <code>fire</code> doesn&#39;t guarantee the event will fire since firing can be prevented with <code>prevent</code>.</p>\n<pre><code>test <span class=\"string\">'event handlers are fired'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, (noise) -&gt; results.push <span class=\"string\">\"detonated with noise <span class=\"subst\">#{noise}</span>\"</span>\n  dynamite.fire <span class=\"string\">'detonate'</span>, <span class=\"string\">\"BOOM!\"</span>\n  equal results[<span class=\"number\">0</span>], <span class=\"string\">\"detonated with noise BOOM!\"</span></code></pre>\n"
  - title: hasEvent
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string"
      returnType: boolean
    id: prototype_function_hasevent
    html: "<p>Asks if the <code>EventEmitter</code> has an event with the given <code>key</code>.</p>\n<pre><code>test <span class=\"string\">'events can be tested for presence'</span>, -&gt;\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; log <span class=\"string\">\"detonated\"</span>\n  ok dynamite.hasEvent(<span class=\"string\">'detonate'</span>)\n  equal dynamite.hasEvent(<span class=\"string\">'click'</span>), <span class=\"literal\">false</span></code></pre>\n"
  - title: once
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string, handler : Function"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_once
    html: "<p>Allows the specified handler to be fired only once before it is removed</p>\n<pre><code>test <span class=\"string\">'handlers added using `once` are removed after they are fired'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.once <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">'BOOM!'</span>\n  ok dynamite.hasEvent(<span class=\"string\">'detonate'</span>)\n  dynamite.fire <span class=\"string\">'detonate'</span>\n  equal results[<span class=\"number\">0</span>], <span class=\"string\">'BOOM!'</span>\n  dynamite.fire <span class=\"string\">'detonate'</span>\n  equal results[<span class=\"number\">1</span>], <span class=\"literal\">undefined</span></code></pre>\n"
  - title: prevent
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string"
      returnType: EventEmitter
    id: prototype_function_prevent
    html: "<p>Prevents the event with name <code>key</code> from firing, even if <code>fire</code> is called. This is useful if you need to guarantee a precondition has been fulfilled before allowing event handlers to execute. Returns the event emitting object.</p>\n<p>Undo event prevention with <code>allow</code> or <code>allowAndFire</code>.</p>\n<p><em>Note</em>: <code>prevent</code> can be called more than once to effectively &quot;nest&quot; preventions. <code>allow</code> or <code>allowAndFire</code> must be called the same number of times or more for events to fire once more.</p>\n<pre><code>test <span class=\"string\">'events can be prevented'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">\"This shouldn't fire\"</span>\n  dynamite.fire(<span class=\"string\">'detonate'</span>)\n  equal results[<span class=\"number\">0</span>], <span class=\"literal\">undefined</span>, <span class=\"string\">\"The event handler wasn't fired.\"</span>\n\ntest <span class=\"string\">'prevent returns the event emitter'</span>, -&gt;\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  equal dynamite, dynamite.prevent(<span class=\"string\">'detonate'</span>)</code></pre>\n"
  - title: allow
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string"
      returnType: EventEmitter
    id: prototype_function_allow
    html: "<p>Allows the event with name <code>key</code> to fire, after <code>prevent</code> had been called. <code>allow</code> will not fire the event when called, regardless of whether or not the event can now be fired or if an attempt to fire it was made while the event was prevented. Returns the event emitting object.</p>\n<p><em>Note</em>: <code>prevent</code> can be called more than once to effectively &quot;nest&quot; preventions. <code>allow</code> or <code>allowAndFire</code> must be called the same number of times or more for events to fire once more.</p>\n<pre><code>test <span class=\"string\">'events can be allowed after prevention'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">\"This will only fire once\"</span>\n\n  dynamite.fire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">0</span>, <span class=\"string\">\"The event handler wasn't fired.\"</span>\n  dynamite.allow(<span class=\"string\">'detonate'</span>)\n  dynamite.fire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"The event handler was fired.\"</span>\n\ntest <span class=\"string\">'events must be allowed the same number of times they have been prevented'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">\"This will only fire once\"</span>\n  dynamite.fire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">0</span>, <span class=\"string\">\"The event handler wasn't fired, the prevent count is at 2.\"</span>\n  dynamite.allow(<span class=\"string\">'detonate'</span>)\n  dynamite.fire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">0</span>, <span class=\"string\">\"The event handler still wasn't fired, but the prevent count is now at 1.\"</span>\n  dynamite.allow(<span class=\"string\">'detonate'</span>)\n  dynamite.fire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"The event handler was fired.\"</span>\n\ntest <span class=\"string\">'allow returns the event emitter'</span>, -&gt;\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  equal dynamite, dynamite.allow(<span class=\"string\">'detonate'</span>)</code></pre>\n"
  - title: allowAndFire
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_allowandfire
    html: "<p>Allows the event with name <code>key</code> to fire once more, and tries to fire it. <code>allowAndFire</code> may fail to fire the event if <code>prevent</code> has been called more times for this event than <code>allow</code> or <code>allowAndFire</code> have.</p>\n<pre><code>test <span class=\"string\">'events can be allowed and fired after prevention'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">\"This will only fire once\"</span>\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  dynamite.fire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">0</span>, <span class=\"string\">\"The event handler wasn't fired.\"</span>\n  dynamite.allowAndFire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"The event handler was fired.\"</span>\n\ntest <span class=\"string\">'events must be allowed and fired the same number of times they have been prevented'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">\"This will only fire once\"</span>\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  dynamite.allowAndFire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">0</span>, <span class=\"string\">\"The event handler wasn't fired.\"</span>\n  dynamite.allowAndFire(<span class=\"string\">'detonate'</span>)\n  equal results.length, <span class=\"number\">1</span>, <span class=\"string\">\"The event handler was fired.\"</span></code></pre>\n"
  - title: isPrevented
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "key : string"
      returnType: boolean
    id: prototype_function_isprevented
    html: "<p>Asks if the specified event is currently being prevented from firing</p>\n<pre><code>test <span class=\"string\">'isPrevented is true after prevent is called'</span>, -&gt;\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">\"This will only fire once\"</span>\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  equal dynamite.isPrevented(<span class=\"string\">'detonate'</span>), <span class=\"literal\">true</span>\n\ntest <span class=\"string\">'isPrevented is false if all prevents have been nullified using `allow`'</span>, -&gt;\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'detonate'</span>, -&gt; results.push <span class=\"string\">\"This will only fire once\"</span>\n  dynamite.prevent(<span class=\"string\">'detonate'</span>)\n  equal dynamite.isPrevented(<span class=\"string\">'detonate'</span>), <span class=\"literal\">true</span>\n  dynamite.allow(<span class=\"string\">'detonate'</span>)\n  equal dynamite.isPrevented(<span class=\"string\">'detonate'</span>), <span class=\"literal\">false</span></code></pre>\n"
  - title: mutate
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "wrappedFunction : Function"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_mutate
    html: "<p>Prevents change events from firing while the specified function is called. Only after <code>wrappedFunction</code> is complete will the <code>change</code> event be fired. Returns the result of <code>wrappedFunction</code>.</p>\n<p>This can be useful when making multiple changes, and only want a single change event fired after the modifications are in place.</p>\n<pre><code>test <span class=\"string\">'mutate fires a single change event, regardless of the logic in wrappedFunction'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'change'</span>, -&gt; results.push <span class=\"string\">'Change event was fired'</span>\n  <span class=\"function\"><span class=\"title\">mutateFunction</span></span> = -&gt;\n    dynamite.fire(<span class=\"string\">'change'</span>)\n    dynamite.fire(<span class=\"string\">'change'</span>)\n  dynamite.mutate(mutateFunction)\n  equal results.length, <span class=\"number\">1</span>\n\ntest <span class=\"string\">'mutate returns the result of wrappedFunction'</span>, -&gt;\n  results = []\n  dynamite = Batman.mixin {}, Batman.EventEmitter\n  dynamite.<span class=\"literal\">on</span> <span class=\"string\">'change'</span>, -&gt; results.push <span class=\"string\">'Change event was fired'</span>\n  <span class=\"function\"><span class=\"title\">mutateFunction</span></span> = -&gt; <span class=\"string\">'BOOM!'</span>\n  mutateResult = dynamite.mutate(mutateFunction)\n  equal mutateResult, <span class=\"string\">'BOOM!'</span></code></pre>\n"
  - title: mutation
    tokens: []
    meta: 
      type: function
      level: prototype
      params: "wrappedFunction : Function"
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_function_mutation
    html: "<p>A helper method that returns a function that will call <code>wrappedFunction</code> and fires the change event when complete (if it is present).</p>\n<p><em>Note</em>: the returned function does not block the change event from firing due to the logic in <code>wrappedFunction</code>. To ignore/block change events, use <code>prevent(&#39;change&#39;)</code>.</p>\n<pre><code>test <span class=\"string\">'mutation returns a function that wraps the provided wrappedFunction'</span>, -&gt;\n  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">extends</span> <span class=\"title\">Batman</span>.<span class=\"title\">Model</span></span>\n    <span class=\"property\">@resourceName</span>: <span class=\"string\">'person'</span>\n    <span class=\"property\">@encode</span> <span class=\"string\">'name'</span>\n    <span class=\"property\">@persist</span> TestStorageAdapter, storage: []\n\n    transform: <span class=\"property\">@mutation</span> -&gt;\n      <span class=\"property\">@name</span> = <span class=\"string\">'Batman'</span>\n\n  results = []\n  <span class=\"function\"><span class=\"title\">verifyTransformation</span></span> = -&gt;\n    equal <span class=\"property\">@name</span>, <span class=\"string\">'Batman'</span>\n\n  person = Person.findOrCreate({name: <span class=\"string\">'Bruce Wayne'</span>})\n  person.<span class=\"literal\">on</span> <span class=\"string\">'change'</span>, verifyTransformation\n  person.transform()</code></pre>\n"
  - title: isEventEmitter
    tokens: []
    meta: 
      type: property
      level: prototype
      params: !<tag:yaml.org,2002:js/undefined> ""
      returnType: !<tag:yaml.org,2002:js/undefined> ""
    id: prototype_property_iseventemitter
    html: "<p>Always true. Useful for testing whether a specific object instance uses the EventEmitter mixin.</p>\n"
tokens: []
id: batman.object
html: "<p><code>Batman.Object</code> is the superclass for virtually all objects in a Batman application. <code>Batman.Object</code> mixes in <code>Batman.Observable</code> and <code>Batman.EventEmitter</code> for things like <code>get</code>, <code>set</code>, <code>observe</code>, and <code>fire</code>, and then defines some more useful things for tying everything together.</p>\n"

---

{{ page.html }}
<ul class="api-list">
{% for s in page.sub %}
  <li class="api-list-item">
    <h3 class="api-title">
      <a id="{{ s.id }}" class="anchor-target"></a>
      <a href="#{{ s.id }}" class="anchor-link">
      <span class="{% if s.meta %}monospace-heading{% endif %}">{% if s.meta.level == 'class' %}@{% endif %}{{ s.title }}{% if s.meta.params %}{% if s.meta.type == 'property' %}<span class="params">{{ s.meta.params }}</span>{% else %}<span class="params">({{ s.meta.params }})</span>  {% endif %}{% endif %}{% if s.meta.returnType %}<span class="return-type"> : {{ s.meta.returnType }}</span>{% endif %}</span>
      </a>
    </h3>
    {{ s.html }}
  </li>
{% endfor %}
</ul>
